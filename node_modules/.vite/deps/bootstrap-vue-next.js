import {
  Fragment,
  Teleport,
  Transition,
  computed,
  createApp,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createSlots,
  createTextVNode,
  createVNode,
  defineComponent,
  getCurrentInstance,
  getCurrentScope,
  guardReactiveProps,
  h,
  inject,
  isReactive,
  isRef,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onActivated,
  onBeforeUnmount,
  onMounted,
  onScopeDispose,
  onUnmounted,
  openBlock,
  provide,
  reactive,
  readonly,
  ref,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDynamicComponent,
  shallowReadonly,
  shallowRef,
  toDisplayString,
  toHandlers,
  toRef,
  unref,
  useAttrs,
  useSlots,
  vModelCheckbox,
  vModelRadio,
  vModelSelect,
  vShow,
  watch,
  watchEffect,
  withCtx,
  withDirectives,
  withKeys,
  withModifiers
} from "./chunk-GPXMV72R.js";

// node_modules/bootstrap-vue-next/dist/bootstrap-vue-next.mjs
var Dn = Object.defineProperty;
var jn = (e, t, a) => t in e ? Dn(e, t, { enumerable: true, configurable: true, writable: true, value: a }) : e[t] = a;
var xe = (e, t, a) => (jn(e, typeof t != "symbol" ? t + "" : t, a), a);
var Zn = (e) => typeof e == "boolean" || e === "" || e === "true" || e === "false";
var so = (e) => typeof e == "boolean" ? e : e === "" ? true : e === "true";
var Xe = class _Xe {
  constructor(t, a = {}) {
    xe(this, "cancelable", true);
    xe(this, "componentId", null);
    xe(this, "_defaultPrevented", false);
    xe(this, "eventType", "");
    xe(this, "nativeEvent", null);
    xe(this, "_preventDefault");
    xe(this, "relatedTarget", null);
    xe(this, "target", null);
    if (!t)
      throw new TypeError(
        `Failed to construct '${this.constructor.name}'. 1 argument required, ${arguments.length} given.`
      );
    Object.assign(this, _Xe.Defaults, a, { eventType: t }), this._preventDefault = function() {
      this.cancelable && (this.defaultPrevented = true);
    };
  }
  // Readable by everyone,
  // But only overwritten by inherrited constructors
  get defaultPrevented() {
    return this._defaultPrevented;
  }
  set defaultPrevented(t) {
    this._defaultPrevented = t;
  }
  // I think this is right
  // We want to be able to have it callable to everyone,
  // But only overwritten by inherrited constructors
  get preventDefault() {
    return this._preventDefault;
  }
  // This may not be correct, because it doesn't get correct type inferences in children
  // Ex overwrite this.preventDefault = () => true is valid. Could be a TS issue
  set preventDefault(t) {
    this._preventDefault = t;
  }
  static get Defaults() {
    return {
      cancelable: true,
      componentId: null,
      eventType: "",
      nativeEvent: null,
      relatedTarget: null,
      target: null
    };
  }
};
var Ft = class extends Xe {
  constructor(a, l = {}) {
    super(a, l);
    xe(this, "trigger", null);
    Object.assign(this, Xe.Defaults, l, { eventType: a });
  }
  static get Defaults() {
    return {
      ...super.Defaults,
      trigger: null
    };
  }
};
var io = class extends Xe {
  constructor(a, l) {
    super(a, l);
    xe(this, "from");
    xe(this, "to");
    xe(this, "direction");
    Object.assign(this, Xe.Defaults, l, { eventType: a });
    const { from: o, direction: n, to: r } = l;
    this.from = o, this.to = r, this.direction = n;
  }
  static get Defaults() {
    return {
      ...super.Defaults
    };
  }
};
var ga = (e) => e !== null && typeof e == "object";
var ro = (e) => /^[0-9]*\.?[0-9]+$/.test(String(e));
var Qn = (e) => Object.prototype.toString.call(e) === "[object Object]";
var uo = /_/g;
var co = /([a-z])([A-Z])/g;
var es = /(\s|^)(\w)/g;
var ts = /(\s|^)(\w)/;
var jt = /\s+/;
var as = /^#/;
var ls = /^#[A-Za-z]+[\w\-:.]*$/;
var os = /-u-.+/;
var Gt = (e, t = 2) => typeof e == "string" ? e : e == null ? "" : Array.isArray(e) || Qn(e) && e.toString === Object.prototype.toString ? JSON.stringify(e, null, t) : String(e);
var Qa = (e) => e.replace(uo, " ").replace(co, (t, a, l) => `${a} ${l}`).replace(ts, (t, a, l) => a + l.toUpperCase());
var el = (e) => e.replace(uo, " ").replace(co, (t, a, l) => `${a} ${l}`).replace(es, (t, a, l) => a + l.toUpperCase());
var ns = (e) => {
  const t = e.trim();
  return t.charAt(0).toUpperCase() + t.slice(1);
};
var va = (e) => `\\${e}`;
var ss = (e) => {
  const t = Gt(e), { length: a } = t, l = t.charCodeAt(0);
  return t.split("").reduce((o, n, r) => {
    const s = t.charCodeAt(r);
    return s === 0 ? `${o}ï¿½` : (
      // ... is U+007F OR
      s === 127 || // ... is in the range [\1-\1F] (U+0001 to U+001F) OR ...
      s >= 1 && s <= 31 || // ... is the first character and is in the range [0-9] (U+0030 to U+0039) OR ...
      r === 0 && s >= 48 && s <= 57 || // ... is the second character and is in the range [0-9] (U+0030 to U+0039)
      // and the first character is a `-` (U+002D) ...
      r === 1 && s >= 48 && s <= 57 && l === 45 ? o + va(`${s.toString(16)} `) : (
        // ... is the first character AND ...
        r === 0 && // ... is a `-` (U+002D) AND ...
        s === 45 && // ... there is no second character ...
        a === 1 ? o + va(n) : (
          // ... is greater than or equal to U+0080 OR ...
          s >= 128 || // ... is `-` (U+002D) OR ...
          s === 45 || // ... is `_` (U+005F) OR ...
          s === 95 || // ... is in the range [0-9] (U+0030 to U+0039) OR ...
          s >= 48 && s <= 57 || // ... is in the range [A-Z] (U+0041 to U+005A) OR ...
          s >= 65 && s <= 90 || // ... is in the range [a-z] (U+0061 to U+007A) ...
          s >= 97 && s <= 122 ? o + n : o + va(n)
        )
      )
    );
  }, "");
};
var fo = typeof window < "u";
var vo = typeof document < "u";
var is = typeof Element < "u";
var mo = typeof navigator < "u";
var sa = fo && vo && mo;
var dt = fo ? window : {};
var ia = vo ? document : {};
var po = mo ? navigator : {};
var rs = (po.userAgent || "").toLowerCase();
rs.indexOf("jsdom") > 0;
(() => {
  let e = false;
  if (sa)
    try {
      const t = {
        // This function will be called when the browser
        // attempts to access the passive property
        get passive() {
          return e = true, e;
        }
      };
      dt.addEventListener("test", t, t), dt.removeEventListener("test", t, t);
    } catch {
      e = false;
    }
  return e;
})();
sa && ("ontouchstart" in ia.documentElement || po.maxTouchPoints > 0);
sa && (dt.PointerEvent || dt.MSPointerEvent);
sa && "IntersectionObserver" in dt && "IntersectionObserverEntry" in dt && // Edge 15 and UC Browser lack support for `isIntersecting`
// but we an use `intersectionRatio > 0` instead
// 'isIntersecting' in window.IntersectionObserverEntry.prototype &&
"intersectionRatio" in dt.IntersectionObserverEntry.prototype;
var Na = typeof window < "u";
var us = typeof document < "u";
var ds = typeof navigator < "u";
var za = Na && us && ds;
var tl = Na ? window : {};
var cs = (() => {
  let e = false;
  if (za)
    try {
      const t = {
        // This function will be called when the browser
        // attempts to access the passive property
        get passive() {
          e = true;
        }
      };
      tl.addEventListener("test", t, t), tl.removeEventListener("test", t, t);
    } catch {
      e = false;
    }
  return e;
})();
var He = is ? Element.prototype : void 0;
var fs = (He == null ? void 0 : He.matches) || (He == null ? void 0 : He.msMatchesSelector) || (He == null ? void 0 : He.webkitMatchesSelector);
var Qe = (e) => !!(e && e.nodeType === Node.ELEMENT_NODE);
var vs = (e) => Qe(e) ? e.getBoundingClientRect() : null;
var ms = (e = []) => {
  const { activeElement: t } = document;
  return t && !e.some((a) => a === t) ? t : null;
};
var ps = (e) => Qe(e) && e === ms();
var gs = (e, t = {}) => {
  try {
    e.focus(t);
  } catch (a) {
    console.error(a);
  }
  return ps(e);
};
var bs = (e, t) => t && Qe(e) && e.getAttribute(t) || null;
var hs = (e) => {
  if (bs(e, "display") === "none")
    return false;
  const t = vs(e);
  return !!(t && t.height > 0 && t.width > 0);
};
var Ve = (e) => ((e == null ? void 0 : e()) ?? []).length === 0;
var go = (e, t) => (Qe(t) ? t : ia).querySelector(e) || null;
var ys = (e, t) => Array.from([(Qe(t) ? t : ia).querySelectorAll(e)]);
var Ra = (e, t) => t && Qe(e) ? e.getAttribute(t) : null;
var Bs = (e) => ia.getElementById(/^#/.test(e) ? e.slice(1) : e) || null;
var $s = (e, t, a) => {
  t && Qe(e) && e.setAttribute(t, a);
};
var ws = (e, t) => {
  t && Qe(e) && e.removeAttribute(t);
};
var ks = (e, t) => Gt(e).toLowerCase() === Gt(t).toLowerCase();
var Rt = Na ? window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || // Fallback, but not a true polyfill
// Only needed for Opera Mini
((e) => setTimeout(e, 16)) : (e) => setTimeout(e, 0);
var bo = (e, t) => Qe(e) ? fs.call(e, t) : false;
var Cs = (He == null ? void 0 : He.closest) || function(e) {
  let t = this;
  if (!t)
    return null;
  do {
    if (bo(t, e))
      return t;
    t = t.parentElement || t.parentNode;
  } while (t !== null && t.nodeType === Node.ELEMENT_NODE);
  return null;
};
var al = (e, t, a = false) => {
  if (!Qe(t))
    return null;
  const l = Cs.call(t, e);
  return a ? l : l === t ? null : l;
};
var ra = (e, t, a) => t.concat(["sm", "md", "lg", "xl", "xxl"]).reduce((l, o) => (l[e ? `${e}${o.charAt(0).toUpperCase() + o.slice(1)}` : o] = a, l), /* @__PURE__ */ Object.create(null));
var ho = (e, t, a, l = a) => Object.keys(t).reduce((o, n) => (e[n] && o.push(
  [l, n.replace(a, ""), e[n]].filter((r) => r && typeof r != "boolean").join("-").toLowerCase()
), o), []);
var at = (e = "") => `__BVID__${Math.random().toString().slice(2, 8)}___BV_${e}__`;
var Et = (e) => !!(e.href || e.to);
var De = (e, t = {}, a = {}) => {
  const l = [e];
  let o;
  for (let n = 0; n < l.length && !o; n++) {
    const r = l[n];
    o = a[r];
  }
  return o && typeof o == "function" ? o(t) : o;
};
var lt = (e, t = NaN) => Number.isInteger(e) ? e : t;
var Ss = (e, t = NaN) => {
  const a = Number.parseInt(e, 10);
  return Number.isNaN(a) ? t : a;
};
var At = (e, t = NaN) => {
  const a = Number.parseFloat(e.toString());
  return Number.isNaN(a) ? t : a;
};
var Lt = (e, t) => Object.keys(e).filter((a) => !t.includes(a)).reduce((a, l) => ({ ...a, [l]: e[l] }), {});
var Wt = (e) => Array.isArray(e) ? e.map((t) => Wt(t)) : e instanceof Date ? new Date(e.getTime()) : e && typeof e == "object" ? Object.getOwnPropertyNames(e).reduce((t, a) => (Object.defineProperty(t, a, Object.getOwnPropertyDescriptor(e, a) ?? {}), t[a] = Wt(e[a]), t), Object.create(Object.getPrototypeOf(e))) : e;
var ba = (e) => new Promise((t) => t(Wt(e)));
var ll = (e, t) => t + (e ? ns(e) : "");
var Ha = (e, t) => (Array.isArray(t) ? t.slice() : Object.keys(t)).reduce(
  (a, l) => (a[l] = e[l], a),
  {}
);
var ua = (e, t) => e === true || e === "true" || e === "" ? "true" : e === "grammar" || e === "spelling" ? e : t === false ? "true" : e === false || e === "false" ? "false" : void 0;
var yo = Symbol("carousel");
var Bo = Symbol("tabs");
var $o = Symbol("breadcrumb");
var wo = Symbol("progress");
var ko = Symbol("listGroup");
var Co = Symbol("avatarGroup");
var So = Symbol("accordion");
var _o = Symbol("checkboxGroup");
var To = Symbol("radioGroup");
var Ma = Symbol("collapse");
var xo = Symbol("collapse");
var ha = (e, t) => ((e == null ? void 0 : e()) ?? []).reduce((a, l) => (typeof l.type == "symbol" ? a = a.concat(l.children) : a.push(l), a), []).filter((a) => {
  var l;
  return ((l = a.type) == null ? void 0 : l.__name) === t;
});
function Nt(e) {
  return e.split("-")[1];
}
function Da(e) {
  return e === "y" ? "height" : "width";
}
function tt(e) {
  return e.split("-")[0];
}
function St(e) {
  return ["top", "bottom"].includes(tt(e)) ? "x" : "y";
}
function ol(e, t, a) {
  let { reference: l, floating: o } = e;
  const n = l.x + l.width / 2 - o.width / 2, r = l.y + l.height / 2 - o.height / 2, s = St(t), f = Da(s), m = l[f] / 2 - o[f] / 2, B = s === "x";
  let h2;
  switch (tt(t)) {
    case "top":
      h2 = { x: n, y: l.y - o.height };
      break;
    case "bottom":
      h2 = { x: n, y: l.y + l.height };
      break;
    case "right":
      h2 = { x: l.x + l.width, y: r };
      break;
    case "left":
      h2 = { x: l.x - o.width, y: r };
      break;
    default:
      h2 = { x: l.x, y: l.y };
  }
  switch (Nt(t)) {
    case "start":
      h2[s] -= m * (a && B ? -1 : 1);
      break;
    case "end":
      h2[s] += m * (a && B ? -1 : 1);
  }
  return h2;
}
var _s = async (e, t, a) => {
  const { placement: l = "bottom", strategy: o = "absolute", middleware: n = [], platform: r } = a, s = n.filter(Boolean), f = await (r.isRTL == null ? void 0 : r.isRTL(t));
  let m = await r.getElementRects({ reference: e, floating: t, strategy: o }), { x: B, y: h2 } = ol(m, l, f), v = l, w = {}, g = 0;
  for (let k = 0; k < s.length; k++) {
    const { name: y, fn: $ } = s[k], { x: b, y: _, data: V, reset: T } = await $({ x: B, y: h2, initialPlacement: l, placement: v, strategy: o, middlewareData: w, rects: m, platform: r, elements: { reference: e, floating: t } });
    B = b ?? B, h2 = _ ?? h2, w = { ...w, [y]: { ...w[y], ...V } }, T && g <= 50 && (g++, typeof T == "object" && (T.placement && (v = T.placement), T.rects && (m = T.rects === true ? await r.getElementRects({ reference: e, floating: t, strategy: o }) : T.rects), { x: B, y: h2 } = ol(m, v, f)), k = -1);
  }
  return { x: B, y: h2, placement: v, strategy: o, middlewareData: w };
};
function ja(e) {
  return typeof e != "number" ? function(t) {
    return { top: 0, right: 0, bottom: 0, left: 0, ...t };
  }(e) : { top: e, right: e, bottom: e, left: e };
}
function wt(e) {
  return { ...e, top: e.y, left: e.x, right: e.x + e.width, bottom: e.y + e.height };
}
async function Ut(e, t) {
  var a;
  t === void 0 && (t = {});
  const { x: l, y: o, platform: n, rects: r, elements: s, strategy: f } = e, { boundary: m = "clippingAncestors", rootBoundary: B = "viewport", elementContext: h2 = "floating", altBoundary: v = false, padding: w = 0 } = t, g = ja(w), k = s[v ? h2 === "floating" ? "reference" : "floating" : h2], y = wt(await n.getClippingRect({ element: (a = await (n.isElement == null ? void 0 : n.isElement(k))) == null || a ? k : k.contextElement || await (n.getDocumentElement == null ? void 0 : n.getDocumentElement(s.floating)), boundary: m, rootBoundary: B, strategy: f })), $ = h2 === "floating" ? { ...r.floating, x: l, y: o } : r.reference, b = await (n.getOffsetParent == null ? void 0 : n.getOffsetParent(s.floating)), _ = await (n.isElement == null ? void 0 : n.isElement(b)) && await (n.getScale == null ? void 0 : n.getScale(b)) || { x: 1, y: 1 }, V = wt(n.convertOffsetParentRelativeRectToViewportRelativeRect ? await n.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: $, offsetParent: b, strategy: f }) : $);
  return { top: (y.top - V.top + g.top) / _.y, bottom: (V.bottom - y.bottom + g.bottom) / _.y, left: (y.left - V.left + g.left) / _.x, right: (V.right - y.right + g.right) / _.x };
}
var Kt = Math.min;
var Xt = Math.max;
function ya(e, t, a) {
  return Xt(e, Kt(t, a));
}
var Ts = (e) => ({ name: "arrow", options: e, async fn(t) {
  const { element: a, padding: l = 0 } = e || {}, { x: o, y: n, placement: r, rects: s, platform: f, elements: m } = t;
  if (a == null)
    return {};
  const B = ja(l), h2 = { x: o, y: n }, v = St(r), w = Da(v), g = await f.getDimensions(a), k = v === "y", y = k ? "top" : "left", $ = k ? "bottom" : "right", b = k ? "clientHeight" : "clientWidth", _ = s.reference[w] + s.reference[v] - h2[v] - s.floating[w], V = h2[v] - s.reference[v], T = await (f.getOffsetParent == null ? void 0 : f.getOffsetParent(a));
  let S = T ? T[b] : 0;
  S && await (f.isElement == null ? void 0 : f.isElement(T)) || (S = m.floating[b] || s.floating[w]);
  const O = _ / 2 - V / 2, I = B[y], C = S - g[w] - B[$], F = S / 2 - g[w] / 2 + O, P = ya(I, F, C), W = Nt(r) != null && F != P && s.reference[w] / 2 - (F < I ? B[y] : B[$]) - g[w] / 2 < 0;
  return { [v]: h2[v] - (W ? F < I ? I - F : C - F : 0), data: { [v]: P, centerOffset: F - P } };
} });
var Ao = ["top", "right", "bottom", "left"];
Ao.reduce((e, t) => e.concat(t, t + "-start", t + "-end"), []);
var xs = { left: "right", right: "left", bottom: "top", top: "bottom" };
function Jt(e) {
  return e.replace(/left|right|bottom|top/g, (t) => xs[t]);
}
function As(e, t, a) {
  a === void 0 && (a = false);
  const l = Nt(e), o = St(e), n = Da(o);
  let r = o === "x" ? l === (a ? "end" : "start") ? "right" : "left" : l === "start" ? "bottom" : "top";
  return t.reference[n] > t.floating[n] && (r = Jt(r)), { main: r, cross: Jt(r) };
}
var Vs = { start: "end", end: "start" };
function ma(e) {
  return e.replace(/start|end/g, (t) => Vs[t]);
}
var Vo = function(e) {
  return e === void 0 && (e = {}), { name: "flip", options: e, async fn(t) {
    var a;
    const { placement: l, middlewareData: o, rects: n, initialPlacement: r, platform: s, elements: f } = t, { mainAxis: m = true, crossAxis: B = true, fallbackPlacements: h2, fallbackStrategy: v = "bestFit", fallbackAxisSideDirection: w = "none", flipAlignment: g = true, ...k } = e, y = tt(l), $ = tt(r) === r, b = await (s.isRTL == null ? void 0 : s.isRTL(f.floating)), _ = h2 || ($ || !g ? [Jt(r)] : function(P) {
      const W = Jt(P);
      return [ma(P), W, ma(W)];
    }(r));
    h2 || w === "none" || _.push(...function(P, W, j, te) {
      const X = Nt(P);
      let q = function(ae, me, pe) {
        const be = ["left", "right"], ne = ["right", "left"], ve = ["top", "bottom"], L = ["bottom", "top"];
        switch (ae) {
          case "top":
          case "bottom":
            return pe ? me ? ne : be : me ? be : ne;
          case "left":
          case "right":
            return me ? ve : L;
          default:
            return [];
        }
      }(tt(P), j === "start", te);
      return X && (q = q.map((ae) => ae + "-" + X), W && (q = q.concat(q.map(ma)))), q;
    }(r, g, w, b));
    const V = [r, ..._], T = await Ut(t, k), S = [];
    let O = ((a = o.flip) == null ? void 0 : a.overflows) || [];
    if (m && S.push(T[y]), B) {
      const { main: P, cross: W } = As(l, n, b);
      S.push(T[P], T[W]);
    }
    if (O = [...O, { placement: l, overflows: S }], !S.every((P) => P <= 0)) {
      var I, C;
      const P = (((I = o.flip) == null ? void 0 : I.index) || 0) + 1, W = V[P];
      if (W)
        return { data: { index: P, overflows: O }, reset: { placement: W } };
      let j = (C = O.filter((te) => te.overflows[0] <= 0).sort((te, X) => te.overflows[1] - X.overflows[1])[0]) == null ? void 0 : C.placement;
      if (!j)
        switch (v) {
          case "bestFit": {
            var F;
            const te = (F = O.map((X) => [X.placement, X.overflows.filter((q) => q > 0).reduce((q, ae) => q + ae, 0)]).sort((X, q) => X[1] - q[1])[0]) == null ? void 0 : F[0];
            te && (j = te);
            break;
          }
          case "initialPlacement":
            j = r;
        }
      if (l !== j)
        return { reset: { placement: j } };
    }
    return {};
  } };
};
function nl(e, t) {
  return { top: e.top - t.height, right: e.right - t.width, bottom: e.bottom - t.height, left: e.left - t.width };
}
function sl(e) {
  return Ao.some((t) => e[t] >= 0);
}
var Os = function(e) {
  return e === void 0 && (e = {}), { name: "hide", options: e, async fn(t) {
    const { strategy: a = "referenceHidden", ...l } = e, { rects: o } = t;
    switch (a) {
      case "referenceHidden": {
        const n = nl(await Ut(t, { ...l, elementContext: "reference" }), o.reference);
        return { data: { referenceHiddenOffsets: n, referenceHidden: sl(n) } };
      }
      case "escaped": {
        const n = nl(await Ut(t, { ...l, altBoundary: true }), o.floating);
        return { data: { escapedOffsets: n, escaped: sl(n) } };
      }
      default:
        return {};
    }
  } };
};
function il(e) {
  const t = Kt(...e.map((l) => l.left)), a = Kt(...e.map((l) => l.top));
  return { x: t, y: a, width: Xt(...e.map((l) => l.right)) - t, height: Xt(...e.map((l) => l.bottom)) - a };
}
var Ps = function(e) {
  return e === void 0 && (e = {}), { name: "inline", options: e, async fn(t) {
    const { placement: a, elements: l, rects: o, platform: n, strategy: r } = t, { padding: s = 2, x: f, y: m } = e, B = Array.from(await (n.getClientRects == null ? void 0 : n.getClientRects(l.reference)) || []), h2 = function(k) {
      const y = k.slice().sort((_, V) => _.y - V.y), $ = [];
      let b = null;
      for (let _ = 0; _ < y.length; _++) {
        const V = y[_];
        !b || V.y - b.y > b.height / 2 ? $.push([V]) : $[$.length - 1].push(V), b = V;
      }
      return $.map((_) => wt(il(_)));
    }(B), v = wt(il(B)), w = ja(s), g = await n.getElementRects({ reference: { getBoundingClientRect: function() {
      if (h2.length === 2 && h2[0].left > h2[1].right && f != null && m != null)
        return h2.find((k) => f > k.left - w.left && f < k.right + w.right && m > k.top - w.top && m < k.bottom + w.bottom) || v;
      if (h2.length >= 2) {
        if (St(a) === "x") {
          const T = h2[0], S = h2[h2.length - 1], O = tt(a) === "top", I = T.top, C = S.bottom, F = O ? T.left : S.left, P = O ? T.right : S.right;
          return { top: I, bottom: C, left: F, right: P, width: P - F, height: C - I, x: F, y: I };
        }
        const k = tt(a) === "left", y = Xt(...h2.map((T) => T.right)), $ = Kt(...h2.map((T) => T.left)), b = h2.filter((T) => k ? T.left === $ : T.right === y), _ = b[0].top, V = b[b.length - 1].bottom;
        return { top: _, bottom: V, left: $, right: y, width: y - $, height: V - _, x: $, y: _ };
      }
      return v;
    } }, floating: l.floating, strategy: r });
    return o.reference.x !== g.reference.x || o.reference.y !== g.reference.y || o.reference.width !== g.reference.width || o.reference.height !== g.reference.height ? { reset: { rects: g } } : {};
  } };
};
var Oo = function(e) {
  return e === void 0 && (e = 0), { name: "offset", options: e, async fn(t) {
    const { x: a, y: l } = t, o = await async function(n, r) {
      const { placement: s, platform: f, elements: m } = n, B = await (f.isRTL == null ? void 0 : f.isRTL(m.floating)), h2 = tt(s), v = Nt(s), w = St(s) === "x", g = ["left", "top"].includes(h2) ? -1 : 1, k = B && w ? -1 : 1, y = typeof r == "function" ? r(n) : r;
      let { mainAxis: $, crossAxis: b, alignmentAxis: _ } = typeof y == "number" ? { mainAxis: y, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...y };
      return v && typeof _ == "number" && (b = v === "end" ? -1 * _ : _), w ? { x: b * k, y: $ * g } : { x: $ * g, y: b * k };
    }(t, e);
    return { x: a + o.x, y: l + o.y, data: o };
  } };
};
function Es(e) {
  return e === "x" ? "y" : "x";
}
var Po = function(e) {
  return e === void 0 && (e = {}), { name: "shift", options: e, async fn(t) {
    const { x: a, y: l, placement: o } = t, { mainAxis: n = true, crossAxis: r = false, limiter: s = { fn: (y) => {
      let { x: $, y: b } = y;
      return { x: $, y: b };
    } }, ...f } = e, m = { x: a, y: l }, B = await Ut(t, f), h2 = St(tt(o)), v = Es(h2);
    let w = m[h2], g = m[v];
    if (n) {
      const y = h2 === "y" ? "bottom" : "right";
      w = ya(w + B[h2 === "y" ? "top" : "left"], w, w - B[y]);
    }
    if (r) {
      const y = v === "y" ? "bottom" : "right";
      g = ya(g + B[v === "y" ? "top" : "left"], g, g - B[y]);
    }
    const k = s.fn({ ...t, [h2]: w, [v]: g });
    return { ...k, data: { x: k.x - a, y: k.y - l } };
  } };
};
function Fe(e) {
  var t;
  return ((t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Ke(e) {
  return Fe(e).getComputedStyle(e);
}
function Eo(e) {
  return e instanceof Fe(e).Node;
}
function nt(e) {
  return Eo(e) ? (e.nodeName || "").toLowerCase() : "";
}
var Ht;
function Io() {
  if (Ht)
    return Ht;
  const e = navigator.userAgentData;
  return e && Array.isArray(e.brands) ? (Ht = e.brands.map((t) => t.brand + "/" + t.version).join(" "), Ht) : navigator.userAgent;
}
function We(e) {
  return e instanceof Fe(e).HTMLElement;
}
function Ge(e) {
  return e instanceof Fe(e).Element;
}
function rl(e) {
  return typeof ShadowRoot > "u" ? false : e instanceof Fe(e).ShadowRoot || e instanceof ShadowRoot;
}
function da(e) {
  const { overflow: t, overflowX: a, overflowY: l, display: o } = Ke(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + l + a) && !["inline", "contents"].includes(o);
}
function Is(e) {
  return ["table", "td", "th"].includes(nt(e));
}
function Ba(e) {
  const t = /firefox/i.test(Io()), a = Ke(e), l = a.backdropFilter || a.WebkitBackdropFilter;
  return a.transform !== "none" || a.perspective !== "none" || !!l && l !== "none" || t && a.willChange === "filter" || t && !!a.filter && a.filter !== "none" || ["transform", "perspective"].some((o) => a.willChange.includes(o)) || ["paint", "layout", "strict", "content"].some((o) => {
    const n = a.contain;
    return n != null && n.includes(o);
  });
}
function $a() {
  return /^((?!chrome|android).)*safari/i.test(Io());
}
function qa(e) {
  return ["html", "body", "#document"].includes(nt(e));
}
var ul = Math.min;
var Vt = Math.max;
var Yt = Math.round;
function Fo(e) {
  const t = Ke(e);
  let a = parseFloat(t.width), l = parseFloat(t.height);
  const o = We(e), n = o ? e.offsetWidth : a, r = o ? e.offsetHeight : l, s = Yt(a) !== n || Yt(l) !== r;
  return s && (a = n, l = r), { width: a, height: l, fallback: s };
}
function Lo(e) {
  return Ge(e) ? e : e.contextElement;
}
var No = { x: 1, y: 1 };
function $t(e) {
  const t = Lo(e);
  if (!We(t))
    return No;
  const a = t.getBoundingClientRect(), { width: l, height: o, fallback: n } = Fo(t);
  let r = (n ? Yt(a.width) : a.width) / l, s = (n ? Yt(a.height) : a.height) / o;
  return r && Number.isFinite(r) || (r = 1), s && Number.isFinite(s) || (s = 1), { x: r, y: s };
}
function vt(e, t, a, l) {
  var o, n;
  t === void 0 && (t = false), a === void 0 && (a = false);
  const r = e.getBoundingClientRect(), s = Lo(e);
  let f = No;
  t && (l ? Ge(l) && (f = $t(l)) : f = $t(e));
  const m = s ? Fe(s) : window, B = $a() && a;
  let h2 = (r.left + (B && ((o = m.visualViewport) == null ? void 0 : o.offsetLeft) || 0)) / f.x, v = (r.top + (B && ((n = m.visualViewport) == null ? void 0 : n.offsetTop) || 0)) / f.y, w = r.width / f.x, g = r.height / f.y;
  if (s) {
    const k = Fe(s), y = l && Ge(l) ? Fe(l) : l;
    let $ = k.frameElement;
    for (; $ && l && y !== k; ) {
      const b = $t($), _ = $.getBoundingClientRect(), V = getComputedStyle($);
      _.x += ($.clientLeft + parseFloat(V.paddingLeft)) * b.x, _.y += ($.clientTop + parseFloat(V.paddingTop)) * b.y, h2 *= b.x, v *= b.y, w *= b.x, g *= b.y, h2 += _.x, v += _.y, $ = Fe($).frameElement;
    }
  }
  return wt({ width: w, height: g, x: h2, y: v });
}
function ot(e) {
  return ((Eo(e) ? e.ownerDocument : e.document) || window.document).documentElement;
}
function ca(e) {
  return Ge(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset };
}
function zo(e) {
  return vt(ot(e)).left + ca(e).scrollLeft;
}
function It(e) {
  if (nt(e) === "html")
    return e;
  const t = e.assignedSlot || e.parentNode || rl(e) && e.host || ot(e);
  return rl(t) ? t.host : t;
}
function Ro(e) {
  const t = It(e);
  return qa(t) ? t.ownerDocument.body : We(t) && da(t) ? t : Ro(t);
}
function Ot(e, t) {
  var a;
  t === void 0 && (t = []);
  const l = Ro(e), o = l === ((a = e.ownerDocument) == null ? void 0 : a.body), n = Fe(l);
  return o ? t.concat(n, n.visualViewport || [], da(l) ? l : []) : t.concat(l, Ot(l));
}
function dl(e, t, a) {
  let l;
  if (t === "viewport")
    l = function(r, s) {
      const f = Fe(r), m = ot(r), B = f.visualViewport;
      let h2 = m.clientWidth, v = m.clientHeight, w = 0, g = 0;
      if (B) {
        h2 = B.width, v = B.height;
        const k = $a();
        (!k || k && s === "fixed") && (w = B.offsetLeft, g = B.offsetTop);
      }
      return { width: h2, height: v, x: w, y: g };
    }(e, a);
  else if (t === "document")
    l = function(r) {
      const s = ot(r), f = ca(r), m = r.ownerDocument.body, B = Vt(s.scrollWidth, s.clientWidth, m.scrollWidth, m.clientWidth), h2 = Vt(s.scrollHeight, s.clientHeight, m.scrollHeight, m.clientHeight);
      let v = -f.scrollLeft + zo(r);
      const w = -f.scrollTop;
      return Ke(m).direction === "rtl" && (v += Vt(s.clientWidth, m.clientWidth) - B), { width: B, height: h2, x: v, y: w };
    }(ot(e));
  else if (Ge(t))
    l = function(r, s) {
      const f = vt(r, true, s === "fixed"), m = f.top + r.clientTop, B = f.left + r.clientLeft, h2 = We(r) ? $t(r) : { x: 1, y: 1 };
      return { width: r.clientWidth * h2.x, height: r.clientHeight * h2.y, x: B * h2.x, y: m * h2.y };
    }(t, a);
  else {
    const r = { ...t };
    if ($a()) {
      var o, n;
      const s = Fe(e);
      r.x -= ((o = s.visualViewport) == null ? void 0 : o.offsetLeft) || 0, r.y -= ((n = s.visualViewport) == null ? void 0 : n.offsetTop) || 0;
    }
    l = r;
  }
  return wt(l);
}
function cl(e, t) {
  return We(e) && Ke(e).position !== "fixed" ? t ? t(e) : e.offsetParent : null;
}
function fl(e, t) {
  const a = Fe(e);
  if (!We(e))
    return a;
  let l = cl(e, t);
  for (; l && Is(l) && Ke(l).position === "static"; )
    l = cl(l, t);
  return l && (nt(l) === "html" || nt(l) === "body" && Ke(l).position === "static" && !Ba(l)) ? a : l || function(o) {
    let n = It(o);
    for (; We(n) && !qa(n); ) {
      if (Ba(n))
        return n;
      n = It(n);
    }
    return null;
  }(e) || a;
}
function Fs(e, t, a) {
  const l = We(t), o = ot(t), n = vt(e, true, a === "fixed", t);
  let r = { scrollLeft: 0, scrollTop: 0 };
  const s = { x: 0, y: 0 };
  if (l || !l && a !== "fixed")
    if ((nt(t) !== "body" || da(o)) && (r = ca(t)), We(t)) {
      const f = vt(t, true);
      s.x = f.x + t.clientLeft, s.y = f.y + t.clientTop;
    } else
      o && (s.x = zo(o));
  return { x: n.left + r.scrollLeft - s.x, y: n.top + r.scrollTop - s.y, width: n.width, height: n.height };
}
var Ls = { getClippingRect: function(e) {
  let { element: t, boundary: a, rootBoundary: l, strategy: o } = e;
  const n = a === "clippingAncestors" ? function(m, B) {
    const h2 = B.get(m);
    if (h2)
      return h2;
    let v = Ot(m).filter((y) => Ge(y) && nt(y) !== "body"), w = null;
    const g = Ke(m).position === "fixed";
    let k = g ? It(m) : m;
    for (; Ge(k) && !qa(k); ) {
      const y = Ke(k), $ = Ba(k);
      y.position === "fixed" && (w = null), (g ? $ || w : $ || y.position !== "static" || !w || !["absolute", "fixed"].includes(w.position)) ? w = y : v = v.filter((b) => b !== k), k = It(k);
    }
    return B.set(m, v), v;
  }(t, this._c) : [].concat(a), r = [...n, l], s = r[0], f = r.reduce((m, B) => {
    const h2 = dl(t, B, o);
    return m.top = Vt(h2.top, m.top), m.right = ul(h2.right, m.right), m.bottom = ul(h2.bottom, m.bottom), m.left = Vt(h2.left, m.left), m;
  }, dl(t, s, o));
  return { width: f.right - f.left, height: f.bottom - f.top, x: f.left, y: f.top };
}, convertOffsetParentRelativeRectToViewportRelativeRect: function(e) {
  let { rect: t, offsetParent: a, strategy: l } = e;
  const o = We(a), n = ot(a);
  if (a === n)
    return t;
  let r = { scrollLeft: 0, scrollTop: 0 }, s = { x: 1, y: 1 };
  const f = { x: 0, y: 0 };
  if ((o || !o && l !== "fixed") && ((nt(a) !== "body" || da(n)) && (r = ca(a)), We(a))) {
    const m = vt(a);
    s = $t(a), f.x = m.x + a.clientLeft, f.y = m.y + a.clientTop;
  }
  return { width: t.width * s.x, height: t.height * s.y, x: t.x * s.x - r.scrollLeft * s.x + f.x, y: t.y * s.y - r.scrollTop * s.y + f.y };
}, isElement: Ge, getDimensions: function(e) {
  return Fo(e);
}, getOffsetParent: fl, getDocumentElement: ot, getScale: $t, async getElementRects(e) {
  let { reference: t, floating: a, strategy: l } = e;
  const o = this.getOffsetParent || fl, n = this.getDimensions;
  return { reference: Fs(t, await o(a), l), floating: { x: 0, y: 0, ...await n(a) } };
}, getClientRects: (e) => Array.from(e.getClientRects()), isRTL: (e) => Ke(e).direction === "rtl" };
function Ns(e, t, a, l) {
  l === void 0 && (l = {});
  const { ancestorScroll: o = true, ancestorResize: n = true, elementResize: r = true, animationFrame: s = false } = l, f = o && !s, m = f || n ? [...Ge(e) ? Ot(e) : e.contextElement ? Ot(e.contextElement) : [], ...Ot(t)] : [];
  m.forEach((w) => {
    f && w.addEventListener("scroll", a, { passive: true }), n && w.addEventListener("resize", a);
  });
  let B, h2 = null;
  r && (h2 = new ResizeObserver(() => {
    a();
  }), Ge(e) && !s && h2.observe(e), Ge(e) || !e.contextElement || s || h2.observe(e.contextElement), h2.observe(t));
  let v = s ? vt(e) : null;
  return s && function w() {
    const g = vt(e);
    !v || g.x === v.x && g.y === v.y && g.width === v.width && g.height === v.height || a(), v = g, B = requestAnimationFrame(w);
  }(), a(), () => {
    var w;
    m.forEach((g) => {
      f && g.removeEventListener("scroll", a), n && g.removeEventListener("resize", a);
    }), (w = h2) == null || w.disconnect(), h2 = null, s && cancelAnimationFrame(B);
  };
}
var zs = (e, t, a) => {
  const l = /* @__PURE__ */ new Map(), o = { platform: Ls, ...a }, n = { ...o.platform, _c: l };
  return _s(e, t, { ...o, platform: n });
};
function wa(e) {
  var t;
  return (t = e == null ? void 0 : e.$el) != null ? t : e;
}
function Rs(e) {
  return {
    name: "arrow",
    options: e,
    fn(t) {
      const a = wa(unref(e.element));
      return a == null ? {} : Ts({
        element: a,
        padding: e.padding
      }).fn(t);
    }
  };
}
function Ho(e, t, a) {
  a === void 0 && (a = {});
  const l = a.whileElementsMounted, o = computed(() => {
    var T;
    return (T = unref(a.open)) != null ? T : true;
  }), n = computed(() => unref(a.middleware)), r = computed(() => {
    var T;
    return (T = unref(a.placement)) != null ? T : "bottom";
  }), s = computed(() => {
    var T;
    return (T = unref(a.strategy)) != null ? T : "absolute";
  }), f = computed(() => wa(e.value)), m = computed(() => wa(t.value)), B = ref(null), h2 = ref(null), v = ref(s.value), w = ref(r.value), g = shallowRef({}), k = ref(false);
  let y;
  function $() {
    f.value == null || m.value == null || zs(f.value, m.value, {
      middleware: n.value,
      placement: r.value,
      strategy: s.value
    }).then((T) => {
      B.value = T.x, h2.value = T.y, v.value = T.strategy, w.value = T.placement, g.value = T.middlewareData, k.value = true;
    });
  }
  function b() {
    typeof y == "function" && (y(), y = void 0);
  }
  function _() {
    if (b(), l === void 0) {
      $();
      return;
    }
    if (f.value != null && m.value != null) {
      y = l(f.value, m.value, $);
      return;
    }
  }
  function V() {
    o.value || (k.value = false);
  }
  return watch([n, r, s], $, {
    flush: "sync"
  }), watch([f, m], _, {
    flush: "sync"
  }), watch(o, V, {
    flush: "sync"
  }), getCurrentScope() && onScopeDispose(b), {
    x: shallowReadonly(B),
    y: shallowReadonly(h2),
    strategy: shallowReadonly(v),
    placement: shallowReadonly(w),
    middlewareData: shallowReadonly(g),
    isPositioned: shallowReadonly(k),
    update: $
  };
}
var Hs = /* @__PURE__ */ new Set([
  "background",
  "cite",
  "href",
  "itemtype",
  "longdesc",
  "poster",
  "src",
  "xlink:href"
]);
var Ms = /^aria-[\w-]*$/i;
var Ds = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;
var js = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;
var qs = (e, t) => {
  const a = e.nodeName.toLowerCase();
  return t.includes(a) ? Hs.has(a) ? !!(Ds.test(e.nodeValue || "") || js.test(e.nodeValue || "")) : true : t.filter((l) => l instanceof RegExp).some((l) => l.test(a));
};
var ht = {
  // Global attributes allowed on any supplied element below.
  "*": ["class", "dir", "id", "lang", "role", Ms],
  a: ["target", "href", "title", "rel"],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  div: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ["src", "srcset", "alt", "title", "width", "height"],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
};
var yt = (e, t, a) => {
  if (!e.length)
    return e;
  if (a && typeof a == "function")
    return a(e);
  const o = new window.DOMParser().parseFromString(e, "text/html"), n = o.body.querySelectorAll("*");
  for (const r of n) {
    const s = r.nodeName.toLowerCase();
    if (!Object.keys(t).includes(s)) {
      r.remove();
      continue;
    }
    const f = r.attributes, m = [...t["*"] || [], ...t[s] || []];
    for (const B of f)
      qs(B, m) || r.removeAttribute(B.nodeName);
  }
  return o.body.innerHTML;
};
var Gs = Object.defineProperty;
var Ws = Object.defineProperties;
var Us = Object.getOwnPropertyDescriptors;
var vl = Object.getOwnPropertySymbols;
var Ks = Object.prototype.hasOwnProperty;
var Xs = Object.prototype.propertyIsEnumerable;
var ml = (e, t, a) => t in e ? Gs(e, t, { enumerable: true, configurable: true, writable: true, value: a }) : e[t] = a;
var Js = (e, t) => {
  for (var a in t || (t = {}))
    Ks.call(t, a) && ml(e, a, t[a]);
  if (vl)
    for (var a of vl(t))
      Xs.call(t, a) && ml(e, a, t[a]);
  return e;
};
var Ys = (e, t) => Ws(e, Us(t));
function Mo(e, t) {
  var a;
  const l = shallowRef();
  return watchEffect(() => {
    l.value = e();
  }, Ys(Js({}, t), {
    flush: (a = t == null ? void 0 : t.flush) != null ? a : "sync"
  })), readonly(l);
}
var pl;
var Zt = typeof window < "u";
var Zs = (e) => typeof e < "u";
var Ga = (e) => typeof e == "function";
var Qs = (e) => typeof e == "string";
var Qt = () => {
};
var ei = Zt && ((pl = window == null ? void 0 : window.navigator) == null ? void 0 : pl.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function Se(e) {
  return typeof e == "function" ? e() : unref(e);
}
function ti(e, t) {
  function a(...l) {
    return new Promise((o, n) => {
      Promise.resolve(e(() => t.apply(this, l), { fn: t, thisArg: this, args: l })).then(o).catch(n);
    });
  }
  return a;
}
var Do = (e) => e();
function ai(e = Do) {
  const t = ref(true);
  function a() {
    t.value = false;
  }
  function l() {
    t.value = true;
  }
  const o = (...n) => {
    t.value && e(...n);
  };
  return { isActive: readonly(t), pause: a, resume: l, eventFilter: o };
}
function li(e) {
  return e;
}
function ea(e) {
  return getCurrentScope() ? (onScopeDispose(e), true) : false;
}
function oi(e) {
  return typeof e == "function" ? computed(e) : ref(e);
}
function jo(e, t = true) {
  getCurrentInstance() ? onMounted(e) : t ? e() : nextTick(e);
}
function qo(e, t = 1e3, a = {}) {
  const {
    immediate: l = true,
    immediateCallback: o = false
  } = a;
  let n = null;
  const r = ref(false);
  function s() {
    n && (clearInterval(n), n = null);
  }
  function f() {
    r.value = false, s();
  }
  function m() {
    const B = Se(t);
    B <= 0 || (r.value = true, o && e(), s(), n = setInterval(e, B));
  }
  if (l && Zt && m(), isRef(t) || Ga(t)) {
    const B = watch(t, () => {
      r.value && Zt && m();
    });
    ea(B);
  }
  return ea(f), {
    isActive: r,
    pause: f,
    resume: m
  };
}
function Bt(e, t = {}) {
  const {
    method: a = "parseFloat",
    radix: l,
    nanToZero: o
  } = t;
  return computed(() => {
    let n = Se(e);
    return typeof n == "string" && (n = Number[a](n, l)), o && isNaN(n) && (n = 0), n;
  });
}
var gl = Object.getOwnPropertySymbols;
var ni = Object.prototype.hasOwnProperty;
var si = Object.prototype.propertyIsEnumerable;
var ii = (e, t) => {
  var a = {};
  for (var l in e)
    ni.call(e, l) && t.indexOf(l) < 0 && (a[l] = e[l]);
  if (e != null && gl)
    for (var l of gl(e))
      t.indexOf(l) < 0 && si.call(e, l) && (a[l] = e[l]);
  return a;
};
function ri(e, t, a = {}) {
  const l = a, {
    eventFilter: o = Do
  } = l, n = ii(l, [
    "eventFilter"
  ]);
  return watch(e, ti(o, t), n);
}
var ui = Object.defineProperty;
var di = Object.defineProperties;
var ci = Object.getOwnPropertyDescriptors;
var ta = Object.getOwnPropertySymbols;
var Go = Object.prototype.hasOwnProperty;
var Wo = Object.prototype.propertyIsEnumerable;
var bl = (e, t, a) => t in e ? ui(e, t, { enumerable: true, configurable: true, writable: true, value: a }) : e[t] = a;
var fi = (e, t) => {
  for (var a in t || (t = {}))
    Go.call(t, a) && bl(e, a, t[a]);
  if (ta)
    for (var a of ta(t))
      Wo.call(t, a) && bl(e, a, t[a]);
  return e;
};
var vi = (e, t) => di(e, ci(t));
var mi = (e, t) => {
  var a = {};
  for (var l in e)
    Go.call(e, l) && t.indexOf(l) < 0 && (a[l] = e[l]);
  if (e != null && ta)
    for (var l of ta(e))
      t.indexOf(l) < 0 && Wo.call(e, l) && (a[l] = e[l]);
  return a;
};
function pi(e, t, a = {}) {
  const l = a, {
    eventFilter: o
  } = l, n = mi(l, [
    "eventFilter"
  ]), { eventFilter: r, pause: s, resume: f, isActive: m } = ai(o);
  return { stop: ri(e, t, vi(fi({}, n), {
    eventFilter: r
  })), pause: s, resume: f, isActive: m };
}
function ut(e) {
  var t;
  const a = Se(e);
  return (t = a == null ? void 0 : a.$el) != null ? t : a;
}
var Je = Zt ? window : void 0;
function we(...e) {
  let t, a, l, o;
  if (Qs(e[0]) || Array.isArray(e[0]) ? ([a, l, o] = e, t = Je) : [t, a, l, o] = e, !t)
    return Qt;
  Array.isArray(a) || (a = [a]), Array.isArray(l) || (l = [l]);
  const n = [], r = () => {
    n.forEach((B) => B()), n.length = 0;
  }, s = (B, h2, v, w) => (B.addEventListener(h2, v, w), () => B.removeEventListener(h2, v, w)), f = watch(() => [ut(t), Se(o)], ([B, h2]) => {
    r(), B && n.push(...a.flatMap((v) => l.map((w) => s(B, v, w, h2))));
  }, { immediate: true, flush: "post" }), m = () => {
    f(), r();
  };
  return ea(m), m;
}
var hl = false;
function Uo(e, t, a = {}) {
  const { window: l = Je, ignore: o = [], capture: n = true, detectIframe: r = false } = a;
  if (!l)
    return;
  ei && !hl && (hl = true, Array.from(l.document.body.children).forEach((v) => v.addEventListener("click", Qt)));
  let s = true;
  const f = (v) => o.some((w) => {
    if (typeof w == "string")
      return Array.from(l.document.querySelectorAll(w)).some((g) => g === v.target || v.composedPath().includes(g));
    {
      const g = ut(w);
      return g && (v.target === g || v.composedPath().includes(g));
    }
  }), B = [
    we(l, "click", (v) => {
      const w = ut(e);
      if (!(!w || w === v.target || v.composedPath().includes(w))) {
        if (v.detail === 0 && (s = !f(v)), !s) {
          s = true;
          return;
        }
        t(v);
      }
    }, { passive: true, capture: n }),
    we(l, "pointerdown", (v) => {
      const w = ut(e);
      w && (s = !v.composedPath().includes(w) && !f(v));
    }, { passive: true }),
    r && we(l, "blur", (v) => {
      var w;
      const g = ut(e);
      ((w = l.document.activeElement) == null ? void 0 : w.tagName) === "IFRAME" && !(g != null && g.contains(l.document.activeElement)) && t(v);
    })
  ].filter(Boolean);
  return () => B.forEach((v) => v());
}
function gi(e, t = false) {
  const a = ref(), l = () => a.value = !!e();
  return l(), jo(l, t), a;
}
function bi(e, t = {}) {
  const { window: a = Je } = t, l = gi(() => a && "matchMedia" in a && typeof a.matchMedia == "function");
  let o;
  const n = ref(false), r = () => {
    o && ("removeEventListener" in o ? o.removeEventListener("change", s) : o.removeListener(s));
  }, s = () => {
    l.value && (r(), o = a.matchMedia(oi(e).value), n.value = o.matches, "addEventListener" in o ? o.addEventListener("change", s) : o.addListener(s));
  };
  return watchEffect(s), ea(() => r()), n;
}
function hi(e) {
  return JSON.parse(JSON.stringify(e));
}
var ka = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var Ca = "__vueuse_ssr_handlers__";
ka[Ca] = ka[Ca] || {};
var yi = ka[Ca];
function Ko(e, t) {
  return yi[e] || t;
}
function Bi(e) {
  return e == null ? "any" : e instanceof Set ? "set" : e instanceof Map ? "map" : e instanceof Date ? "date" : typeof e == "boolean" ? "boolean" : typeof e == "string" ? "string" : typeof e == "object" ? "object" : Number.isNaN(e) ? "any" : "number";
}
var $i = Object.defineProperty;
var yl = Object.getOwnPropertySymbols;
var wi = Object.prototype.hasOwnProperty;
var ki = Object.prototype.propertyIsEnumerable;
var Bl = (e, t, a) => t in e ? $i(e, t, { enumerable: true, configurable: true, writable: true, value: a }) : e[t] = a;
var $l = (e, t) => {
  for (var a in t || (t = {}))
    wi.call(t, a) && Bl(e, a, t[a]);
  if (yl)
    for (var a of yl(t))
      ki.call(t, a) && Bl(e, a, t[a]);
  return e;
};
var Ci = {
  boolean: {
    read: (e) => e === "true",
    write: (e) => String(e)
  },
  object: {
    read: (e) => JSON.parse(e),
    write: (e) => JSON.stringify(e)
  },
  number: {
    read: (e) => Number.parseFloat(e),
    write: (e) => String(e)
  },
  any: {
    read: (e) => e,
    write: (e) => String(e)
  },
  string: {
    read: (e) => e,
    write: (e) => String(e)
  },
  map: {
    read: (e) => new Map(JSON.parse(e)),
    write: (e) => JSON.stringify(Array.from(e.entries()))
  },
  set: {
    read: (e) => new Set(JSON.parse(e)),
    write: (e) => JSON.stringify(Array.from(e))
  },
  date: {
    read: (e) => new Date(e),
    write: (e) => e.toISOString()
  }
};
var wl = "vueuse-storage";
function Si(e, t, a, l = {}) {
  var o;
  const {
    flush: n = "pre",
    deep: r = true,
    listenToStorageChanges: s = true,
    writeDefaults: f = true,
    mergeDefaults: m = false,
    shallow: B,
    window: h2 = Je,
    eventFilter: v,
    onError: w = (I) => {
      console.error(I);
    }
  } = l, g = (B ? shallowRef : ref)(t);
  if (!a)
    try {
      a = Ko("getDefaultStorage", () => {
        var I;
        return (I = Je) == null ? void 0 : I.localStorage;
      })();
    } catch (I) {
      w(I);
    }
  if (!a)
    return g;
  const k = Se(t), y = Bi(k), $ = (o = l.serializer) != null ? o : Ci[y], { pause: b, resume: _ } = pi(g, () => V(g.value), { flush: n, deep: r, eventFilter: v });
  return h2 && s && (we(h2, "storage", O), we(h2, wl, S)), O(), g;
  function V(I) {
    try {
      if (I == null)
        a.removeItem(e);
      else {
        const C = $.write(I), F = a.getItem(e);
        F !== C && (a.setItem(e, C), h2 && h2.dispatchEvent(new CustomEvent(wl, {
          detail: {
            key: e,
            oldValue: F,
            newValue: C,
            storageArea: a
          }
        })));
      }
    } catch (C) {
      w(C);
    }
  }
  function T(I) {
    const C = I ? I.newValue : a.getItem(e);
    if (C == null)
      return f && k !== null && a.setItem(e, $.write(k)), k;
    if (!I && m) {
      const F = $.read(C);
      return Ga(m) ? m(F, k) : y === "object" && !Array.isArray(F) ? $l($l({}, k), F) : F;
    } else
      return typeof C != "string" ? C : $.read(C);
  }
  function S(I) {
    O(I.detail);
  }
  function O(I) {
    if (!(I && I.storageArea !== a)) {
      if (I && I.key == null) {
        g.value = k;
        return;
      }
      if (!(I && I.key !== e)) {
        b();
        try {
          g.value = T(I);
        } catch (C) {
          w(C);
        } finally {
          I ? nextTick(_) : _();
        }
      }
    }
  }
}
function Xo(e) {
  return bi("(prefers-color-scheme: dark)", e);
}
var _i = Object.defineProperty;
var kl = Object.getOwnPropertySymbols;
var Ti = Object.prototype.hasOwnProperty;
var xi = Object.prototype.propertyIsEnumerable;
var Cl = (e, t, a) => t in e ? _i(e, t, { enumerable: true, configurable: true, writable: true, value: a }) : e[t] = a;
var Ai = (e, t) => {
  for (var a in t || (t = {}))
    Ti.call(t, a) && Cl(e, a, t[a]);
  if (kl)
    for (var a of kl(t))
      xi.call(t, a) && Cl(e, a, t[a]);
  return e;
};
function Jo(e = {}) {
  const {
    selector: t = "html",
    attribute: a = "class",
    initialValue: l = "auto",
    window: o = Je,
    storage: n,
    storageKey: r = "vueuse-color-scheme",
    listenToStorageChanges: s = true,
    storageRef: f,
    emitAuto: m
  } = e, B = Ai({
    auto: "",
    light: "light",
    dark: "dark"
  }, e.modes || {}), h2 = Xo({ window: o }), v = computed(() => h2.value ? "dark" : "light"), w = f || (r == null ? ref(l) : Si(r, l, n, { window: o, listenToStorageChanges: s })), g = computed({
    get() {
      return w.value === "auto" && !m ? v.value : w.value;
    },
    set(b) {
      w.value = b;
    }
  }), k = Ko("updateHTMLAttrs", (b, _, V) => {
    const T = o == null ? void 0 : o.document.querySelector(b);
    if (T)
      if (_ === "class") {
        const S = V.split(/\s/g);
        Object.values(B).flatMap((O) => (O || "").split(/\s/g)).filter(Boolean).forEach((O) => {
          S.includes(O) ? T.classList.add(O) : T.classList.remove(O);
        });
      } else
        T.setAttribute(_, V);
  });
  function y(b) {
    var _;
    const V = b === "auto" ? v.value : b;
    k(t, a, (_ = B[V]) != null ? _ : V);
  }
  function $(b) {
    e.onChanged ? e.onChanged(b, y) : y(b);
  }
  return watch(g, $, { flush: "post", immediate: true }), m && watch(v, () => $(g.value), { flush: "post" }), jo(() => $(g.value)), g;
}
var Vi = Object.defineProperty;
var Oi = Object.defineProperties;
var Pi = Object.getOwnPropertyDescriptors;
var Sl = Object.getOwnPropertySymbols;
var Ei = Object.prototype.hasOwnProperty;
var Ii = Object.prototype.propertyIsEnumerable;
var _l = (e, t, a) => t in e ? Vi(e, t, { enumerable: true, configurable: true, writable: true, value: a }) : e[t] = a;
var Fi = (e, t) => {
  for (var a in t || (t = {}))
    Ei.call(t, a) && _l(e, a, t[a]);
  if (Sl)
    for (var a of Sl(t))
      Ii.call(t, a) && _l(e, a, t[a]);
  return e;
};
var Li = (e, t) => Oi(e, Pi(t));
function Ni(e = {}) {
  const {
    valueDark: t = "dark",
    valueLight: a = "",
    window: l = Je
  } = e, o = Jo(Li(Fi({}, e), {
    onChanged: (s, f) => {
      var m;
      e.onChanged ? (m = e.onChanged) == null || m.call(e, s === "dark") : f(s);
    },
    modes: {
      dark: t,
      light: a
    }
  })), n = Xo({ window: l });
  return computed({
    get() {
      return o.value === "dark";
    },
    set(s) {
      s === n.value ? o.value = "auto" : o.value = s ? "dark" : "light";
    }
  });
}
function qe(e, t = {}) {
  const { initialValue: a = false } = t, l = ref(false), o = computed(() => ut(e));
  we(o, "focus", () => l.value = true), we(o, "blur", () => l.value = false);
  const n = computed({
    get: () => l.value,
    set(r) {
      var s, f;
      !r && l.value ? (s = o.value) == null || s.blur() : r && !l.value && ((f = o.value) == null || f.focus());
    }
  });
  return watch(o, () => {
    n.value = a;
  }, { immediate: true, flush: "post" }), { focused: n };
}
function zi(e = {}) {
  const {
    type: t = "page",
    touch: a = true,
    resetOnTouchEnds: l = false,
    initialValue: o = { x: 0, y: 0 },
    window: n = Je,
    eventFilter: r
  } = e, s = ref(o.x), f = ref(o.y), m = ref(null), B = (k) => {
    t === "page" ? (s.value = k.pageX, f.value = k.pageY) : t === "client" ? (s.value = k.clientX, f.value = k.clientY) : t === "movement" && (s.value = k.movementX, f.value = k.movementY), m.value = "mouse";
  }, h2 = () => {
    s.value = o.x, f.value = o.y;
  }, v = (k) => {
    if (k.touches.length > 0) {
      const y = k.touches[0];
      t === "page" ? (s.value = y.pageX, f.value = y.pageY) : t === "client" && (s.value = y.clientX, f.value = y.clientY), m.value = "touch";
    }
  }, w = (k) => r === void 0 ? B(k) : r(() => B(k), {}), g = (k) => r === void 0 ? v(k) : r(() => v(k), {});
  return n && (we(n, "mousemove", w, { passive: true }), we(n, "dragover", w, { passive: true }), a && t !== "movement" && (we(n, "touchstart", g, { passive: true }), we(n, "touchmove", g, { passive: true }), l && we(n, "touchend", h2, { passive: true }))), {
    x: s,
    y: f,
    sourceType: m
  };
}
function Tl(e, t = {}) {
  const {
    handleOutside: a = true,
    window: l = Je
  } = t, { x: o, y: n, sourceType: r } = zi(t), s = ref(e ?? (l == null ? void 0 : l.document.body)), f = ref(0), m = ref(0), B = ref(0), h2 = ref(0), v = ref(0), w = ref(0), g = ref(true);
  let k = () => {
  };
  return l && (k = watch([s, o, n], () => {
    const y = ut(s);
    if (!y)
      return;
    const {
      left: $,
      top: b,
      width: _,
      height: V
    } = y.getBoundingClientRect();
    B.value = $ + l.pageXOffset, h2.value = b + l.pageYOffset, v.value = V, w.value = _;
    const T = o.value - B.value, S = n.value - h2.value;
    g.value = _ === 0 || V === 0 || T < 0 || S < 0 || T > _ || S > V, (a || !g.value) && (f.value = T, m.value = S);
  }, { immediate: true }), we(document, "mouseleave", () => {
    g.value = true;
  })), {
    x: o,
    y: n,
    sourceType: r,
    elementX: f,
    elementY: m,
    elementPositionX: B,
    elementPositionY: h2,
    elementHeight: v,
    elementWidth: w,
    isOutside: g,
    stop: k
  };
}
var rt;
(function(e) {
  e.UP = "UP", e.RIGHT = "RIGHT", e.DOWN = "DOWN", e.LEFT = "LEFT", e.NONE = "NONE";
})(rt || (rt = {}));
function Ri(e, t = {}) {
  const {
    threshold: a = 50,
    onSwipe: l,
    onSwipeEnd: o,
    onSwipeStart: n,
    passive: r = true,
    window: s = Je
  } = t, f = reactive({ x: 0, y: 0 }), m = reactive({ x: 0, y: 0 }), B = computed(() => f.x - m.x), h2 = computed(() => f.y - m.y), { max: v, abs: w } = Math, g = computed(() => v(w(B.value), w(h2.value)) >= a), k = ref(false), y = computed(() => g.value ? w(B.value) > w(h2.value) ? B.value > 0 ? rt.LEFT : rt.RIGHT : h2.value > 0 ? rt.UP : rt.DOWN : rt.NONE), $ = (C) => [C.touches[0].clientX, C.touches[0].clientY], b = (C, F) => {
    f.x = C, f.y = F;
  }, _ = (C, F) => {
    m.x = C, m.y = F;
  };
  let V;
  const T = Hi(s == null ? void 0 : s.document);
  r ? V = T ? { passive: true } : { capture: false } : V = T ? { passive: false, capture: true } : { capture: true };
  const S = (C) => {
    k.value && (o == null || o(C, y.value)), k.value = false;
  }, O = [
    we(e, "touchstart", (C) => {
      V.capture && !V.passive && C.preventDefault();
      const [F, P] = $(C);
      b(F, P), _(F, P), n == null || n(C);
    }, V),
    we(e, "touchmove", (C) => {
      const [F, P] = $(C);
      _(F, P), !k.value && g.value && (k.value = true), k.value && (l == null || l(C));
    }, V),
    we(e, "touchend", S, V),
    we(e, "touchcancel", S, V)
  ];
  return {
    isPassiveEventSupported: T,
    isSwiping: k,
    direction: y,
    coordsStart: f,
    coordsEnd: m,
    lengthX: B,
    lengthY: h2,
    stop: () => O.forEach((C) => C())
  };
}
function Hi(e) {
  if (!e)
    return false;
  let t = false;
  const a = {
    get passive() {
      return t = true, false;
    }
  };
  return e.addEventListener("x", Qt, a), e.removeEventListener("x", Qt), t;
}
var Mi = Object.defineProperty;
var xl = Object.getOwnPropertySymbols;
var Di = Object.prototype.hasOwnProperty;
var ji = Object.prototype.propertyIsEnumerable;
var Al = (e, t, a) => t in e ? Mi(e, t, { enumerable: true, configurable: true, writable: true, value: a }) : e[t] = a;
var qi = (e, t) => {
  for (var a in t || (t = {}))
    Di.call(t, a) && Al(e, a, t[a]);
  if (xl)
    for (var a of xl(t))
      ji.call(t, a) && Al(e, a, t[a]);
  return e;
};
var Gi = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
qi({
  linear: li
}, Gi);
function Te(e, t, a, l = {}) {
  var o, n, r;
  const {
    clone: s = false,
    passive: f = false,
    eventName: m,
    deep: B = false,
    defaultValue: h2
  } = l, v = getCurrentInstance(), w = a || (v == null ? void 0 : v.emit) || ((o = v == null ? void 0 : v.$emit) == null ? void 0 : o.bind(v)) || ((r = (n = v == null ? void 0 : v.proxy) == null ? void 0 : n.$emit) == null ? void 0 : r.bind(v == null ? void 0 : v.proxy));
  let g = m;
  t || (t = "modelValue"), g = m || g || `update:${t.toString()}`;
  const k = ($) => s ? Ga(s) ? s($) : hi($) : $, y = () => Zs(e[t]) ? k(e[t]) : h2;
  if (f) {
    const $ = y(), b = ref($);
    return watch(() => e[t], (_) => b.value = k(_)), watch(b, (_) => {
      (_ !== e[t] || B) && w(g, _);
    }, { deep: B }), b;
  } else
    return computed({
      get() {
        return y();
      },
      set($) {
        w(g, $);
      }
    });
}
var zt = (e) => Mo(() => e.value ? `justify-content-${e.value}` : "");
function c(e) {
  return Mo(
    () => e.value === void 0 || e.value === null ? e.value : so(e.value)
  );
}
var Yo = {
  items: reactive([]),
  reset() {
    this.items = reactive([]);
  }
};
var Zo = (e) => {
  e.provide($o, Yo);
};
var Qo = () => inject($o, null) ?? Yo;
var Wi = (e = {}) => {
  const t = "data-bs-theme", a = "body";
  return Jo({
    attribute: t,
    selector: a,
    storageKey: e.persist === true ? `bv-color-${e.attribute ?? t}-${e.selector ?? a}` : null,
    ...e
  });
};
var Ui = (e, t = ref(1e3), a = {}) => {
  const l = ref(false), o = ref(0), n = ref(Se(e)), r = ref(Se(t)), s = computed(() => Math.ceil(n.value / r.value)), f = computed(
    () => h2.value || l.value ? Math.round(n.value - o.value * r.value) : 0
  ), { pause: m, resume: B, isActive: h2 } = qo(
    () => o.value = o.value + 1,
    t,
    a
  ), v = () => {
    l.value = false, o.value = 0, B();
  }, w = () => {
    l.value = false, o.value = s.value;
  };
  watchEffect(() => {
    const y = Se(e), $ = n.value;
    y !== $ && (n.value = y, w(), v());
  }), watchEffect(() => {
    const y = Se(t), $ = r.value;
    y !== $ && (r.value = y, w(), v());
  }), watchEffect(() => {
    o.value > s.value && (o.value = s.value), o.value === s.value && m();
  });
  const g = () => {
    h2.value !== false && (l.value = true, m());
  }, k = () => {
    o.value !== s.value && (l.value = false, B());
  };
  return {
    isActive: readonly(h2),
    isPaused: readonly(l),
    restart: v,
    stop: w,
    pause: g,
    resume: k,
    value: f
  };
};
var en = (e) => {
  const t = ref(Se(e));
  return watchEffect(() => t.value = Se(e)), computed(() => ({
    "form-check": t.value.plain === false && t.value.button === false,
    "form-check-inline": t.value.inline === true,
    "form-switch": t.value.switch === true,
    [`form-control-${t.value.size}`]: t.value.size !== void 0 && t.value.size !== "md" && t.value.button === false
  }));
};
var tn = (e) => {
  const t = ref(Se(e));
  return watchEffect(() => t.value = Se(e)), computed(() => ({
    "form-check-input": t.value.plain === false && t.value.button === false,
    "is-valid": t.value.state === true,
    "is-invalid": t.value.state === false,
    "btn-check": t.value.button === true
  }));
};
var an = (e) => {
  const t = ref(Se(e));
  return watchEffect(() => t.value = Se(e)), computed(() => ({
    "form-check-label": t.value.plain === false && t.value.button === false,
    btn: t.value.button === true,
    [`btn-${t.value.buttonVariant}`]: t.value.button === true && t.value.buttonVariant !== void 0,
    [`btn-${t.value.size}`]: t.value.button && t.value.size && t.value.size !== "md"
  }));
};
var ln = (e) => {
  const t = ref(Se(e));
  return watchEffect(() => t.value = Se(e)), computed(() => ({
    "aria-invalid": ua(t.value.ariaInvalid, t.value.state),
    "aria-required": t.value.required === true ? true : void 0
  }));
};
var on = (e) => {
  const t = ref(Se(e));
  return watchEffect(() => t.value = Se(e)), computed(() => ({
    "was-validated": t.value.validated === true,
    "btn-group": t.value.buttons === true && t.value.stacked === false,
    "btn-group-vertical": t.value.stacked === true && t.value.buttons === true,
    [`btn-group-${t.value.size}`]: t.value.size !== void 0
  }));
};
var nn = {
  ariaInvalid: {
    type: [Boolean, String],
    default: void 0
  },
  autocomplete: { type: String, required: false },
  autofocus: { type: Boolean, default: false },
  disabled: { type: Boolean, default: false },
  form: { type: String, required: false },
  formatter: { type: Function, required: false },
  id: { type: String, required: false },
  lazy: { type: Boolean, default: false },
  lazyFormatter: { type: Boolean, default: false },
  list: { type: String, required: false },
  modelValue: { type: [String, Number], default: "" },
  name: { type: String, required: false },
  number: { type: Boolean, default: false },
  placeholder: { type: String, required: false },
  plaintext: { type: Boolean, default: false },
  readonly: { type: Boolean, default: false },
  required: { type: Boolean, default: false },
  size: { type: String, required: false },
  state: { type: Boolean, default: null },
  trim: { type: Boolean, default: false }
};
var sn = (e, t) => {
  const a = ref();
  let l = null, o = true;
  const n = Ce(toRef(e, "id"), "input"), r = c(toRef(e, "state")), s = (y, $, b = false) => (y = String(y), typeof e.formatter == "function" && (!e.lazyFormatter || b) ? (o = false, e.formatter(y, $)) : y), f = (y) => e.trim ? y.trim() : e.number ? Number.parseFloat(y) : y, m = () => {
    var y;
    e.autofocus && ((y = a.value) == null || y.focus());
  };
  onMounted(() => {
    a.value && (a.value.value = e.modelValue), nextTick(() => {
      m();
    });
  }), onActivated(() => {
    nextTick(() => {
    });
  });
  const B = computed(
    () => ua(e.ariaInvalid, r.value)
  ), h2 = (y) => {
    const { value: $ } = y.target, b = s($, y);
    if (b === false || y.defaultPrevented) {
      y.preventDefault();
      return;
    }
    if (e.lazy)
      return;
    const _ = f(b);
    e.modelValue !== _ && (l = $, t("update:modelValue", _)), t("input", b);
  }, v = (y) => {
    const { value: $ } = y.target, b = s($, y);
    if (b === false || y.defaultPrevented) {
      y.preventDefault();
      return;
    }
    if (!e.lazy)
      return;
    l = $, t("update:modelValue", b);
    const _ = f(b);
    e.modelValue !== _ && t("change", b);
  }, w = (y) => {
    if (t("blur", y), !e.lazy && !e.lazyFormatter)
      return;
    const { value: $ } = y.target, b = s($, y, true);
    l = $, t("update:modelValue", b);
  }, g = () => {
    var y;
    e.disabled || (y = a.value) == null || y.focus();
  }, k = () => {
    var y;
    e.disabled || (y = a.value) == null || y.blur();
  };
  return watch(
    () => e.modelValue,
    (y) => {
      a.value && (a.value.value = l && o ? l : y, l = null, o = true);
    }
  ), {
    input: a,
    computedId: n,
    computedAriaInvalid: B,
    onInput: h2,
    onChange: v,
    onBlur: w,
    focus: g,
    blur: k
  };
};
var bt = (e, t) => {
  if (!e)
    return e;
  if (t in e)
    return e[t];
  const a = t.split(".");
  return bt(e[a[0]], a.splice(1).join("."));
};
var pa = (e, t = null, a, l) => {
  if (Object.prototype.toString.call(e) === "[object Object]") {
    const o = bt(e, l.valueField), n = bt(e, l.textField), r = bt(e, l.htmlField), s = bt(e, l.disabledField), f = e[l.optionsField] || null;
    return f !== null ? {
      label: String(bt(e, l.labelField) || n),
      options: Wa(f, a, l)
    } : {
      value: typeof o > "u" ? t || n : o,
      text: String(typeof n > "u" ? t : n),
      html: r,
      disabled: !!s
    };
  }
  return {
    value: t || e,
    text: String(e),
    disabled: false
  };
};
var Wa = (e, t, a) => Array.isArray(e) ? e.map((l) => pa(l, null, t, a)) : Object.prototype.toString.call(e) === "[object Object]" ? (console.warn(
  `[BootstrapVue warn]: ${t} - Setting prop "options" to an object is deprecated. Use the array format instead.`
), Object.keys(e).map((l) => {
  const o = e[l];
  switch (typeof o) {
    case "object":
      return pa(o.text, String(o.value), t, a);
    default:
      return pa(o, String(l), t, a);
  }
})) : [];
var Ce = (e, t) => computed(() => (e == null ? void 0 : e.value) || at(t));
var Ki = ["id"];
var Xi = ["innerHTML"];
var Ji = ["innerHTML"];
var Yi = ["id"];
var Zi = ["innerHTML"];
var Qi = ["innerHTML"];
var er = {
  inheritAttrs: false
};
var Ua = defineComponent({
  ...er,
  __name: "BPopover",
  props: {
    modelValue: { default: false },
    container: { default: null },
    target: { type: [Function, String, null], default: null },
    reference: { type: [Function, String, null], default: null },
    content: { default: void 0 },
    id: { default: void 0 },
    title: { default: void 0 },
    delay: { default: () => ({ show: 100, hide: 300 }) },
    click: { default: false },
    manual: { default: false },
    variant: { default: void 0 },
    offset: { default: null },
    customClass: { default: "" },
    placement: { default: "top" },
    strategy: { default: "absolute" },
    floatingMiddleware: { default: void 0 },
    noFlip: { default: false },
    noShift: { default: false },
    noFade: { default: false },
    noAutoClose: { default: false },
    hide: { default: true },
    realtime: { default: false },
    inline: { default: false },
    tooltip: { default: false },
    html: { default: false }
  },
  emits: ["show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "update:modelValue"],
  setup(e, { emit: t }) {
    const a = e, l = c(toRef(a, "modelValue")), o = ref(l.value);
    watchEffect(() => {
      t("update:modelValue", o.value);
    }), watch(l, () => {
      l.value !== o.value && (l.value ? ee() : re(new Event("update:modelValue")));
    });
    const n = Ce(toRef(a, "id"), "popover"), r = c(toRef(a, "click")), s = c(toRef(a, "manual")), f = c(toRef(a, "noShift")), m = c(toRef(a, "noFlip")), B = c(toRef(a, "noFade")), h2 = c(toRef(a, "noAutoClose")), v = c(toRef(a, "hide")), w = c(toRef(a, "realtime")), g = c(toRef(a, "inline")), k = c(toRef(a, "tooltip")), y = c(toRef(a, "html")), $ = ref(false), b = ref(null), _ = ref(null), V = ref(null), T = ref(null), S = ref(null), O = (U) => {
      if (typeof U == "string" || U instanceof HTMLElement)
        return U;
      if (typeof U == "function")
        return U().$el ? U().$el : U();
      if (typeof U < "u")
        return U.$el;
    }, I = (U) => {
      if (U) {
        if (typeof U == "string") {
          const ie = document.getElementById(U);
          return ie || void 0;
        }
        return U;
      }
    }, C = computed(
      () => a.title ? yt(a.title, ht) : ""
    ), F = computed(
      () => a.content ? yt(a.content, ht) : ""
    ), P = computed(() => {
      if (a.floatingMiddleware !== void 0)
        return a.floatingMiddleware;
      const U = a.offset ? a.offset : k.value ? 0 : 10, ie = [Oo(U)];
      return m.value === false && ie.push(Vo()), f.value === false && ie.push(Po()), v.value === true && ie.push(Os({ padding: 10 })), g.value === true && ie.push(Ps()), ie.push(Rs({ element: V, padding: 10 })), ie;
    }), W = computed(() => a.placement), { x: j, y: te, strategy: X, middlewareData: q, placement: ae, update: me } = Ho(_, b, {
      placement: W,
      middleware: P,
      strategy: a.strategy,
      whileElementsMounted: (...U) => Ns(...U, { animationFrame: w.value })
    }), pe = ref({ position: "absolute" });
    watch(q, () => {
      var U;
      if (v.value === true && ((U = q.value.hide) != null && U.referenceHidden ? $.value = true : $.value = false), q.value.arrow) {
        const { x: ie, y: Re } = q.value.arrow;
        pe.value = {
          position: "absolute",
          top: Re ? `${Re}px` : "",
          left: ie ? `${ie}px` : ""
        };
      }
    });
    const be = computed(() => {
      const U = k.value ? "tooltip" : "popover";
      return [
        U,
        `b-${U}`,
        {
          [`b-${U}-${a.variant}`]: a.variant !== void 0,
          show: o.value && !$.value,
          ["pe-none"]: !o.value,
          fade: !B.value,
          ["d-none"]: !o.value && B.value,
          [`${a.customClass}`]: a.customClass !== void 0,
          [`bs-${U}-${ar(ae.value)}`]: ae.value !== void 0
        }
      ];
    }), { isOutside: ne } = Tl(b), { isOutside: ve } = Tl(T), L = (U) => {
      const ie = U ?? new Event("click");
      o.value ? re(ie) : ee();
    }, z = (U, ie = {}) => new Ft(U, {
      cancelable: false,
      target: b.value || null,
      relatedTarget: null,
      trigger: null,
      ...ie,
      componentId: n.value
    }), ee = () => {
      var ie;
      const U = z("show", { cancelable: true });
      if (t("show", U), U.defaultPrevented) {
        t("show-prevented");
        return;
      }
      setTimeout(
        () => {
          me(), o.value = true, nextTick(() => {
            t("shown", z("shown"));
          });
        },
        typeof a.delay == "number" ? a.delay : ((ie = a.delay) == null ? void 0 : ie.show) || 0
      );
    }, re = (U) => {
      var Ie;
      const ie = z("hide", { cancelable: true });
      if (t("hide", ie), ie.defaultPrevented) {
        t("hide-prevented");
        return;
      }
      const Re = typeof a.delay == "number" ? a.delay : ((Ie = a.delay) == null ? void 0 : Ie.hide) || 100;
      setTimeout(() => {
        var E;
        (U == null ? void 0 : U.type) === "click" || ne.value && ve.value && !((E = b.value) != null && E.contains(document == null ? void 0 : document.activeElement)) ? (o.value = false, nextTick(() => {
          t("hidden", z("hidden"));
        })) : setTimeout(() => {
          re(U);
        }, Re);
      }, Re);
    }, he = () => {
      var U;
      if (a.target) {
        const ie = I(O(a.target));
        ie ? T.value = ie : console.warn("Target element not found", a.target);
      } else
        T.value = (U = S.value) == null ? void 0 : U.nextElementSibling;
      if (a.reference) {
        const ie = I(O(a.reference));
        ie ? _.value = ie : console.warn("Reference element not found", a.reference);
      } else
        _.value = T.value;
      !T.value || s.value || za && (r.value && T.value.addEventListener("click", L), !r.value && T.value.addEventListener("pointerenter", ee), !r.value && T.value.addEventListener("pointerleave", re), !r.value && T.value.addEventListener("focus", ee), !r.value && T.value.addEventListener("blur", re));
    }, Oe = () => {
      T.value && (T.value.removeEventListener("click", L), T.value.removeEventListener("pointerenter", ee), T.value.removeEventListener("pointerleave", re), T.value.removeEventListener("focus", ee), T.value.removeEventListener("blur", re));
    };
    return Uo(
      b,
      () => {
        o.value && r.value && !h2.value && !s.value && re(new Event("clickOutside"));
      },
      { ignore: [T] }
    ), watch(
      () => [a.click, a.target, a.reference],
      () => {
        Oe(), he();
      }
    ), onMounted(he), onBeforeUnmount(Oe), (U, ie) => (openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("span", {
        ref_key: "placeholder",
        ref: S
      }, null, 512),
      renderSlot(U.$slots, "target", normalizeProps(guardReactiveProps({ show: ee, hide: re, toggle: L, showState: o.value }))),
      e.container ? (openBlock(), createBlock(Teleport, {
        key: 0,
        to: e.container
      }, [
        createBaseVNode("div", mergeProps({ id: e.id }, U.$attrs, {
          ref_key: "element",
          ref: b,
          class: unref(be),
          role: "tooltip",
          tabindex: "-1",
          style: {
            position: unref(X),
            top: `${unref(te) ?? 0}px`,
            left: `${unref(j) ?? 0}px`,
            width: "max-content"
          }
        }), [
          createBaseVNode("div", {
            ref_key: "arrow",
            ref: V,
            class: normalizeClass(`${unref(k) ? "tooltip" : "popover"}-arrow`),
            style: normalizeStyle(pe.value),
            "data-popper-arrow": ""
          }, null, 6),
          e.title || U.$slots.title ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            unref(y) ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass(unref(k) ? "tooltip-inner" : "popover-header"),
              innerHTML: unref(C)
            }, null, 10, Xi)) : (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(unref(k) ? "tooltip-inner" : "popover-header")
            }, [
              renderSlot(U.$slots, "title", {}, () => [
                createTextVNode(toDisplayString(e.title), 1)
              ])
            ], 2))
          ], 64)) : createCommentVNode("", true),
          unref(k) && !U.$slots.title && !e.title || !unref(k) ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            unref(y) ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass(unref(k) ? "tooltip-inner" : "popover-body"),
              innerHTML: unref(F)
            }, null, 10, Ji)) : (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(unref(k) ? "tooltip-inner" : "popover-body")
            }, [
              renderSlot(U.$slots, "default", {}, () => [
                createTextVNode(toDisplayString(e.content), 1)
              ])
            ], 2))
          ], 64)) : createCommentVNode("", true)
        ], 16, Ki)
      ], 8, ["to"])) : (openBlock(), createElementBlock("div", mergeProps({
        key: 1,
        id: e.id
      }, U.$attrs, {
        ref_key: "element",
        ref: b,
        class: unref(be),
        role: "tooltip",
        tabindex: "-1",
        style: {
          position: unref(X),
          top: `${unref(te) ?? 0}px`,
          left: `${unref(j) ?? 0}px`,
          width: "max-content"
        }
      }), [
        createBaseVNode("div", {
          ref_key: "arrow",
          ref: V,
          class: normalizeClass(`${unref(k) ? "tooltip" : "popover"}-arrow`),
          style: normalizeStyle(pe.value),
          "data-popper-arrow": ""
        }, null, 6),
        e.title || U.$slots.title ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          unref(y) ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass(unref(k) ? "tooltip-inner" : "popover-header"),
            innerHTML: unref(C)
          }, null, 10, Zi)) : (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(unref(k) ? "tooltip-inner" : "popover-header")
          }, [
            renderSlot(U.$slots, "title", {}, () => [
              createTextVNode(toDisplayString(e.title), 1)
            ])
          ], 2))
        ], 64)) : createCommentVNode("", true),
        unref(k) && !U.$slots.title && !e.title || !unref(k) ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          unref(y) ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass(unref(k) ? "tooltip-inner" : "popover-body"),
            innerHTML: unref(F)
          }, null, 10, Qi)) : (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(unref(k) ? "tooltip-inner" : "popover-body")
          }, [
            renderSlot(U.$slots, "default", {}, () => [
              createTextVNode(toDisplayString(e.content), 1)
            ])
          ], 2))
        ], 64)) : createCommentVNode("", true)
      ], 16, Yi))
    ], 64));
  }
});
var tr = ({
  top: e,
  end: t,
  start: a,
  alignCenter: l,
  alignEnd: o
}) => {
  const n = e ? "top" : a ? "left" : t ? "right" : "bottom", r = o ? "end" : l ? null : "start";
  return `${n}${r ? `-${r}` : ""}`;
};
var ar = (e) => {
  const [t] = e.split("-");
  switch (t) {
    case "left":
      return "start";
    case "right":
      return "end";
    default:
      return t;
  }
};
var aa = (e, t) => {
  if ((typeof e > "u" || typeof e == "object" && !(e != null && e.title) && !(e != null && e.content)) && !t.getAttribute("title"))
    return console.warn(
      "Review tooltip directive usage. Some uses are not defining a title in root component or a value like `v-b-tooltip='{title: \"my title\"}'` nor `v-b-tooltip=\"'my title'\"` to define a title"
    ), {};
  if ((typeof e > "u" || typeof e == "object" && !(e != null && e.title) && !(e != null && e.content)) && (t.getAttribute("title") || t.getAttribute("data-original-title"))) {
    const a = t.getAttribute("title") ?? t.getAttribute("data-original-title");
    if (a && a !== "")
      return t.removeAttribute("title"), t.setAttribute("data-original-title", a), {
        content: yt(a, ht)
      };
  }
  return typeof e == "string" ? {
    content: yt(e, ht)
  } : {
    title: e != null && e.title ? yt(e == null ? void 0 : e.title, ht) : void 0,
    content: e != null && e.content ? yt(e == null ? void 0 : e.content, ht) : void 0
  };
};
var la = (e, t) => ({
  target: () => t,
  modelValue: e.modifiers.show,
  inline: e.modifiers.inline,
  click: e.modifiers.click,
  realtime: e.modifiers.realtime,
  placement: e.modifiers.left ? "left" : e.modifiers.right ? "right" : e.modifiers.bottom ? "bottom" : e.modifiers.top ? "top" : void 0,
  html: true,
  ...typeof e.value == "object" ? e.value : {},
  title: null,
  content: null
});
var rn = (e, t) => {
  var l;
  const a = document.createElement("span");
  t.modifiers.body ? document.body.appendChild(a) : t.modifiers.child ? e.appendChild(a) : (l = e.parentNode) == null || l.insertBefore(a, e.nextSibling), e.$__app = createApp({ render: () => {
    var o;
    return h(Ua, { ...(o = e.$__state) == null ? void 0 : o.value });
  } }), e.$__app.mount(a), e.$__element = a;
};
var un = (e) => {
  var a;
  const t = e.$__element;
  (a = e.$__app) == null || a.unmount(), delete e.$__app, delete e.$__state, setTimeout(() => {
    t == null || t.remove();
  }, 0), delete e.$__element;
};
var lr = ["id"];
var or = defineComponent({
  __name: "BAccordion",
  props: {
    flush: { default: false },
    free: { default: false },
    id: { default: void 0 },
    modelValue: null
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const a = e, l = Te(a, "modelValue", t, { passive: true }), o = Ce(toRef(a, "id"), "accordion"), n = c(toRef(a, "flush")), r = c(toRef(a, "free")), s = computed(() => ({
      "accordion-flush": n.value
    }));
    return provide(So, {
      openItem: readonly(l),
      free: r,
      setOpenItem: (f) => {
        l.value = f;
      }
    }), (f, m) => (openBlock(), createElementBlock("div", {
      id: unref(o),
      class: normalizeClass(["accordion", unref(s)])
    }, [
      renderSlot(f.$slots, "default")
    ], 10, lr));
  }
});
var nr = {
  inheritAttrs: false
};
var dn = defineComponent({
  ...nr,
  __name: "BCollapse",
  props: {
    id: { default: void 0 },
    modelValue: { default: false },
    tag: { default: "div" },
    toggle: { default: false },
    horizontal: { default: false },
    visible: { default: false },
    isNav: { default: false }
  },
  emits: ["show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "update:modelValue"],
  setup(e, { expose: t, emit: a }) {
    const l = e, o = (S, O = {}) => new Ft(S, {
      cancelable: false,
      target: v.value || null,
      relatedTarget: null,
      trigger: null,
      ...O,
      componentId: h2.value
    }), n = Te(l, "modelValue", a, { passive: true }), r = c(n), s = c(toRef(l, "toggle")), f = c(toRef(l, "horizontal")), m = c(toRef(l, "isNav")), B = c(toRef(l, "visible")), h2 = Ce(toRef(l, "id"), "collapse"), v = ref(null), w = ref(false), g = ref(r.value), k = computed(() => ({
      show: g.value,
      "navbar-collapse": m.value,
      collapsing: w.value,
      closing: g.value && !r.value,
      "collapse-horizontal": f.value
    })), y = () => n.value = false, $ = () => n.value = true, b = () => n.value = !r.value, _ = () => {
      g.value = true, w.value = true;
      const S = o("show", { cancelable: true });
      if (a("show", S), S.defaultPrevented) {
        a("show-prevented");
        return;
      }
      nextTick(() => {
        v.value !== null && (f.value ? v.value.style.width = `${v.value.scrollWidth}px` : v.value.style.height = `${v.value.scrollHeight}px`, setTimeout(() => {
          w.value = false, a("shown", o("shown")), v.value !== null && (v.value.style.height = "", v.value.style.width = "");
        }, T(v.value)));
      });
    }, V = () => {
      const S = o("hide", { cancelable: true });
      if (a("hide", S), S.defaultPrevented) {
        a("hide-prevented");
        return;
      }
      v.value !== null && (f.value ? v.value.style.width = `${v.value.scrollWidth}px` : v.value.style.height = `${v.value.scrollHeight}px`, v.value.offsetHeight, w.value = true, nextTick(() => {
        v.value !== null && (v.value.style.height = "", v.value.style.width = "", setTimeout(() => {
          g.value = false, w.value = false, a("hidden", o("hidden"));
        }, T(v.value)));
      }));
    };
    watch([n, g], () => {
      if (r.value === true) {
        if (g.value)
          return;
        _();
        return;
      }
      V();
    });
    const T = (S) => {
      const O = window.getComputedStyle(S), I = O.transitionDelay.split(",")[0] || "", C = O.transitionDuration.split(",")[0] || "", F = Number(I.slice(0, -1)) * 1e3, P = Number(C.slice(0, -1)) * 1e3;
      return F + P;
    };
    return onMounted(() => {
      v.value !== null && !r.value && s.value && nextTick(() => {
        n.value = true;
      });
    }), B.value && (n.value = true, g.value = true), watch(B, (S) => {
      S ? $() : y();
    }), we(v, "bv-toggle", () => {
      n.value = !r.value;
    }), t({
      close: y,
      open: $,
      toggle: b,
      visible: readonly(g),
      isNav: m
    }), provide(Ma, {
      id: h2,
      close: y,
      open: $,
      toggle: b,
      visible: readonly(g),
      isNav: m
    }), (S, O) => (openBlock(), createElementBlock(Fragment, null, [
      renderSlot(S.$slots, "header", normalizeProps(guardReactiveProps({ visible: unref(r), toggle: b, open: $, close: y, id: unref(h2) }))),
      (openBlock(), createBlock(resolveDynamicComponent(e.tag), mergeProps({
        id: unref(h2),
        ref_key: "element",
        ref: v,
        class: ["collapse", unref(k)],
        "is-nav": unref(m)
      }, S.$attrs), {
        default: withCtx(() => [
          renderSlot(S.$slots, "default", normalizeProps(guardReactiveProps({ visible: unref(r), toggle: b, open: $, close: y })))
        ]),
        _: 3
      }, 16, ["id", "class", "is-nav"])),
      renderSlot(S.$slots, "footer", normalizeProps(guardReactiveProps({ visible: unref(r), toggle: b, open: $, close: y, id: unref(h2) })))
    ], 64));
  }
});
var sr = { class: "accordion-item" };
var ir = ["aria-expanded", "aria-controls", "onClick"];
var rr = { class: "accordion-body" };
var ur = {
  inheritAttrs: false
};
var dr = defineComponent({
  ...ur,
  __name: "BAccordionItem",
  props: {
    id: { default: void 0 },
    title: { default: void 0 },
    modelValue: { default: false },
    headerTag: { default: "h2" },
    tag: null,
    toggle: null,
    horizontal: null,
    visible: { default: false },
    isNav: null
  },
  emits: ["show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "update:modelValue"],
  setup(e, { emit: t }) {
    const a = e, l = {
      show: (s) => t("show", s),
      shown: (s) => t("shown", s),
      hide: (s) => t("hide", s),
      hidden: (s) => t("hidden", s),
      "hide-prevented": () => t("hide-prevented"),
      "show-prevented": () => t("show-prevented")
    }, o = Te(a, "modelValue", t, { passive: true }), n = inject(So, null), r = Ce(toRef(a, "id"), "accordion_item");
    return onMounted(() => {
      o.value && !(n != null && n.free.value) && (n == null || n.setOpenItem(r.value)), !o.value && (n == null ? void 0 : n.openItem.value) === r.value && (o.value = true);
    }), watch(
      () => n == null ? void 0 : n.openItem.value,
      () => o.value = (n == null ? void 0 : n.openItem.value) === r.value && !(n != null && n.free.value)
    ), watch(o, () => {
      o.value && !(n != null && n.free.value) && (n == null || n.setOpenItem(r.value));
    }), (s, f) => (openBlock(), createElementBlock("div", sr, [
      createVNode(dn, mergeProps({
        id: unref(r),
        modelValue: unref(o),
        "onUpdate:modelValue": f[0] || (f[0] = (m) => isRef(o) ? o.value = m : null),
        class: "accordion-collapse"
      }, s.$attrs, {
        "aria-labelledby": `heading${unref(r)}`,
        tag: e.tag,
        toggle: e.toggle,
        horizontal: e.horizontal,
        visible: e.visible,
        "is-nav": e.isNav
      }, toHandlers(l)), {
        header: withCtx(({ visible: m, toggle: B }) => [
          (openBlock(), createBlock(resolveDynamicComponent(e.headerTag), {
            id: `heading${unref(r)}`,
            class: "accordion-header"
          }, {
            default: withCtx(() => [
              createBaseVNode("button", {
                class: normalizeClass(["accordion-button", { collapsed: !m }]),
                type: "button",
                "aria-expanded": m ? "true" : "false",
                "aria-controls": unref(r),
                onClick: B
              }, [
                renderSlot(s.$slots, "title", {}, () => [
                  createTextVNode(toDisplayString(e.title), 1)
                ])
              ], 10, ir)
            ]),
            _: 2
          }, 1032, ["id"]))
        ]),
        default: withCtx(() => [
          createBaseVNode("div", rr, [
            renderSlot(s.$slots, "default")
          ])
        ]),
        _: 3
      }, 16, ["id", "modelValue", "aria-labelledby", "tag", "toggle", "horizontal", "visible", "is-nav"])
    ]));
  }
});
var _t = defineComponent({
  __name: "BTransition",
  props: {
    appear: { default: false },
    mode: { default: void 0 },
    noFade: { default: false },
    transProps: { default: void 0 }
  },
  setup(e) {
    const t = e, a = c(toRef(t, "appear")), l = c(toRef(t, "noFade")), o = computed(() => {
      const s = {
        name: "",
        enterActiveClass: "",
        enterToClass: "",
        leaveActiveClass: "",
        leaveToClass: "showing",
        enterFromClass: "showing",
        leaveFromClass: ""
      }, f = {
        ...s,
        enterActiveClass: "fade showing",
        leaveActiveClass: "fade showing"
      };
      return l.value ? s : f;
    }), n = computed(() => ({ mode: t.mode, css: true, ...o.value })), r = computed(
      () => t.transProps !== void 0 ? {
        // Order matters here since the props.transProps would get overwritten if it came first
        // But the goal of props.transProps is to overwrite base properties
        ...n.value,
        ...t.transProps
      } : a.value ? {
        ...n.value,
        appear: true,
        appearActiveClass: o.value.enterActiveClass,
        appearToClass: o.value.enterToClass
      } : n.value
    );
    return (s, f) => (openBlock(), createBlock(Transition, normalizeProps(guardReactiveProps(unref(r))), {
      default: withCtx(() => [
        renderSlot(s.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var cr = ["type", "disabled", "aria-label"];
var Tt = defineComponent({
  __name: "BCloseButton",
  props: {
    ariaLabel: { default: "Close" },
    disabled: { default: false },
    white: { default: false },
    type: { default: "button" }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = e, l = c(toRef(a, "disabled")), o = c(toRef(a, "white")), n = computed(() => ({
      "btn-close-white": o.value
    }));
    return (r, s) => (openBlock(), createElementBlock("button", {
      type: e.type,
      class: normalizeClass(["btn-close", unref(n)]),
      disabled: unref(l),
      "aria-label": e.ariaLabel,
      onClick: s[0] || (s[0] = (f) => t("click", f))
    }, null, 10, cr));
  }
});
var fr = {
  key: 0,
  class: "visually-hidden"
};
var fa = defineComponent({
  __name: "BSpinner",
  props: {
    label: { default: void 0 },
    role: { default: "status" },
    small: { default: false },
    tag: { default: "span" },
    type: { default: "border" },
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = useSlots(), l = c(toRef(t, "small")), o = computed(() => ({
      "spinner-border": t.type === "border",
      "spinner-border-sm": t.type === "border" && l.value,
      "spinner-grow": t.type === "grow",
      "spinner-grow-sm": t.type === "grow" && l.value,
      [`text-${t.variant}`]: t.variant !== void 0
    })), n = computed(() => !Ve(a.label));
    return (r, s) => (openBlock(), createBlock(resolveDynamicComponent(e.tag), {
      class: normalizeClass(unref(o)),
      role: e.label || unref(n) ? e.role : null,
      "aria-hidden": e.label || unref(n) ? null : true
    }, {
      default: withCtx(() => [
        e.label || unref(n) ? (openBlock(), createElementBlock("span", fr, [
          renderSlot(r.$slots, "label", {}, () => [
            createTextVNode(toDisplayString(e.label), 1)
          ])
        ])) : createCommentVNode("", true)
      ]),
      _: 3
    }, 8, ["class", "role", "aria-hidden"]));
  }
});
var mt = {
  active: { type: [Boolean, String, void 0], default: void 0 },
  activeClass: { type: String, default: "router-link-active" },
  append: { type: [Boolean, String], default: false },
  disabled: { type: [Boolean, String], default: false },
  event: { type: [String, Array], default: "click" },
  href: { type: String },
  // noPrefetch: {type: [Boolean, String] as PropType<Booleanish>, default: false},
  // prefetch: {type: [Boolean, String] as PropType<Booleanish>, default: null},
  rel: { type: String, default: null },
  replace: { type: [Boolean, String], default: false },
  routerComponentName: { type: String, default: "router-link" },
  routerTag: { type: String, default: "a" },
  target: { type: String, default: "_self" },
  to: { type: [String, Object], default: null }
};
var vr = defineComponent({
  // TODO this component will likely have an issue with inheritAttrs
  props: mt,
  emits: ["click"],
  setup(e, { emit: t, attrs: a }) {
    const l = c(toRef(e, "active")), o = c(toRef(e, "append")), n = c(toRef(e, "disabled")), r = c(toRef(e, "replace")), s = inject(Ma, null), f = () => {
      var y;
      (y = s == null ? void 0 : s.close) == null || y.call(s);
    }, m = getCurrentInstance(), B = ref(null), h2 = computed(() => {
      const y = e.routerComponentName.split("-").map((b) => b.charAt(0).toUpperCase() + b.slice(1)).join("");
      return !((m == null ? void 0 : m.appContext.app.component(y)) !== void 0) || n.value || !e.to ? "a" : e.routerComponentName;
    }), v = computed(() => {
      const y = "#";
      if (e.href)
        return e.href;
      if (typeof e.to == "string")
        return e.to || y;
      const $ = e.to;
      if (Object.prototype.toString.call($) === "[object Object]" && ($.path || $.query || $.hash)) {
        const b = $.path || "", _ = $.query ? `?${Object.keys($.query).map((T) => `${T}=${$.query[T]}`).join("=")}` : "", V = !$.hash || $.hash.charAt(0) === "#" ? $.hash || "" : `#${$.hash}`;
        return `${b}${_}${V}` || y;
      }
      return y;
    }), w = computed(() => ({
      to: e.to,
      href: v.value,
      target: e.target,
      rel: e.target === "_blank" && e.rel === null ? "noopener" : e.rel || null,
      tabindex: n.value ? "-1" : typeof a.tabindex > "u" ? null : a.tabindex,
      "aria-disabled": n.value ? true : null
    }));
    return {
      computedLinkClasses: computed(() => ({
        active: l.value,
        disabled: n.value
      })),
      tag: h2,
      routerAttr: w,
      link: B,
      clicked: (y) => {
        var $;
        if (n.value) {
          y.preventDefault(), y.stopImmediatePropagation();
          return;
        }
        ($ = s == null ? void 0 : s.close) == null || $.call(s), t("click", y);
      },
      activeBoolean: l,
      appendBoolean: o,
      disabledBoolean: n,
      replaceBoolean: r,
      closeCollapse: f
    };
  }
});
var ze = (e, t) => {
  const a = e.__vccOpts || e;
  for (const [l, o] of t)
    a[l] = o;
  return a;
};
function mr(e, t, a, l, o, n) {
  return e.tag === "router-link" ? (openBlock(), createBlock(resolveDynamicComponent(e.tag), mergeProps({ key: 0 }, e.routerAttr, { custom: "" }), {
    default: withCtx(({ href: r, navigate: s, isActive: f }) => [
      (openBlock(), createBlock(resolveDynamicComponent(e.routerTag), mergeProps({
        ref: "link",
        href: r,
        class: [(e.activeBoolean ?? f) && e.activeClass]
      }, e.$attrs, {
        onClick: (m) => {
          s(m), e.closeCollapse();
        }
      }), {
        default: withCtx(() => [
          renderSlot(e.$slots, "default")
        ]),
        _: 2
      }, 1040, ["href", "class", "onClick"]))
    ]),
    _: 3
  }, 16)) : (openBlock(), createBlock(resolveDynamicComponent(e.tag), mergeProps({
    key: 1,
    ref: "link",
    class: e.computedLinkClasses
  }, e.routerAttr, { onClick: e.clicked }), {
    default: withCtx(() => [
      renderSlot(e.$slots, "default")
    ]),
    _: 3
  }, 16, ["class", "onClick"]));
}
var Ne = ze(vr, [["render", mr]]);
var pr = defineComponent({
  components: { BLink: Ne, BSpinner: fa },
  props: {
    ...mt,
    active: { type: [Boolean, String], default: false },
    disabled: { type: [Boolean, String], default: false },
    href: { type: String, default: void 0 },
    pill: { type: [Boolean, String], default: false },
    pressed: { type: [Boolean, String], default: null },
    rel: { type: String, default: void 0 },
    size: { type: String, default: "md" },
    squared: { type: [Boolean, String], default: false },
    tag: { type: String, default: "button" },
    target: { type: String, default: "_self" },
    type: { type: String, default: "button" },
    variant: { type: String, default: "secondary" },
    loading: { type: [Boolean, String], default: false },
    loadingMode: { type: String, default: "inline" }
  },
  emits: ["click", "update:pressed"],
  setup(e, { emit: t }) {
    const a = Te(e, "pressed", t), l = c(toRef(e, "active")), o = c(toRef(e, "disabled")), n = c(toRef(e, "pill")), r = c(toRef(e, "pressed")), s = c(toRef(e, "squared")), f = c(toRef(e, "loading")), m = computed(() => typeof r.value == "boolean"), B = computed(
      () => e.tag === "button" && e.href === void 0 && e.to === null
    ), h2 = computed(() => Et(e)), v = computed(() => e.to !== null), w = computed(
      () => e.href !== void 0 ? false : !B.value
    ), g = computed(() => [
      [`btn-${e.variant}`],
      [`btn-${e.size}`],
      {
        active: l.value || r.value,
        "rounded-pill": n.value,
        "rounded-0": s.value,
        disabled: o.value
      }
    ]), k = computed(() => ({
      "aria-disabled": w.value ? o.value : null,
      "aria-pressed": m.value ? r.value : null,
      autocomplete: m.value ? "off" : null,
      disabled: B.value ? o.value : null,
      href: e.href,
      rel: h2.value ? e.rel : null,
      role: w.value || h2.value ? "button" : null,
      target: h2.value ? e.target : null,
      type: B.value ? e.type : null,
      to: B.value ? null : e.to,
      append: h2.value ? e.append : null,
      activeClass: v.value ? e.activeClass : null,
      event: v.value ? e.event : null,
      replace: v.value ? e.replace : null,
      routerComponentName: v.value ? e.routerComponentName : null,
      routerTag: v.value ? e.routerTag : null
    })), y = computed(
      () => v.value ? Ne : e.href ? "a" : e.tag
    );
    return {
      computedClasses: g,
      computedAttrs: k,
      computedTag: y,
      clicked: (b) => {
        if (o.value) {
          b.preventDefault(), b.stopPropagation();
          return;
        }
        t("click", b), m.value && (a.value = !r.value);
      },
      loadingBoolean: f
    };
  }
});
function gr(e, t, a, l, o, n) {
  const r = resolveComponent("b-spinner");
  return openBlock(), createBlock(resolveDynamicComponent(e.computedTag), mergeProps({
    class: ["btn", e.computedClasses]
  }, e.computedAttrs, { onClick: e.clicked }), {
    default: withCtx(() => [
      e.loadingBoolean ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(["btn-loading", { "mode-fill": e.loadingMode === "fill", "mode-inline": e.loadingMode === "inline" }])
      }, [
        renderSlot(e.$slots, "loading", {}, () => [
          createVNode(r, {
            class: "btn-spinner",
            small: e.size !== "lg"
          }, null, 8, ["small"])
        ])
      ], 2)) : createCommentVNode("", true),
      createBaseVNode("div", {
        class: normalizeClass(["btn-content", { "btn-loading-fill": e.loadingBoolean && e.loadingMode === "fill" }])
      }, [
        renderSlot(e.$slots, "default")
      ], 2)
    ]),
    _: 3
  }, 16, ["class", "onClick"]);
}
var kt = ze(pr, [["render", gr]]);
var br = ["onMouseenter"];
var hr = defineComponent({
  __name: "BAlert",
  props: {
    noHoverPause: { default: false },
    dismissLabel: { default: "Close" },
    dismissible: { default: false },
    fade: { default: false },
    closeVariant: { default: "secondary" },
    modelValue: { type: [Boolean, Number], default: false },
    variant: { default: "info" },
    closeContent: { default: void 0 },
    immediate: { default: true },
    interval: { default: 1e3 },
    showOnPause: { default: true }
  },
  emits: ["closed", "close-countdown", "update:modelValue"],
  setup(e, { expose: t, emit: a }) {
    const l = e, o = useSlots(), n = Te(l, "modelValue", a), r = c(toRef(l, "dismissible")), s = c(toRef(l, "fade")), f = c(toRef(l, "immediate")), m = c(toRef(l, "showOnPause")), B = c(toRef(l, "noHoverPause")), h2 = computed(() => !Ve(o.close)), v = computed(
      () => typeof n.value == "boolean" ? 0 : n.value
    ), w = computed(() => [
      [`alert-${l.variant}`],
      {
        "alert-dismissible": r.value
      }
    ]), {
      isActive: g,
      pause: k,
      restart: y,
      resume: $,
      stop: b,
      isPaused: _,
      value: V
    } = Ui(v, toRef(l, "interval"), {
      immediate: typeof n.value == "number" && f.value
    }), T = computed(
      () => typeof n.value == "boolean" ? n.value : g.value || m.value && _.value
    ), S = computed(() => ({
      variant: l.closeVariant,
      type: "button"
    }));
    watchEffect(() => a("close-countdown", V.value));
    const O = () => {
      typeof n.value == "boolean" ? n.value = false : (n.value = 0, b()), a("closed");
    }, I = () => {
      B.value || k();
    };
    return onBeforeUnmount(b), t({ pause: k, resume: $, restart: y, stop: b }), (C, F) => (openBlock(), createBlock(_t, {
      "no-fade": !unref(s),
      "trans-props": { enterToClass: "show" }
    }, {
      default: withCtx(() => [
        unref(T) ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(["alert", unref(w)]),
          role: "alert",
          "aria-live": "polite",
          "aria-atomic": "true",
          onMouseenter: withModifiers(I, ["stop"]),
          onMouseleave: F[0] || (F[0] = withModifiers(
            //@ts-ignore
            (...P) => unref($) && unref($)(...P),
            ["stop"]
          ))
        }, [
          renderSlot(C.$slots, "default"),
          unref(r) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            unref(h2) || e.closeContent ? (openBlock(), createBlock(kt, mergeProps({ key: 0 }, unref(S), { onClick: O }), {
              default: withCtx(() => [
                renderSlot(C.$slots, "close", {}, () => [
                  createTextVNode(toDisplayString(e.closeContent), 1)
                ])
              ]),
              _: 3
            }, 16)) : (openBlock(), createBlock(Tt, mergeProps({
              key: 1,
              "aria-label": e.dismissLabel
            }, unref(S), { onClick: O }), null, 16, ["aria-label"]))
          ], 64)) : createCommentVNode("", true)
        ], 42, br)) : createCommentVNode("", true)
      ]),
      _: 3
    }, 8, ["no-fade"]));
  }
});
var yr = {
  key: 0,
  class: "b-avatar-custom"
};
var Br = {
  key: 1,
  class: "b-avatar-img"
};
var $r = ["src", "alt"];
var Sa = (e) => {
  const t = typeof e == "string" && ro(e) ? At(e, 0) : e;
  return typeof t == "number" ? `${t}px` : t || null;
};
var wr = defineComponent({
  __name: "BAvatar",
  props: {
    alt: { default: "avatar" },
    ariaLabel: { default: void 0 },
    badge: { type: [Boolean, String], default: false },
    badgeLeft: { default: false },
    badgeOffset: { default: void 0 },
    badgeTop: { default: false },
    badgeVariant: { default: "primary" },
    button: { default: false },
    buttonType: { default: "button" },
    disabled: { default: false },
    icon: { default: void 0 },
    rounded: { type: [Boolean, String], default: "circle" },
    size: { default: void 0 },
    square: { default: false },
    src: { default: void 0 },
    text: { default: void 0 },
    textVariant: { default: void 0 },
    variant: { default: "secondary" }
  },
  emits: ["click", "img-error"],
  setup(e, { emit: t }) {
    const a = e, l = useSlots(), o = inject(Co, null), n = ["sm", null, "lg"], r = 0.4, s = r * 0.7, f = c(toRef(a, "badgeLeft")), m = c(toRef(a, "badgeTop")), B = c(toRef(a, "button")), h2 = c(toRef(a, "disabled")), v = c(toRef(a, "square")), w = computed(() => !Ve(l.default)), g = computed(() => !Ve(l.badge)), k = computed(() => !!a.badge || a.badge === "" || g.value), y = computed(
      () => (o == null ? void 0 : o.size.value) ?? Sa(a.size)
    ), $ = computed(() => (o == null ? void 0 : o.variant.value) ?? a.variant), b = computed(() => (o == null ? void 0 : o.rounded.value) ?? a.rounded), _ = computed(() => ({
      type: B.value ? a.buttonType : void 0,
      "aria-label": a.ariaLabel || null,
      disabled: h2.value || null
    })), V = computed(() => [`bg-${a.badgeVariant}`]), T = computed(() => a.badge === true ? "" : a.badge), S = computed(() => [[`text-${te(a.badgeVariant)}`]]), O = computed(() => ({
      [`b-avatar-${a.size}`]: !!a.size && n.indexOf(Sa(a.size)) !== -1,
      [`bg-${$.value}`]: !!$.value,
      badge: !B.value && $.value && w.value,
      rounded: b.value === "" || b.value === true,
      ["rounded-circle"]: !v.value && b.value === "circle",
      ["rounded-0"]: v.value || b.value === "0",
      ["rounded-1"]: !v.value && b.value === "sm",
      ["rounded-3"]: !v.value && b.value === "lg",
      ["rounded-top"]: !v.value && b.value === "top",
      ["rounded-bottom"]: !v.value && b.value === "bottom",
      ["rounded-start"]: !v.value && b.value === "left",
      ["rounded-end"]: !v.value && b.value === "right",
      btn: B.value,
      [`btn-${$.value}`]: B.value ? !!$.value : false
    })), I = computed(() => [
      [`text-${a.textVariant || te($.value)}`]
    ]), C = computed(() => {
      const ae = a.badgeOffset || "0px";
      return {
        fontSize: (n.indexOf(y.value || null) === -1 ? `calc(${y.value} * ${s})` : "") || "",
        top: m.value ? ae : "",
        bottom: m.value ? "" : ae,
        left: f.value ? ae : "",
        right: f.value ? "" : ae
      };
    }), F = computed(() => {
      const ae = n.indexOf(y.value || null) === -1 ? `calc(${y.value} * ${r})` : null;
      return ae ? { fontSize: ae } : {};
    }), P = computed(() => {
      var pe;
      const ae = ((pe = o == null ? void 0 : o.overlapScale) == null ? void 0 : pe.value) || 0, me = y.value && ae ? `calc(${y.value} * -${ae})` : null;
      return me ? { marginLeft: me, marginRight: me } : {};
    }), W = computed(() => B.value ? "button" : "span"), j = computed(() => ({
      ...P.value,
      width: y.value ?? void 0,
      height: y.value ?? void 0
    })), te = (ae) => ae === "light" || ae === "warning" ? "dark" : "light", X = (ae) => {
      !h2.value && B.value && t("click", ae);
    }, q = (ae) => t("img-error", ae);
    return (ae, me) => (openBlock(), createBlock(resolveDynamicComponent(unref(W)), mergeProps({
      class: ["b-avatar", unref(O)],
      style: unref(j)
    }, unref(_), { onClick: X }), {
      default: withCtx(() => [
        unref(w) ? (openBlock(), createElementBlock("span", yr, [
          renderSlot(ae.$slots, "default")
        ])) : e.src ? (openBlock(), createElementBlock("span", Br, [
          createBaseVNode("img", {
            src: e.src,
            alt: e.alt,
            onError: q
          }, null, 40, $r)
        ])) : e.text ? (openBlock(), createElementBlock("span", {
          key: 2,
          class: normalizeClass(["b-avatar-text", unref(I)]),
          style: normalizeStyle(unref(F))
        }, toDisplayString(e.text), 7)) : createCommentVNode("", true),
        unref(k) ? (openBlock(), createElementBlock("span", {
          key: 3,
          class: normalizeClass(["b-avatar-badge", unref(V)]),
          style: normalizeStyle(unref(C))
        }, [
          unref(g) ? renderSlot(ae.$slots, "badge", { key: 0 }) : (openBlock(), createElementBlock("span", {
            key: 1,
            class: normalizeClass(unref(S))
          }, toDisplayString(unref(T)), 3))
        ], 6)) : createCommentVNode("", true)
      ]),
      _: 3
    }, 16, ["class", "style"]));
  }
});
var kr = defineComponent({
  __name: "BAvatarGroup",
  props: {
    overlap: { default: 0.3 },
    rounded: { type: [Boolean, String], default: false },
    size: { default: void 0 },
    square: { default: false },
    tag: { default: "div" },
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = c(toRef(t, "square")), l = computed(() => Sa(t.size)), o = computed(
      () => Math.min(Math.max(r(t.overlap), 0), 1) / 2
    ), n = computed(() => {
      const s = l.value ? `calc(${l.value} * ${o.value})` : null;
      return s ? { paddingLeft: s, paddingRight: s } : {};
    }), r = (s) => typeof s == "string" && ro(s) ? At(s, 0) : s || 0;
    return provide(Co, {
      overlapScale: o,
      size: readonly(toRef(t, "size")),
      square: a,
      rounded: readonly(toRef(t, "rounded")),
      variant: readonly(toRef(t, "variant"))
    }), (s, f) => (openBlock(), createBlock(resolveDynamicComponent(e.tag), {
      class: "b-avatar-group",
      role: "group"
    }, {
      default: withCtx(() => [
        createBaseVNode("div", {
          class: "b-avatar-group-inner",
          style: normalizeStyle(unref(n))
        }, [
          renderSlot(s.$slots, "default")
        ], 4)
      ]),
      _: 3
    }));
  }
});
var Vl = Lt(mt, ["event", "routerTag"]);
var Cr = defineComponent({
  components: { BLink: Ne },
  props: {
    pill: { type: [Boolean, String], default: false },
    tag: { type: String, default: "span" },
    variant: { type: String, default: "secondary" },
    textIndicator: { type: [Boolean, String], default: false },
    dotIndicator: { type: [Boolean, String], default: false },
    ...Vl
  },
  setup(e) {
    const t = c(toRef(e, "pill")), a = c(toRef(e, "textIndicator")), l = c(toRef(e, "dotIndicator")), o = c(toRef(e, "active")), n = c(toRef(e, "disabled")), r = computed(() => Et(e)), s = computed(
      () => r.value ? Ne : e.tag
    ), f = computed(() => [
      [`bg-${e.variant}`],
      {
        active: o.value,
        disabled: n.value,
        "text-dark": ["warning", "info", "light"].includes(e.variant),
        "rounded-pill": t.value,
        "position-absolute top-0 start-100 translate-middle": a.value || l.value,
        "p-2 border border-light rounded-circle": l.value,
        "text-decoration-none": r.value
      }
    ]), m = computed(
      () => r.value ? Ha(e, Vl) : {}
    );
    return {
      computedClasses: f,
      computedLinkProps: m,
      computedTag: s
    };
  }
});
function Sr(e, t, a, l, o, n) {
  return openBlock(), createBlock(resolveDynamicComponent(e.computedTag), mergeProps({
    class: ["badge", e.computedClasses]
  }, e.computedLinkProps), {
    default: withCtx(() => [
      renderSlot(e.$slots, "default")
    ]),
    _: 3
  }, 16, ["class"]);
}
var _r = ze(Cr, [["render", Sr]]);
var Ol = Lt(mt, ["event", "routerTag"]);
var Tr = defineComponent({
  components: { BLink: Ne },
  props: {
    ...Ol,
    active: { type: [Boolean, String], default: false },
    ariaCurrent: { type: String, default: "location" },
    disabled: { type: [Boolean, String], default: false },
    text: { type: String, default: void 0 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = c(toRef(e, "active")), l = c(toRef(e, "disabled")), o = computed(() => ({
      active: a.value
    })), n = computed(
      () => a.value ? "span" : Ne
    ), r = computed(
      () => a.value ? e.ariaCurrent : void 0
    );
    return {
      computedLinkProps: computed(
        () => n.value !== "span" ? Ha(e, Ol) : {}
      ),
      computedClasses: o,
      computedTag: n,
      computedAriaCurrent: r,
      clicked: (m) => {
        if (l.value || a.value) {
          m.preventDefault(), m.stopImmediatePropagation();
          return;
        }
        l.value || t("click", m);
      }
    };
  }
});
function xr(e, t, a, l, o, n) {
  return openBlock(), createElementBlock("li", {
    class: normalizeClass(["breadcrumb-item", e.computedClasses])
  }, [
    (openBlock(), createBlock(resolveDynamicComponent(e.computedTag), mergeProps({ "aria-current": e.computedAriaCurrent }, e.computedLinkProps, { onClick: e.clicked }), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(e.text), 1)
        ])
      ]),
      _: 3
    }, 16, ["aria-current", "onClick"]))
  ], 2);
}
var cn = ze(Tr, [["render", xr]]);
var Ar = { "aria-label": "breadcrumb" };
var Vr = { class: "breadcrumb" };
var Or = defineComponent({
  __name: "BBreadcrumb",
  props: {
    items: { default: void 0 }
  },
  setup(e) {
    const t = e, a = Qo(), l = computed(() => {
      const o = t.items || (a == null ? void 0 : a.items) || [];
      let n = false;
      return o.map((s, f) => (typeof s == "string" && (s = { text: s }, f < o.length - 1 && (s.href = "#")), s.active && (n = true), !s.active && !n && (s.active = f + 1 === o.length), s));
    });
    return (o, n) => (openBlock(), createElementBlock("nav", Ar, [
      createBaseVNode("ol", Vr, [
        renderSlot(o.$slots, "prepend"),
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(l), (r, s) => (openBlock(), createBlock(cn, mergeProps({ key: s }, r), {
          default: withCtx(() => [
            createTextVNode(toDisplayString(r.text), 1)
          ]),
          _: 2
        }, 1040))), 128)),
        renderSlot(o.$slots, "default"),
        renderSlot(o.$slots, "append")
      ])
    ]));
  }
});
var Pr = defineComponent({
  __name: "BButtonGroup",
  props: {
    ariaLabel: { default: "Group" },
    size: { default: void 0 },
    tag: { default: "div" },
    vertical: { default: false }
  },
  setup(e) {
    const t = e, a = c(toRef(t, "vertical")), l = computed(() => ({
      "btn-group": !a.value,
      [`btn-group-${t.size}`]: t.size !== void 0,
      "btn-group-vertical": a.value
    }));
    return (o, n) => (openBlock(), createBlock(resolveDynamicComponent(e.tag), {
      class: normalizeClass(unref(l)),
      role: "group",
      "aria-label": e.ariaLabel
    }, {
      default: withCtx(() => [
        renderSlot(o.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "aria-label"]));
  }
});
var Er = ["role", "aria-label"];
var Ir = defineComponent({
  __name: "BButtonToolbar",
  props: {
    ariaLabel: { default: "Group" },
    justify: { default: false },
    role: { default: "toolbar" }
  },
  setup(e) {
    const a = c(toRef(e, "justify")), l = computed(() => ({
      "justify-content-between": a.value
    }));
    return (o, n) => (openBlock(), createElementBlock("div", {
      class: normalizeClass([unref(l), "btn-toolbar"]),
      role: e.role,
      "aria-label": e.ariaLabel
    }, [
      renderSlot(o.$slots, "default")
    ], 10, Er));
  }
});
var Ka = defineComponent({
  __name: "BImg",
  props: {
    alt: { default: void 0 },
    blank: { default: false },
    blankColor: { default: "transparent" },
    block: { default: false },
    center: { default: false },
    fluid: { default: false },
    lazy: { default: false },
    fluidGrow: { default: false },
    height: { default: void 0 },
    start: { default: false },
    end: { default: false },
    rounded: { type: [Boolean, String], default: false },
    sizes: { default: void 0 },
    src: { default: void 0 },
    srcset: { default: void 0 },
    thumbnail: { default: false },
    width: { default: void 0 }
  },
  emits: ["load"],
  setup(e, { emit: t }) {
    const a = e, l = '<svg width="%{w}" height="%{h}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 %{w} %{h}" preserveAspectRatio="none"><rect width="100%" height="100%" style="fill:%{f};"></rect></svg>', o = c(toRef(a, "lazy")), n = c(toRef(a, "blank")), r = c(toRef(a, "block")), s = c(toRef(a, "center")), f = c(toRef(a, "fluid")), m = c(toRef(a, "fluidGrow")), B = c(toRef(a, "start")), h2 = c(toRef(a, "end")), v = c(toRef(a, "thumbnail")), w = computed(
      () => typeof a.srcset == "string" ? a.srcset.split(",").filter((T) => T).join(",") : Array.isArray(a.srcset) ? a.srcset.filter((T) => T).join(",") : void 0
    ), g = computed(
      () => typeof a.sizes == "string" ? a.sizes.split(",").filter((T) => T).join(",") : Array.isArray(a.sizes) ? a.sizes.filter((T) => T).join(",") : void 0
    ), k = computed(() => {
      const T = (I) => I === void 0 ? void 0 : typeof I == "number" ? I : Number.parseInt(I, 10) || void 0, S = T(a.width), O = T(a.height);
      if (n.value) {
        if (S !== void 0 && O === void 0)
          return { height: S, width: S };
        if (S === void 0 && O !== void 0)
          return { height: O, width: O };
        if (S === void 0 && O === void 0)
          return { height: 1, width: 1 };
      }
      return {
        width: S,
        height: O
      };
    }), y = computed(
      () => V(k.value.width, k.value.height, a.blankColor)
    ), $ = computed(() => ({
      src: n.value ? y.value : a.src,
      alt: a.alt,
      width: k.value.width || void 0,
      height: k.value.height || void 0,
      srcset: n.value ? void 0 : w.value,
      sizes: n.value ? void 0 : g.value,
      loading: o.value ? "lazy" : "eager"
    })), b = computed(
      () => B.value ? "float-start" : h2.value ? "float-end" : s.value ? "mx-auto" : void 0
    ), _ = computed(() => ({
      "img-thumbnail": v.value,
      "img-fluid": f.value || m.value,
      "w-100": m.value,
      rounded: a.rounded === "" || a.rounded === true,
      [`rounded-${a.rounded}`]: typeof a.rounded == "string" && a.rounded !== "",
      [`${b.value}`]: b.value !== void 0,
      "d-block": r.value || s.value
    })), V = (T, S, O) => `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(
      l.replace("%{w}", String(T)).replace("%{h}", String(S)).replace("%{f}", O)
    )}`;
    return (T, S) => (openBlock(), createElementBlock("img", mergeProps({ class: unref(_) }, unref($), {
      onLoad: S[0] || (S[0] = (O) => t("load", O))
    }), null, 16));
  }
});
var oa = defineComponent({
  __name: "BCardImg",
  props: {
    alt: { default: void 0 },
    blank: { default: false },
    blankColor: { default: void 0 },
    bottom: { default: false },
    lazy: { default: false },
    height: { default: void 0 },
    start: { default: false },
    end: { default: false },
    sizes: { default: void 0 },
    src: { default: void 0 },
    srcset: { default: void 0 },
    top: { default: false },
    width: { default: void 0 }
  },
  emits: ["load"],
  setup(e, { emit: t }) {
    const a = e, l = c(toRef(a, "bottom")), o = c(toRef(a, "end")), n = c(toRef(a, "start")), r = c(toRef(a, "top")), s = computed(
      () => r.value ? "card-img-top" : o.value ? "card-img-right" : l.value ? "card-img-bottom" : n.value ? "card-img-left" : "card-img"
    ), f = computed(() => ({
      alt: a.alt,
      height: a.height,
      src: a.src,
      lazy: a.lazy,
      width: a.width,
      blank: a.blank,
      blankColor: a.blankColor,
      sizes: a.sizes,
      srcset: a.srcset
    }));
    return (m, B) => (openBlock(), createBlock(Ka, mergeProps({ class: unref(s) }, unref(f), {
      onLoad: B[0] || (B[0] = (h2) => t("load", h2))
    }), null, 16, ["class"]));
  }
});
var Fr = ["innerHTML"];
var fn = defineComponent({
  __name: "BCardHeadFoot",
  props: {
    text: { default: void 0 },
    bgVariant: { default: void 0 },
    borderVariant: { default: void 0 },
    html: { default: void 0 },
    tag: { default: "div" },
    textVariant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = computed(() => ({
      [`text-${t.textVariant}`]: t.textVariant !== void 0,
      [`bg-${t.bgVariant}`]: t.bgVariant !== void 0,
      [`border-${t.borderVariant}`]: t.borderVariant !== void 0
    }));
    return (l, o) => (openBlock(), createBlock(resolveDynamicComponent(e.tag), {
      class: normalizeClass(unref(a))
    }, {
      default: withCtx(() => [
        e.html ? (openBlock(), createElementBlock("div", {
          key: 0,
          innerHTML: e.html
        }, null, 8, Fr)) : renderSlot(l.$slots, "default", { key: 1 }, () => [
          createTextVNode(toDisplayString(e.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
});
var vn = defineComponent({
  __name: "BCardHeader",
  props: {
    text: { default: void 0 },
    bgVariant: { default: void 0 },
    borderVariant: { default: void 0 },
    html: { default: void 0 },
    tag: { default: "div" },
    textVariant: { default: void 0 }
  },
  setup(e) {
    const t = e;
    return (a, l) => (openBlock(), createBlock(fn, mergeProps({ class: "card-header" }, t), {
      default: withCtx(() => [
        renderSlot(a.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var mn = defineComponent({
  __name: "BCardTitle",
  props: {
    text: { default: void 0 },
    tag: { default: "h4" }
  },
  setup(e) {
    return (t, a) => (openBlock(), createBlock(resolveDynamicComponent(e.tag), { class: "card-title" }, {
      default: withCtx(() => [
        renderSlot(t.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(e.text), 1)
        ])
      ]),
      _: 3
    }));
  }
});
var pn = defineComponent({
  __name: "BCardSubtitle",
  props: {
    text: { default: void 0 },
    tag: { default: "h6" },
    textVariant: { default: "muted" }
  },
  setup(e) {
    const t = e, a = computed(() => [`text-${t.textVariant}`]);
    return (l, o) => (openBlock(), createBlock(resolveDynamicComponent(e.tag), {
      class: normalizeClass(["card-subtitle mb-2", unref(a)])
    }, {
      default: withCtx(() => [
        renderSlot(l.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(e.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
});
var gn = defineComponent({
  __name: "BCardBody",
  props: {
    bodyBgVariant: { default: void 0 },
    bodyTag: { default: "div" },
    bodyTextVariant: { default: void 0 },
    overlay: { default: false },
    subtitle: { default: void 0 },
    subtitleTag: { default: "h4" },
    subtitleTextVariant: { default: void 0 },
    title: { default: void 0 },
    titleTag: { default: "h4" },
    text: { default: void 0 }
  },
  setup(e) {
    const t = e, a = useSlots(), l = c(toRef(t, "overlay")), o = computed(() => !Ve(a.title)), n = computed(() => !Ve(a.subtitle)), r = computed(() => ({
      "card-img-overlay": l.value,
      [`text-${t.bodyTextVariant}`]: t.bodyTextVariant !== void 0,
      [`bg-${t.bodyBgVariant}`]: t.bodyBgVariant !== void 0
    }));
    return (s, f) => (openBlock(), createBlock(resolveDynamicComponent(e.bodyTag), {
      class: normalizeClass(["card-body", unref(r)])
    }, {
      default: withCtx(() => [
        e.title || unref(o) ? (openBlock(), createBlock(mn, {
          key: 0,
          tag: e.titleTag
        }, {
          default: withCtx(() => [
            renderSlot(s.$slots, "title", {}, () => [
              createTextVNode(toDisplayString(e.title), 1)
            ])
          ]),
          _: 3
        }, 8, ["tag"])) : createCommentVNode("", true),
        e.subtitle || unref(n) ? (openBlock(), createBlock(pn, {
          key: 1,
          tag: e.subtitleTag,
          "text-variant": e.subtitleTextVariant
        }, {
          default: withCtx(() => [
            renderSlot(s.$slots, "subtitle", {}, () => [
              createTextVNode(toDisplayString(e.subtitle), 1)
            ])
          ]),
          _: 3
        }, 8, ["tag", "text-variant"])) : createCommentVNode("", true),
        renderSlot(s.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(e.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
});
var bn = defineComponent({
  __name: "BCardFooter",
  props: {
    text: { default: void 0 },
    bgVariant: { default: void 0 },
    borderVariant: { default: void 0 },
    html: { default: void 0 },
    tag: { default: "div" },
    textVariant: { default: void 0 }
  },
  setup(e) {
    const t = e;
    return (a, l) => (openBlock(), createBlock(fn, mergeProps({ class: "card-footer" }, t), {
      default: withCtx(() => [
        renderSlot(a.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(e.text), 1)
        ])
      ]),
      _: 3
    }, 16));
  }
});
var hn = defineComponent({
  __name: "BCard",
  props: {
    align: { default: void 0 },
    bgVariant: { default: void 0 },
    bodyBgVariant: { default: void 0 },
    bodyClass: { default: void 0 },
    bodyTag: { default: "div" },
    bodyTextVariant: { default: void 0 },
    borderVariant: { default: void 0 },
    footer: { default: void 0 },
    footerBgVariant: { default: void 0 },
    footerBorderVariant: { default: void 0 },
    footerClass: { default: void 0 },
    footerHtml: { default: "" },
    footerTag: { default: "div" },
    footerTextVariant: { default: void 0 },
    header: { default: void 0 },
    headerBgVariant: { default: void 0 },
    headerBorderVariant: { default: void 0 },
    headerClass: { default: void 0 },
    headerHtml: { default: "" },
    headerTag: { default: "div" },
    headerTextVariant: { default: void 0 },
    imgAlt: { default: void 0 },
    imgBottom: { default: false },
    imgEnd: { default: false },
    imgHeight: { default: void 0 },
    imgSrc: { default: void 0 },
    imgStart: { default: false },
    imgTop: { default: false },
    imgWidth: { default: void 0 },
    noBody: { default: false },
    overlay: { default: false },
    subtitle: { default: void 0 },
    subtitleTag: { default: "h6" },
    subtitleTextVariant: { default: "muted" },
    tag: { default: "div" },
    textVariant: { default: void 0 },
    title: { default: void 0 },
    titleTag: { default: "h4" },
    bodyText: { default: "" }
  },
  setup(e) {
    const t = e, a = useSlots(), l = c(toRef(t, "imgBottom")), o = c(toRef(t, "imgEnd")), n = c(toRef(t, "imgStart")), r = c(toRef(t, "noBody")), s = computed(() => !Ve(a.header)), f = computed(() => !Ve(a.footer)), m = computed(() => ({
      [`text-${t.align}`]: t.align !== void 0,
      [`text-${t.textVariant}`]: t.textVariant !== void 0,
      [`bg-${t.bgVariant}`]: t.bgVariant !== void 0,
      [`border-${t.borderVariant}`]: t.borderVariant !== void 0,
      "flex-row": n.value,
      "flex-row-reverse": o.value
    })), B = computed(() => ({
      bgVariant: t.headerBgVariant,
      borderVariant: t.headerBorderVariant,
      html: t.headerHtml,
      tag: t.headerTag,
      textVariant: t.headerTextVariant
    })), h2 = computed(() => ({
      overlay: t.overlay,
      bodyBgVariant: t.bodyBgVariant,
      bodyTag: t.bodyTag,
      bodyTextVariant: t.bodyTextVariant,
      subtitle: t.subtitle,
      subtitleTag: t.subtitleTag,
      subtitleTextVariant: t.subtitleTextVariant,
      title: t.title,
      titleTag: t.titleTag
    })), v = computed(() => ({
      bgVariant: t.footerBgVariant,
      borderVariant: t.footerBorderVariant,
      html: t.footerHtml,
      tag: t.footerTag,
      textVariant: t.footerTextVariant
    })), w = computed(() => ({
      src: t.imgSrc,
      alt: t.imgAlt,
      height: t.imgHeight,
      width: t.imgWidth,
      bottom: t.imgBottom,
      end: t.imgEnd,
      start: t.imgStart,
      top: t.imgTop
    }));
    return (g, k) => (openBlock(), createBlock(resolveDynamicComponent(e.tag), {
      class: normalizeClass(["card", unref(m)])
    }, {
      default: withCtx(() => [
        unref(l) ? createCommentVNode("", true) : renderSlot(g.$slots, "img", { key: 0 }, () => [
          e.imgSrc ? (openBlock(), createBlock(oa, normalizeProps(mergeProps({ key: 0 }, unref(w))), null, 16)) : createCommentVNode("", true)
        ]),
        e.header || unref(s) || e.headerHtml ? (openBlock(), createBlock(vn, mergeProps({ key: 1 }, unref(B), { class: e.headerClass }), {
          default: withCtx(() => [
            renderSlot(g.$slots, "header", {}, () => [
              createTextVNode(toDisplayString(e.header), 1)
            ])
          ]),
          _: 3
        }, 16, ["class"])) : createCommentVNode("", true),
        unref(r) ? renderSlot(g.$slots, "default", { key: 3 }, () => [
          createTextVNode(toDisplayString(e.bodyText), 1)
        ]) : (openBlock(), createBlock(gn, mergeProps({ key: 2 }, unref(h2), { class: e.bodyClass }), {
          default: withCtx(() => [
            renderSlot(g.$slots, "default", {}, () => [
              createTextVNode(toDisplayString(e.bodyText), 1)
            ])
          ]),
          _: 3
        }, 16, ["class"])),
        e.footer || unref(f) || e.footerHtml ? (openBlock(), createBlock(bn, mergeProps({ key: 4 }, unref(v), { class: e.footerClass }), {
          default: withCtx(() => [
            renderSlot(g.$slots, "footer", {}, () => [
              createTextVNode(toDisplayString(e.footer), 1)
            ])
          ]),
          _: 3
        }, 16, ["class"])) : createCommentVNode("", true),
        unref(l) ? renderSlot(g.$slots, "img", { key: 5 }, () => [
          e.imgSrc ? (openBlock(), createBlock(oa, normalizeProps(mergeProps({ key: 0 }, unref(w))), null, 16)) : createCommentVNode("", true)
        ]) : createCommentVNode("", true)
      ]),
      _: 3
    }, 8, ["class"]));
  }
});
var Lr = defineComponent({
  __name: "BCardGroup",
  props: {
    columns: { default: false },
    deck: { default: false },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, a = c(toRef(t, "columns")), l = c(toRef(t, "deck")), o = computed(
      () => l.value ? "card-deck" : a.value ? "card-columns" : "card-group"
    ), n = computed(() => [o.value]);
    return (r, s) => (openBlock(), createBlock(resolveDynamicComponent(e.tag), {
      class: normalizeClass(unref(n))
    }, {
      default: withCtx(() => [
        renderSlot(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
});
var Nr = defineComponent({
  __name: "BCardText",
  props: {
    text: { default: void 0 },
    tag: { default: "p" }
  },
  setup(e) {
    return (t, a) => (openBlock(), createBlock(resolveDynamicComponent(e.tag), { class: "card-text" }, {
      default: withCtx(() => [
        renderSlot(t.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(e.text), 1)
        ])
      ]),
      _: 3
    }));
  }
});
var zr = ["id", "onMouseenter", "onMouseleave"];
var Rr = {
  key: 0,
  class: "carousel-indicators"
};
var Hr = ["aria-current", "aria-label", "onClick"];
var Mr = { class: "carousel-inner" };
var Dr = createBaseVNode("span", {
  class: "carousel-control-prev-icon",
  "aria-hidden": "true"
}, null, -1);
var jr = { class: "visually-hidden" };
var qr = createBaseVNode("span", {
  class: "carousel-control-next-icon",
  "aria-hidden": "true"
}, null, -1);
var Gr = { class: "visually-hidden" };
var Wr = defineComponent({
  __name: "BCarousel",
  props: {
    ride: { type: [Boolean, String], default: false },
    noHoverPause: { default: false },
    rideReverse: { default: false },
    fade: { default: false },
    id: { default: void 0 },
    imgHeight: { default: void 0 },
    imgWidth: { default: void 0 },
    background: { default: void 0 },
    modelValue: { default: 0 },
    controls: { default: false },
    indicators: { default: false },
    interval: { default: 5e3 },
    noTouch: { default: false },
    noWrap: { default: false },
    controlsPrevText: { default: "Previous" },
    controlsNextText: { default: "Next" },
    indicatorsButtonLabel: { default: "Slide" },
    keyboard: { default: true },
    touchThreshold: { default: 50 }
  },
  emits: ["slid", "slide", "update:modelValue"],
  setup(e, { expose: t, emit: a }) {
    const l = e, o = useSlots(), n = Ce(toRef(l, "id"), "carousel"), r = Te(l, "modelValue", a, { passive: true }), s = c(toRef(l, "keyboard")), f = c(toRef(l, "rideReverse")), m = c(toRef(l, "noHoverPause")), B = c(toRef(l, "fade")), h2 = c(toRef(l, "controls")), v = c(toRef(l, "indicators")), w = c(toRef(l, "noTouch")), g = c(toRef(l, "noWrap")), k = Bt(toRef(l, "touchThreshold"), {
      nanToZero: true,
      method: "parseInt"
    }), y = ref(false), $ = ref(false), b = ref(true), _ = ref(null), V = ref(null), T = computed(
      () => Zn(l.ride) ? so(l.ride) : l.ride
    ), { pause: S, resume: O } = qo(
      () => {
        f.value ? j() : te();
      },
      toRef(l, "interval"),
      { immediate: T.value === "carousel" }
    ), I = computed(
      () => T.value === true && $.value === true || T.value === "carousel"
    ), C = computed(() => ha(o.default, "BCarouselSlide")), F = computed(() => [
      "carousel",
      "slide",
      "pointer-event",
      { "carousel-fade": B.value }
    ]), P = (ne, ve) => {
      var L;
      return new io(ne, {
        componentId: n.value,
        cancelable: false,
        target: V.value,
        direction: b.value ? "right" : "left",
        from: ve,
        to: r.value,
        relatedTarget: ((L = _.value) == null ? void 0 : L.children[r.value]) ?? null
      });
    }, W = (ne) => {
      if (y.value !== true) {
        if (T.value === true && ($.value = true), I.value === true && O(), b.value = !(ne < r.value), ne >= C.value.length) {
          if (g.value)
            return;
          r.value = 0;
          return;
        }
        if (ne < 0) {
          if (g.value)
            return;
          r.value = C.value.length - 1;
          return;
        }
        r.value = ne;
      }
    }, j = () => W(r.value - 1), te = () => W(r.value + 1), X = (ne) => {
      s.value !== false && ne();
    }, q = () => {
      m.value || S();
    }, ae = () => {
      I.value && O();
    }, { lengthX: me } = Ri(V, {
      passive: true,
      onSwipeStart() {
        w.value !== true && S();
      },
      onSwipeEnd() {
        if (w.value === true)
          return;
        const ne = () => {
          I.value !== false && O();
        };
        if (me.value >= k.value) {
          te(), ne();
          return;
        }
        me.value <= -k.value && (j(), ne());
      }
    }), pe = (ne) => {
      a("slide", P("slide", ne)), y.value = true;
    }, be = (ne) => {
      a("slid", P("slid", ne)), y.value = false;
    };
    return watch(
      () => l.ride,
      () => $.value = false
    ), t({ pause: S, resume: O, prev: j, next: te }), provide(yo, {
      background: readonly(toRef(l, "background")),
      width: readonly(toRef(l, "imgWidth")),
      height: readonly(toRef(l, "imgHeight"))
    }), (ne, ve) => (openBlock(), createElementBlock("div", {
      id: unref(n),
      ref_key: "target",
      ref: V,
      class: normalizeClass(unref(F)),
      onKeydown: [
        ve[0] || (ve[0] = withKeys((L) => X(j), ["left"])),
        ve[1] || (ve[1] = withKeys((L) => X(te), ["right"]))
      ],
      onMouseenter: withModifiers(q, ["stop"]),
      onMouseleave: withModifiers(ae, ["stop"])
    }, [
      unref(v) ? (openBlock(), createElementBlock("div", Rr, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(C).length, (L, z) => (openBlock(), createElementBlock("button", {
          key: z,
          type: "button",
          "data-bs-target": "",
          class: normalizeClass(z === unref(r) ? "active" : ""),
          "aria-current": z === unref(r) ? true : void 0,
          "aria-label": `${e.indicatorsButtonLabel} ${z}`,
          onClick: (ee) => W(z)
        }, null, 10, Hr))), 128))
      ])) : createCommentVNode("", true),
      createBaseVNode("div", {
        ref_key: "relatedTarget",
        ref: _,
        class: "carousel-inner"
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(C), (L, z) => (openBlock(), createBlock(Transition, {
          key: z,
          "enter-from-class": `carousel-item-next carousel-item-${b.value ? "end" : "start"}`,
          "leave-active-class": "active",
          "leave-to-class": `carousel-item-prev carousel-item-${b.value ? "start" : "end"}`,
          onBeforeLeave: pe,
          onAfterLeave: be
        }, {
          default: withCtx(() => [
            withDirectives((openBlock(), createBlock(resolveDynamicComponent(L), {
              class: normalizeClass({ active: z === unref(r) })
            }, null, 8, ["class"])), [
              [vShow, z === unref(r)]
            ])
          ]),
          _: 2
        }, 1032, ["enter-from-class", "leave-to-class"]))), 128))
      ], 512),
      createBaseVNode("div", Mr, [
        renderSlot(ne.$slots, "default")
      ]),
      unref(h2) ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        createBaseVNode("button", {
          class: "carousel-control-prev",
          type: "button",
          onClick: j
        }, [
          Dr,
          createBaseVNode("span", jr, toDisplayString(e.controlsPrevText), 1)
        ]),
        createBaseVNode("button", {
          class: "carousel-control-next",
          type: "button",
          onClick: te
        }, [
          qr,
          createBaseVNode("span", Gr, toDisplayString(e.controlsNextText), 1)
        ])
      ], 64)) : createCommentVNode("", true)
    ], 42, zr));
  }
});
var Ur = ["innerHTML"];
var Kr = { key: 1 };
var Xr = ["innerHTML"];
var Jr = { key: 1 };
var Yr = defineComponent({
  __name: "BCarouselSlide",
  props: {
    imgSrc: { default: void 0 },
    imgHeight: { default: void 0 },
    imgWidth: { default: void 0 },
    interval: { default: void 0 },
    background: { default: void 0 },
    caption: { default: void 0 },
    captionHtml: { default: void 0 },
    captionTag: { default: "h3" },
    contentTag: { default: "div" },
    contentVisibleUp: { default: void 0 },
    id: { default: void 0 },
    imgAlt: { default: void 0 },
    imgBlank: { default: false },
    imgBlankColor: { default: "transparent" },
    text: { default: void 0 },
    textHtml: { default: void 0 },
    textTag: { default: "p" }
  },
  setup(e) {
    const t = e, a = useSlots(), l = inject(yo, null), o = computed(() => t.text || t.textHtml || !Ve(a.text)), n = computed(() => t.caption || t.captionHtml || !Ve(a.caption)), r = computed(() => o.value || n.value || !Ve(a.default)), s = computed(() => ({
      background: `${t.background || (l == null ? void 0 : l.background.value) || "rgb(171, 171, 171)"} none repeat scroll 0% 0%`
    })), f = computed(() => ({
      "d-none": t.contentVisibleUp !== void 0,
      [`d-${t.contentVisibleUp}-block`]: t.contentVisibleUp !== void 0
    }));
    return (m, B) => (openBlock(), createElementBlock("div", {
      class: "carousel-item",
      style: normalizeStyle(unref(s))
    }, [
      renderSlot(m.$slots, "img", {}, () => {
        var h2, v;
        return [
          createVNode(Ka, {
            class: "d-block w-100",
            alt: e.imgAlt,
            src: e.imgSrc,
            width: e.imgWidth || ((h2 = unref(l)) == null ? void 0 : h2.width.value),
            height: e.imgHeight || ((v = unref(l)) == null ? void 0 : v.height.value),
            blank: e.imgBlank,
            "blank-color": e.imgBlankColor
          }, null, 8, ["alt", "src", "width", "height", "blank", "blank-color"])
        ];
      }),
      unref(r) ? (openBlock(), createBlock(resolveDynamicComponent(e.contentTag), {
        key: 0,
        class: normalizeClass(["carousel-caption", unref(f)])
      }, {
        default: withCtx(() => [
          unref(n) ? (openBlock(), createBlock(resolveDynamicComponent(e.captionTag), { key: 0 }, {
            default: withCtx(() => [
              renderSlot(m.$slots, "caption", {}, () => [
                e.captionHtml ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  innerHTML: e.captionHtml
                }, null, 8, Ur)) : (openBlock(), createElementBlock("span", Kr, toDisplayString(e.caption), 1))
              ])
            ]),
            _: 3
          })) : createCommentVNode("", true),
          unref(o) ? (openBlock(), createBlock(resolveDynamicComponent(e.textTag), { key: 1 }, {
            default: withCtx(() => [
              renderSlot(m.$slots, "text", {}, () => [
                e.textHtml ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  innerHTML: e.textHtml
                }, null, 8, Xr)) : (openBlock(), createElementBlock("span", Jr, toDisplayString(e.text), 1))
              ])
            ]),
            _: 3
          })) : createCommentVNode("", true),
          renderSlot(m.$slots, "default")
        ]),
        _: 3
      }, 8, ["class"])) : createCommentVNode("", true)
    ], 4));
  }
});
var Pl = ra("", [], { type: [Boolean, String, Number], default: false });
var El = ra("offset", [""], { type: [String, Number], default: null });
var Il = ra("order", [""], { type: [String, Number], default: null });
var Zr = defineComponent({
  name: "BCol",
  props: {
    col: { type: [Boolean, String], default: false },
    // Generic flexbox .col (xs)
    cols: { type: [String, Number], default: null },
    // .col-[1-12]|auto (xs)
    ...Pl,
    offset: { type: [String, Number], default: null },
    ...El,
    order: { type: [String, Number], default: null },
    ...Il,
    alignSelf: { type: String, default: null },
    tag: { type: String, default: "div" }
  },
  setup(e) {
    const t = [
      { content: Pl, propPrefix: "cols", classPrefix: "col" },
      { content: El, propPrefix: "offset" },
      { content: Il, propPrefix: "order" }
    ], a = c(toRef(e, "col")), l = computed(
      () => t.flatMap((n) => ho(e, n.content, n.propPrefix, n.classPrefix))
    );
    return {
      computedClasses: computed(() => [
        l.value,
        {
          col: a.value || !l.value.some((n) => /^col-/.test(n)) && !e.cols,
          [`col-${e.cols}`]: !!e.cols,
          [`offset-${e.offset}`]: !!e.offset,
          [`order-${e.order}`]: !!e.order,
          [`align-self-${e.alignSelf}`]: !!e.alignSelf
        }
      ])
    };
  }
});
function Qr(e, t, a, l, o, n) {
  return openBlock(), createBlock(resolveDynamicComponent(e.tag), {
    class: normalizeClass(e.computedClasses)
  }, {
    default: withCtx(() => [
      renderSlot(e.$slots, "default")
    ]),
    _: 3
  }, 8, ["class"]);
}
var xt = ze(Zr, [["render", Qr]]);
var gt = {
  autoHide: true,
  delay: 5e3,
  noCloseButton: false,
  pos: "top-right",
  value: true
};
var Fl = class {
  constructor(t) {
    xe(this, "vm");
    xe(this, "containerPositions");
    isReactive(t) ? this.vm = t : this.vm = reactive(t), this.containerPositions = computed(() => {
      const a = /* @__PURE__ */ new Set([]);
      return this.vm.toasts.map((l) => {
        l.options.pos && a.add(l.options.pos);
      }), a;
    });
  }
  toasts(t) {
    return t ? computed(
      () => this.vm.toasts.filter((a) => {
        if (a.options.pos === t && a.options.value)
          return a;
      })
    ) : computed(() => this.vm.toasts);
  }
  remove(...t) {
    this.vm.toasts = this.vm.toasts.filter((a) => {
      if (a.options.id && !t.includes(a.options.id))
        return a;
    });
  }
  isRoot() {
    return this.vm.root ?? false;
  }
  show(t, a = gt) {
    const l = { id: at(), ...gt, ...a }, o = {
      options: reactive(l),
      content: t
    };
    return this.vm.toasts.push(o), o;
  }
  info(t, a = gt) {
    return this.show(t, { variant: "info", ...a });
  }
  danger(t, a = gt) {
    return this.show(t, { variant: "danger", ...a });
  }
  warning(t, a = gt) {
    return this.show(t, { variant: "warning", ...a });
  }
  success(t, a = gt) {
    return this.show(t, { variant: "success", ...a });
  }
  hide() {
  }
};
var eu = class {
  constructor() {
    xe(this, "vms");
    xe(this, "rootInstance");
    xe(this, "useToast", Bn);
    this.vms = {};
  }
  getOrCreateViewModel(t) {
    if (!t) {
      if (this.rootInstance)
        return this.vms[this.rootInstance];
      const a = { root: true, toasts: [], container: void 0, id: Symbol("toast") };
      return this.rootInstance = a.id, this.vms[a.id] = a, a;
    }
    if (t.root) {
      if (this.rootInstance)
        return this.vms[this.rootInstance];
      this.rootInstance = t.id;
    }
    return this.vms[t.id] = t, t;
  }
  getVM(t) {
    if (!t && this.rootInstance)
      return this.vms[this.rootInstance];
    if (t)
      return this.vms[t];
  }
};
var _a = Symbol("toast");
var yn = Symbol("toastFetch");
var tu = {
  container: void 0,
  toasts: [],
  root: false
};
function au() {
  return inject(yn);
}
function Bn(e, t = _a) {
  const a = inject(au());
  if (!e)
    return new Fl(a.getOrCreateViewModel());
  const l = { id: Symbol("toastInstance") }, o = { ...tu, ...l, ...e }, n = a.getOrCreateViewModel(o);
  return new Fl(n);
}
var lu = {
  install: (e, t = {}) => {
    var a, l;
    e.provide(yn, ((a = t == null ? void 0 : t.BToast) == null ? void 0 : a.injectkey) ?? _a), e.provide(((l = t == null ? void 0 : t.BToast) == null ? void 0 : l.injectkey) ?? _a, new eu());
  }
};
var ou = "toast-title";
var Ll = 1e3;
var $n = defineComponent({
  components: { BLink: Ne },
  props: {
    ...mt,
    delay: { type: Number, default: 5e3 },
    bodyClass: { type: String, default: void 0 },
    body: { type: [Object, String], default: void 0 },
    headerClass: { type: String, default: void 0 },
    headerTag: { type: String, default: "div" },
    animation: { type: [Boolean, String], default: true },
    id: { type: String, default: void 0 },
    // Switches role to 'status' and aria-live to 'polite'
    isStatus: { type: [Boolean, String], default: false },
    autoHide: { type: [Boolean, String], default: true },
    noCloseButton: { type: [Boolean, String], default: false },
    noFade: { type: [Boolean, String], default: false },
    noHoverPause: { type: [Boolean, String], default: false },
    solid: { type: [Boolean, String], default: false },
    // Render the toast in place, rather than in a portal-target
    static: { type: [Boolean, String], default: false },
    title: { type: String, default: void 0 },
    modelValue: { type: [Boolean, String], default: false },
    toastClass: { type: Array, default: void 0 },
    variant: { type: String, default: void 0 }
  },
  emits: ["destroyed", "update:modelValue"],
  setup(e, { emit: t, slots: a }) {
    c(toRef(e, "animation"));
    const l = c(toRef(e, "isStatus")), o = c(toRef(e, "autoHide")), n = c(toRef(e, "noCloseButton")), r = c(toRef(e, "noFade")), s = c(toRef(e, "noHoverPause"));
    c(toRef(e, "solid")), c(toRef(e, "static"));
    const f = c(toRef(e, "modelValue")), m = ref(false), B = ref(false), h2 = ref(false), v = computed(() => ({
      [`b-toast-${e.variant}`]: e.variant !== void 0,
      show: h2.value || m.value
    }));
    let w, g, k;
    const y = () => {
      typeof w > "u" || (clearTimeout(w), w = void 0);
    }, $ = computed(
      () => (
        // Minimum supported duration is 1 second
        Math.max(lt(e.delay, 0), Ll)
      )
    ), b = () => {
      f.value && (g = k = 0, y(), B.value = true, Rt(() => {
        h2.value = false;
      }));
    }, _ = () => {
      y(), t("update:modelValue", true), g = k = 0, B.value = false, nextTick(() => {
        Rt(() => {
          h2.value = true;
        });
      });
    }, V = () => {
      if (!o.value || s.value || !w || k)
        return;
      const W = Date.now() - g;
      W > 0 && (y(), k = Math.max($.value - W, Ll));
    }, T = () => {
      (!o.value || s.value || !k) && (k = g = 0), S();
    };
    watch(f, (W) => {
      W ? _() : b();
    });
    const S = () => {
      y(), o.value && (w = setTimeout(b, k || $.value), g = Date.now(), k = 0);
    }, O = () => {
      m.value = true, t("update:modelValue", true);
    }, I = () => {
      m.value = false, S();
    }, C = () => {
      m.value = true;
    }, F = () => {
      m.value = false, k = g = 0, t("update:modelValue", false);
    };
    onUnmounted(() => {
      y(), o.value && t("destroyed", e.id);
    }), onMounted(() => {
      nextTick(() => {
        f.value && Rt(() => {
          _();
        });
      });
    });
    const P = () => {
      nextTick(() => {
        Rt(() => {
          b();
        });
      });
    };
    return () => {
      const W = () => {
        const j = [], te = De(ou, { hide: b }, a);
        te ? j.push(h(te)) : e.title && j.push(h("strong", { class: "me-auto" }, e.title)), !n.value && j.length !== 0 && j.push(
          h(Tt, {
            class: ["btn-close"],
            onClick: () => {
              b();
            }
          })
        );
        const X = [];
        if (j.length > 0 && X.push(
          h(
            e.headerTag,
            {
              class: "toast-header"
            },
            { default: () => j }
          )
        ), De("default", { hide: b }, a) || e.body) {
          const q = h(
            Et(e) ? "b-link" : "div",
            {
              class: ["toast-body", e.bodyClass],
              onClick: Et(e) ? { click: P } : {}
            },
            De("default", { hide: b }, a) || e.body
          );
          X.push(q);
        }
        return h(
          "div",
          {
            class: ["toast", e.toastClass, v.value],
            tabindex: "0"
          },
          X
        );
      };
      return h(
        "div",
        {
          class: ["b-toast"],
          id: e.id,
          role: B.value ? null : l.value ? "status" : "alert",
          "aria-live": B.value ? null : l.value ? "polite" : "assertive",
          "aria-atomic": B.value ? null : true,
          onmouseenter: V,
          onmouseleave: T
        },
        [
          h(
            _t,
            {
              noFade: r.value,
              onAfterEnter: I,
              onBeforeEnter: O,
              onAfterLeave: F,
              onBeforeLeave: C
            },
            () => [h2.value ? W() : ""]
          )
        ]
      );
    };
  }
});
var Ta = defineComponent({
  __name: "BToaster",
  props: {
    position: { default: "top-right" },
    instance: { default: void 0 }
  },
  setup(e) {
    const t = e, a = {
      "top-left": "top-0 start-0",
      "top-center": "top-0 start-50 translate-middle-x",
      "top-right": "top-0 end-0",
      "middle-left": "top-50 start-0 translate-middle-y",
      "middle-center": "top-50 start-50 translate-middle",
      "middle-right": "top-50 end-0 translate-middle-y",
      "bottom-left": "bottom-0 start-0",
      "bottom-center": "bottom-0 start-50 translate-middle-x",
      "bottom-right": "bottom-0 end-0"
    }, l = computed(() => a[t.position]), o = (n) => {
      var r;
      (r = t.instance) == null || r.remove(n);
    };
    return (n, r) => {
      var s;
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([[unref(l)], "b-toaster position-fixed p-3"]),
        style: { "z-index": "11" }
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList((s = e.instance) == null ? void 0 : s.toasts(e.position).value, (f) => (openBlock(), createBlock($n, {
          id: f.options.id,
          key: f.options.id,
          modelValue: f.options.value,
          "onUpdate:modelValue": (m) => f.options.value = m,
          "auto-hide": f.options.autoHide,
          delay: f.options.delay,
          "no-close-button": f.options.noCloseButton,
          title: f.content.title,
          body: f.content.body,
          component: f.content.body,
          variant: f.options.variant,
          onDestroyed: o
        }, null, 8, ["id", "modelValue", "onUpdate:modelValue", "auto-hide", "delay", "no-close-button", "title", "body", "component", "variant"]))), 128))
      ], 2);
    };
  }
});
var nu = defineComponent({
  props: {
    gutterX: { type: String, default: null },
    gutterY: { type: String, default: null },
    fluid: { type: [Boolean, String], default: false },
    toast: { type: Object, default: void 0 },
    position: { type: String, default: void 0 }
  },
  setup(e, { slots: t, expose: a }) {
    const l = ref();
    let o;
    const n = computed(() => ({
      container: !e.fluid,
      ["container-fluid"]: typeof e.fluid == "boolean" && e.fluid,
      [`container-${e.fluid}`]: typeof e.fluid == "string",
      [`gx-${e.gutterX}`]: e.gutterX !== null,
      [`gy-${e.gutterY}`]: e.gutterY !== null
    }));
    return onMounted(() => {
      e.toast;
    }), e.toast && (o = Bn({ container: l, root: e.toast.root }), a({
      // ...toastInstance?.useMethods,
    })), () => {
      var s;
      const r = [];
      return o == null || o.containerPositions.value.forEach((f) => {
        r.push(h(Ta, { key: f, instance: o, position: f }));
      }), h("div", { class: [n.value, e.position], ref: l }, [
        ...r,
        (s = t.default) == null ? void 0 : s.call(t)
      ]);
    };
  },
  methods: {}
});
var su = { class: "visually-hidden" };
var iu = ["aria-labelledby", "role"];
var ru = {
  inheritAttrs: false
};
var wn = defineComponent({
  ...ru,
  __name: "BDropdown",
  props: {
    id: { default: void 0 },
    menuClass: { default: void 0 },
    size: { default: void 0 },
    splitClass: { default: void 0 },
    splitVariant: { default: void 0 },
    text: { default: void 0 },
    toggleClass: { default: void 0 },
    autoClose: { type: [Boolean, String], default: true },
    block: { default: false },
    dark: { default: false },
    disabled: { default: false },
    isNav: { default: false },
    dropup: { default: false },
    dropend: { default: false },
    dropstart: { default: false },
    center: { default: false },
    end: { default: false },
    noFlip: { default: false },
    noShift: { default: false },
    offset: { default: 0 },
    role: { default: "menu" },
    split: { default: false },
    splitButtonType: { default: "button" },
    splitHref: { default: void 0 },
    splitDisabled: { default: void 0 },
    noCaret: { default: false },
    toggleText: { default: "Toggle dropdown" },
    variant: { default: "secondary" },
    modelValue: { default: false },
    lazy: { default: false },
    strategy: { default: "absolute" },
    floatingMiddleware: { default: void 0 },
    splitTo: { default: void 0 }
  },
  emits: ["show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "click", "toggle", "update:modelValue"],
  setup(e, { emit: t }) {
    const a = e, l = Ce(toRef(a, "id"), "dropdown"), o = Te(a, "modelValue", t, { passive: true }), n = c(o), r = c(toRef(a, "block")), s = c(toRef(a, "dark")), f = c(toRef(a, "dropup")), m = c(toRef(a, "dropend")), B = c(toRef(a, "isNav")), h2 = c(toRef(a, "dropstart")), v = c(toRef(a, "center")), w = c(toRef(a, "end")), g = c(toRef(a, "split")), k = c(toRef(a, "noCaret")), y = c(toRef(a, "noFlip")), $ = c(toRef(a, "noShift")), b = c(toRef(a, "lazy")), _ = c(toRef(a, "splitDisabled")), V = computed(
      () => typeof a.offset == "string" || typeof a.offset == "number" ? a.offset : NaN
    ), T = Bt(V, { method: "parseInt", nanToZero: true }), S = ref(null), O = ref(null), I = ref(null), C = computed(() => g.value ? O.value : I.value), F = computed(
      () => tr({
        top: f.value,
        start: h2.value,
        end: m.value,
        alignCenter: v.value,
        alignEnd: w.value
      })
    ), P = computed(() => {
      if (a.floatingMiddleware !== void 0)
        return a.floatingMiddleware;
      const L = typeof a.offset == "string" || typeof a.offset == "number" ? T.value : a.offset, z = [Oo(L)];
      return y.value === false && z.push(Vo()), $.value === false && z.push(Po()), z;
    }), { x: W, y: j, strategy: te, update: X } = Ho(C, S, {
      placement: F,
      middleware: P,
      strategy: a.strategy
    }), q = computed(() => ({
      "d-grid": r.value,
      dropup: f.value,
      dropend: m.value,
      dropstart: h2.value,
      "d-flex": r.value && g.value
    })), ae = computed(() => [
      g.value ? a.splitClass : a.toggleClass,
      {
        "nav-link": B.value,
        "dropdown-toggle": !g.value,
        "dropdown-toggle-no-caret": k.value && !g.value,
        "w-100": g.value && r.value
      }
    ]), me = computed(() => [
      a.menuClass,
      {
        "dropdown-menu-dark": s.value
      }
    ]), pe = computed(() => ({
      "aria-expanded": g.value ? void 0 : false,
      href: g.value ? a.splitHref : void 0,
      to: g.value && a.splitTo ? a.splitTo : void 0
    })), be = () => {
      t("toggle");
      const L = n.value, z = new Xe(L ? "hide" : "show");
      if (t(L ? "hide" : "show", z), z.defaultPrevented) {
        t(L ? "hide-prevented" : "show-prevented");
        return;
      }
      o.value = !L, t(L ? "hidden" : "shown");
    }, ne = (L) => {
      g.value ? t("click", L) : be();
    };
    Uo(
      S,
      () => {
        n.value && (a.autoClose === true || a.autoClose === "outside") && (o.value = !n.value);
      },
      { ignore: [O, I] }
    );
    const ve = () => {
      n.value && (a.autoClose === true || a.autoClose === "inside") && (o.value = !n.value);
    };
    return watch(n, X), provide(xo, {
      id: l,
      open: () => {
        o.value = true;
      },
      close: () => {
        o.value = false;
      },
      toggle: () => {
        o.value = !n.value;
      },
      visible: n,
      isNav: B
    }), (L, z) => (openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("div", mergeProps({
        class: [unref(q), "btn-group"]
      }, L.$attrs), [
        createVNode(kt, mergeProps({
          id: unref(l),
          ref_key: "splitButton",
          ref: I,
          variant: e.splitVariant || e.variant,
          size: e.size,
          class: unref(ae),
          disabled: unref(_) || e.disabled,
          type: e.splitButtonType
        }, unref(pe), {
          onClick: ne,
          onKeydown: z[0] || (z[0] = withKeys((ee) => o.value = !unref(n), ["esc"]))
        }), {
          default: withCtx(() => [
            renderSlot(L.$slots, "button-content", {}, () => [
              createTextVNode(toDisplayString(e.text), 1)
            ])
          ]),
          _: 3
        }, 16, ["id", "variant", "size", "class", "disabled", "type"]),
        unref(g) ? (openBlock(), createBlock(kt, {
          key: 0,
          ref_key: "button",
          ref: O,
          variant: e.variant,
          size: e.size,
          disabled: e.disabled,
          class: normalizeClass([e.toggleClass, "dropdown-toggle-split dropdown-toggle"]),
          "aria-expanded": "false",
          onClick: be
        }, {
          default: withCtx(() => [
            createBaseVNode("span", su, [
              renderSlot(L.$slots, "toggle-text", {}, () => [
                createTextVNode(toDisplayString(e.toggleText), 1)
              ])
            ])
          ]),
          _: 3
        }, 8, ["variant", "size", "disabled", "class"])) : createCommentVNode("", true)
      ], 16),
      !unref(b) || unref(n) ? withDirectives((openBlock(), createElementBlock("ul", {
        key: 0,
        ref_key: "floating",
        ref: S,
        style: normalizeStyle({
          position: unref(te) === "absolute" ? void 0 : "fixed",
          top: `${unref(j) ?? 0}px`,
          left: `${unref(W) ?? 0}px`,
          width: "max-content"
        }),
        class: normalizeClass(["dropdown-menu show", unref(me)]),
        "aria-labelledby": unref(l),
        role: e.role,
        onClick: ve
      }, [
        renderSlot(L.$slots, "default")
      ], 14, iu)), [
        [vShow, unref(b) || unref(n)]
      ]) : createCommentVNode("", true)
    ], 64));
  }
});
var uu = { role: "presentation" };
var du = defineComponent({
  __name: "BDropdownDivider",
  props: {
    tag: { default: "hr" }
  },
  setup(e) {
    return (t, a) => (openBlock(), createElementBlock("li", uu, [
      (openBlock(), createBlock(resolveDynamicComponent(e.tag), {
        class: "dropdown-divider",
        role: "separator",
        "aria-orientation": "horizontal"
      }))
    ]));
  }
});
var cu = {};
var fu = { role: "presentation" };
var vu = { class: "px-4 py-3" };
function mu(e, t) {
  return openBlock(), createElementBlock("li", fu, [
    createBaseVNode("form", vu, [
      renderSlot(e.$slots, "default")
    ])
  ]);
}
var pu = ze(cu, [["render", mu]]);
var gu = { role: "presentation" };
var bu = ["id", "aria-describedby"];
var hu = {
  inheritAttrs: false
};
var yu = defineComponent({
  ...hu,
  __name: "BDropdownGroup",
  props: {
    id: { default: void 0 },
    ariaDescribedby: { default: void 0 },
    header: { default: void 0 },
    headerClass: { default: void 0 },
    headerTag: { default: "header" },
    headerVariant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = computed(
      () => t.id ? `${t.id}_group_dd_header` : void 0
    ), l = computed(
      () => t.headerTag === "header" ? void 0 : "heading"
    ), o = computed(() => [
      t.headerClass,
      {
        [`text-${t.headerVariant}`]: t.headerVariant !== void 0
      }
    ]);
    return (n, r) => (openBlock(), createElementBlock("li", gu, [
      (openBlock(), createBlock(resolveDynamicComponent(e.headerTag), {
        id: unref(a),
        class: normalizeClass(["dropdown-header", unref(o)]),
        role: unref(l)
      }, {
        default: withCtx(() => [
          renderSlot(n.$slots, "header", {}, () => [
            createTextVNode(toDisplayString(e.header), 1)
          ])
        ]),
        _: 3
      }, 8, ["id", "class", "role"])),
      createBaseVNode("ul", mergeProps({
        id: e.id,
        role: "group",
        class: "list-unstyled"
      }, n.$attrs, {
        "aria-describedby": e.ariaDescribedby || unref(a)
      }), [
        renderSlot(n.$slots, "default")
      ], 16, bu)
    ]));
  }
});
var Bu = {};
var $u = { class: "dropdown-header" };
function wu(e, t) {
  return openBlock(), createElementBlock("li", null, [
    createBaseVNode("h6", $u, [
      renderSlot(e.$slots, "default")
    ])
  ]);
}
var ku = ze(Bu, [["render", wu]]);
var Cu = {
  inheritAttrs: false
};
var Su = defineComponent({
  ...Cu,
  __name: "BDropdownItem",
  props: {
    href: { default: void 0 },
    linkClass: { default: void 0 },
    active: { default: false },
    disabled: { default: false },
    rel: { default: void 0 },
    target: { default: "_self" },
    variant: { default: void 0 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = e, l = c(toRef(a, "active")), o = c(toRef(a, "disabled")), n = useAttrs(), r = computed(() => [
      a.linkClass,
      {
        active: l.value,
        disabled: o.value,
        [`text-${a.variant}`]: a.variant !== void 0
      }
    ]), s = computed(
      () => a.href ? "a" : n.to ? Ne : "button"
    ), f = computed(() => ({
      disabled: o.value,
      "aria-current": l.value ? true : null,
      href: s.value === "a" ? a.href : null,
      rel: a.rel,
      type: s.value === "button" ? "button" : null,
      target: a.target,
      ...n.to ? { activeClass: "active", ...n } : {}
    })), m = inject(Ma, null), B = inject(xo, null), h2 = (v) => {
      var w, g;
      t("click", v), (w = m == null ? void 0 : m.close) == null || w.call(m), (g = B == null ? void 0 : B.close) == null || g.call(B);
    };
    return (v, w) => (openBlock(), createElementBlock("li", {
      role: "presentation",
      class: normalizeClass(v.$attrs.class)
    }, [
      (openBlock(), createBlock(resolveDynamicComponent(unref(s)), mergeProps({
        class: ["dropdown-item", unref(r)]
      }, unref(f), { onClick: h2 }), {
        default: withCtx(() => [
          renderSlot(v.$slots, "default")
        ]),
        _: 3
      }, 16, ["class"]))
    ], 2));
  }
});
var _u = ["disabled"];
var Tu = {
  inheritAttrs: false
};
var xu = defineComponent({
  ...Tu,
  __name: "BDropdownItemButton",
  props: {
    buttonClass: { default: void 0 },
    active: { default: false },
    activeClass: { default: "active" },
    disabled: { default: false },
    variant: { default: void 0 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = e, l = c(toRef(a, "active")), o = c(toRef(a, "disabled")), n = computed(() => [
      a.buttonClass,
      {
        [a.activeClass]: l.value,
        disabled: o.value,
        [`text-${a.variant}`]: a.variant !== void 0
      }
    ]), r = (s) => t("click", s);
    return (s, f) => (openBlock(), createElementBlock("li", {
      role: "presentation",
      class: normalizeClass(s.$attrs.class)
    }, [
      createBaseVNode("button", {
        role: "menu",
        type: "button",
        class: normalizeClass(["dropdown-item", unref(n)]),
        disabled: unref(o),
        onClick: r
      }, [
        renderSlot(s.$slots, "default")
      ], 10, _u)
    ], 2));
  }
});
var Au = { role: "presentation" };
var Vu = { class: "px-4 py-1 mb-0 text-muted" };
var Ou = defineComponent({
  __name: "BDropdownText",
  props: {
    text: { default: "" }
  },
  setup(e) {
    return (t, a) => (openBlock(), createElementBlock("li", Au, [
      createBaseVNode("p", Vu, [
        renderSlot(t.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(e.text), 1)
        ])
      ])
    ]));
  }
});
var Pu = ["id", "novalidate", "onSubmit"];
var kn = defineComponent({
  __name: "BForm",
  props: {
    id: { default: void 0 },
    floating: { default: false },
    novalidate: { default: false },
    validated: { default: false }
  },
  emits: ["submit"],
  setup(e, { emit: t }) {
    const a = e, l = c(toRef(a, "floating")), o = c(toRef(a, "novalidate")), n = c(toRef(a, "validated")), r = computed(() => ({
      "form-floating": l.value,
      "was-validated": n.value
    })), s = (f) => t("submit", f);
    return (f, m) => (openBlock(), createElementBlock("form", {
      id: e.id,
      novalidate: unref(o),
      class: normalizeClass(unref(r)),
      onSubmit: withModifiers(s, ["prevent"])
    }, [
      renderSlot(f.$slots, "default")
    ], 42, Pu));
  }
});
var Eu = { class: "form-floating" };
var Iu = ["for"];
var Fu = defineComponent({
  __name: "BFormFloatingLabel",
  props: {
    labelFor: { default: void 0 },
    label: { default: void 0 },
    text: { default: void 0 }
  },
  setup(e) {
    return (t, a) => (openBlock(), createElementBlock("div", Eu, [
      renderSlot(t.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(e.text), 1)
      ]),
      createBaseVNode("label", { for: e.labelFor }, [
        renderSlot(t.$slots, "label", {}, () => [
          createTextVNode(toDisplayString(e.label), 1)
        ])
      ], 8, Iu)
    ]));
  }
});
var xa = defineComponent({
  __name: "BFormInvalidFeedback",
  props: {
    ariaLive: { default: void 0 },
    forceShow: { default: false },
    id: { default: void 0 },
    text: { default: void 0 },
    role: { default: void 0 },
    state: { default: null },
    tag: { default: "div" },
    tooltip: { default: false }
  },
  setup(e) {
    const t = e, a = c(toRef(t, "forceShow")), l = c(toRef(t, "state")), o = c(toRef(t, "tooltip")), n = computed(
      () => a.value === true || l.value === false
    ), r = computed(() => ({
      "d-block": n.value,
      "invalid-feedback": !o.value,
      "invalid-tooltip": o.value
    })), s = computed(() => ({
      id: t.id,
      role: t.role,
      "aria-live": t.ariaLive,
      "aria-atomic": t.ariaLive ? true : void 0
    }));
    return (f, m) => (openBlock(), createBlock(resolveDynamicComponent(e.tag), mergeProps({ class: unref(r) }, unref(s)), {
      default: withCtx(() => [
        renderSlot(f.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(e.text), 1)
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
});
var qt = defineComponent({
  __name: "BFormRow",
  props: {
    tag: { default: "div" }
  },
  setup(e) {
    return (t, a) => (openBlock(), createBlock(resolveDynamicComponent(e.tag), { class: "row d-flex flex-wrap" }, {
      default: withCtx(() => [
        renderSlot(t.$slots, "default")
      ]),
      _: 3
    }));
  }
});
var Aa = defineComponent({
  __name: "BFormText",
  props: {
    id: { default: void 0 },
    inline: { default: false },
    tag: { default: "small" },
    text: { default: void 0 },
    textVariant: { default: "muted" }
  },
  setup(e) {
    const t = e, a = c(toRef(t, "inline")), l = computed(() => [
      [`text-${t.textVariant}`],
      {
        "form-text": !a.value
      }
    ]);
    return (o, n) => (openBlock(), createBlock(resolveDynamicComponent(e.tag), {
      id: e.id,
      class: normalizeClass(unref(l))
    }, {
      default: withCtx(() => [
        renderSlot(o.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(e.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
});
var Va = defineComponent({
  __name: "BFormValidFeedback",
  props: {
    ariaLive: { default: void 0 },
    forceShow: { default: false },
    id: { default: void 0 },
    role: { default: void 0 },
    text: { default: void 0 },
    state: { default: null },
    tag: { default: "div" },
    tooltip: { default: false }
  },
  setup(e) {
    const t = e, a = c(toRef(t, "forceShow")), l = c(toRef(t, "state")), o = c(toRef(t, "tooltip")), n = computed(
      () => a.value === true || l.value === true
    ), r = computed(() => ({
      "d-block": n.value,
      "valid-feedback": !o.value,
      "valid-tooltip": o.value
    })), s = computed(() => t.ariaLive ? true : void 0);
    return (f, m) => (openBlock(), createBlock(resolveDynamicComponent(e.tag), {
      id: e.id,
      role: e.role,
      "aria-live": e.ariaLive,
      "aria-atomic": unref(s),
      class: normalizeClass(unref(r))
    }, {
      default: withCtx(() => [
        renderSlot(f.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(e.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "role", "aria-live", "aria-atomic", "class"]));
  }
});
var Cn = defineComponent({
  name: "ComponentOrEmpty",
  props: {
    tag: {
      type: String,
      default: "div"
    },
    skip: {
      type: Boolean,
      default: false
    }
  },
  setup(e, { slots: t, attrs: a }) {
    return () => {
      var l, o;
      return e.skip ? (l = t.default) == null ? void 0 : l.call(t) : h(e.tag, { ...a }, [(o = t.default) == null ? void 0 : o.call(t)]);
    };
  }
});
var Lu = ["id", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "aria-required", "value", "indeterminate"];
var Nu = ["for"];
var zu = {
  inheritAttrs: false
};
var Sn = defineComponent({
  ...zu,
  __name: "BFormCheckbox",
  props: {
    ariaLabel: { default: void 0 },
    ariaLabelledBy: { default: void 0 },
    form: { default: void 0 },
    indeterminate: { default: void 0 },
    name: { default: void 0 },
    id: { default: void 0 },
    autofocus: { default: false },
    plain: { default: false },
    button: { default: false },
    buttonGroup: { default: false },
    switch: { default: false },
    disabled: { default: false },
    buttonVariant: { default: void 0 },
    inline: { default: false },
    required: { default: void 0 },
    size: { default: void 0 },
    state: { default: null },
    uncheckedValue: { type: [Array, Set, Boolean, String, Object, Number, null], default: false },
    value: { type: [Array, Set, Boolean, String, Object, Number, null], default: true },
    modelValue: { type: [Array, Set, Boolean, String, Object, Number, null], default: void 0 }
  },
  emits: ["update:modelValue", "input", "change"],
  setup(e, { emit: t }) {
    const a = e, l = useSlots(), o = Te(a, "modelValue", t, { passive: true }), n = Ce(toRef(a, "id"), "form-check"), r = c(toRef(a, "indeterminate")), s = c(toRef(a, "autofocus")), f = c(toRef(a, "plain")), m = c(toRef(a, "button")), B = c(toRef(a, "buttonGroup")), h2 = c(toRef(a, "switch")), v = c(toRef(a, "disabled")), w = c(toRef(a, "inline")), g = c(toRef(a, "required")), k = c(toRef(a, "state")), y = inject(_o, null), $ = ref(null);
    qe($, {
      initialValue: s.value
    });
    const b = computed(() => !Ve(l.default)), _ = computed({
      get: () => y !== null ? y.modelValue.value.map((F) => JSON.stringify(F)).includes(JSON.stringify(a.value)) : JSON.stringify(o.value) === JSON.stringify(a.value),
      set: (F) => {
        const P = F ? a.value : a.uncheckedValue;
        t("input", P), o.value = P, nextTick(() => {
          t("change", P);
        });
      }
    });
    watch(o, (F) => {
      if (y !== null) {
        if (F === false) {
          y.remove(a.value);
          return;
        }
        y.set(a.value);
      }
    });
    const V = computed(
      () => !!(a.name ?? (y == null ? void 0 : y.name.value)) && (g.value || (y == null ? void 0 : y.required.value))
    ), T = computed(
      () => B.value || ((y == null ? void 0 : y.buttons.value) ?? false)
    ), S = computed(() => ({
      plain: f.value || ((y == null ? void 0 : y.plain.value) ?? false),
      button: m.value || ((y == null ? void 0 : y.buttons.value) ?? false),
      inline: w.value || ((y == null ? void 0 : y.inline.value) ?? false),
      switch: h2.value || ((y == null ? void 0 : y.switch.value) ?? false),
      state: k.value || (y == null ? void 0 : y.state.value),
      size: a.size !== void 0 ? a.size : (y == null ? void 0 : y.size.value) ?? "md",
      // This is where the true default is made
      buttonVariant: a.buttonVariant !== void 0 ? a.buttonVariant : (y == null ? void 0 : y.buttonVariant.value) ?? "secondary"
      // This is where the true default is made
    })), O = en(S), I = tn(S), C = an(S);
    return (F, P) => (openBlock(), createBlock(Cn, {
      skip: unref(T),
      class: normalizeClass(unref(O))
    }, {
      default: withCtx(() => {
        var W, j, te;
        return [
          withDirectives(createBaseVNode("input", mergeProps({ id: unref(n) }, F.$attrs, {
            ref_key: "input",
            ref: $,
            "onUpdate:modelValue": P[0] || (P[0] = (X) => isRef(_) ? _.value = X : null),
            class: unref(I),
            type: "checkbox",
            disabled: unref(v) || ((W = unref(y)) == null ? void 0 : W.disabled.value),
            required: unref(V) ? true : void 0,
            name: e.name || ((j = unref(y)) == null ? void 0 : j.name.value),
            form: e.form || ((te = unref(y)) == null ? void 0 : te.form.value),
            "aria-label": e.ariaLabel,
            "aria-labelledby": e.ariaLabelledBy,
            "aria-required": unref(V) ? true : void 0,
            value: e.value,
            indeterminate: unref(r)
          }), null, 16, Lu), [
            [vModelCheckbox, unref(_)]
          ]),
          unref(b) || unref(f) === false ? (openBlock(), createElementBlock("label", {
            key: 0,
            for: unref(n),
            class: normalizeClass(unref(C))
          }, [
            renderSlot(F.$slots, "default")
          ], 10, Nu)) : createCommentVNode("", true)
        ];
      }),
      _: 3
    }, 8, ["skip", "class"]));
  }
});
var Ru = ["id"];
var Hu = ["innerHTML"];
var Mu = ["textContent"];
var Du = defineComponent({
  __name: "BFormCheckboxGroup",
  props: {
    id: { default: void 0 },
    form: { default: void 0 },
    modelValue: { default: () => [] },
    ariaInvalid: { default: void 0 },
    autofocus: { default: false },
    buttonVariant: { default: "secondary" },
    buttons: { default: false },
    disabled: { default: false },
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    name: { default: void 0 },
    options: { default: () => [] },
    plain: { default: false },
    required: { default: false },
    size: { default: void 0 },
    stacked: { default: false },
    state: { default: null },
    switches: { default: false },
    textField: { default: "text" },
    validated: { default: false },
    valueField: { default: "value" }
  },
  emits: ["input", "update:modelValue", "change"],
  setup(e, { emit: t }) {
    const a = e, l = Te(a, "modelValue", t), o = Ce(toRef(a, "id"), "checkbox"), n = Ce(toRef(a, "name"), "checkbox"), r = c(toRef(a, "autofocus")), s = c(toRef(a, "buttons")), f = c(toRef(a, "disabled")), m = c(toRef(a, "plain")), B = c(toRef(a, "required")), h2 = c(toRef(a, "stacked")), v = c(toRef(a, "state")), w = c(toRef(a, "switches")), g = c(toRef(a, "validated")), k = ref(null);
    qe(k, {
      initialValue: r.value
    }), provide(_o, {
      set: (V) => {
        const T = [...l.value];
        T.push(V), t("input", T), l.value = T, nextTick(() => {
          t("change", T);
        });
      },
      remove: (V) => {
        const T = [...l.value];
        T.splice(l.value.indexOf(V), 1), t("input", T), l.value = T, nextTick(() => {
          t("change", T);
        });
      },
      modelValue: computed(() => l.value),
      switch: w,
      buttonVariant: readonly(toRef(a, "buttonVariant")),
      form: readonly(toRef(a, "form")),
      name: n,
      state: v,
      plain: m,
      size: readonly(toRef(a, "size")),
      inline: computed(() => !h2.value),
      required: B,
      buttons: s,
      disabled: f
    });
    const y = computed(
      () => a.options.map(
        (V, T) => typeof V == "string" || typeof V == "number" ? {
          props: {
            value: V,
            disabled: f.value
          },
          text: V.toString(),
          html: void 0,
          self: Symbol(`checkboxGroupOptionItem${T}`)
        } : {
          props: {
            value: V[a.valueField],
            disabled: V[a.disabledField],
            ...V.props ? V.props : {}
          },
          text: V[a.textField],
          html: V[a.htmlField],
          self: Symbol(`checkboxGroupOptionItem${T}`)
        }
      )
    ), $ = computed(() => ({
      required: B.value,
      ariaInvalid: a.ariaInvalid,
      state: v.value,
      validated: g.value,
      buttons: s.value,
      stacked: h2.value,
      size: a.size
    })), b = ln($), _ = on($);
    return (V, T) => (openBlock(), createElementBlock("div", mergeProps(unref(b), {
      id: unref(o),
      ref_key: "element",
      ref: k,
      role: "group",
      class: [unref(_), "bv-no-focus-ring"],
      tabindex: "-1"
    }), [
      renderSlot(V.$slots, "first"),
      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(y), (S) => (openBlock(), createBlock(Sn, mergeProps({
        key: S.self
      }, S.props), {
        default: withCtx(() => [
          S.html ? (openBlock(), createElementBlock("span", {
            key: 0,
            innerHTML: S.html
          }, null, 8, Hu)) : (openBlock(), createElementBlock("span", {
            key: 1,
            textContent: toDisplayString(S.text)
          }, null, 8, Mu))
        ]),
        _: 2
      }, 1040))), 128)),
      renderSlot(V.$slots, "default")
    ], 16, Ru));
  }
});
var _n = ["input", "select", "textarea"];
var ju = _n.map((e) => `${e}:not([disabled])`).join();
var qu = [..._n, "a", "button", "label"];
var Gu = "label";
var Wu = "invalid-feedback";
var Uu = "valid-feedback";
var Ku = "description";
var Xu = "default";
var Ju = defineComponent({
  components: { BCol: xt, BFormInvalidFeedback: xa, BFormRow: qt, BFormText: Aa, BFormValidFeedback: Va },
  props: {
    contentCols: { type: [Boolean, String, Number], default: void 0 },
    contentColsLg: { type: [Boolean, String, Number], default: void 0 },
    contentColsMd: { type: [Boolean, String, Number], default: void 0 },
    contentColsSm: { type: [Boolean, String, Number], default: void 0 },
    contentColsXl: { type: [Boolean, String, Number], default: void 0 },
    description: { type: [String], default: void 0 },
    disabled: { type: [Boolean, String], default: false },
    feedbackAriaLive: { type: String, default: "assertive" },
    id: { type: String, default: void 0 },
    invalidFeedback: { type: String, default: void 0 },
    label: { type: String, default: void 0 },
    labelAlign: { type: [Boolean, String, Number], default: void 0 },
    labelAlignLg: { type: [Boolean, String, Number], default: void 0 },
    labelAlignMd: { type: [Boolean, String, Number], default: void 0 },
    labelAlignSm: { type: [Boolean, String, Number], default: void 0 },
    labelAlignXl: { type: [Boolean, String, Number], default: void 0 },
    labelClass: { type: [Array, Object, String], default: void 0 },
    labelCols: { type: [Boolean, String, Number], default: void 0 },
    labelColsLg: { type: [Boolean, String, Number], default: void 0 },
    labelColsMd: { type: [Boolean, String, Number], default: void 0 },
    labelColsSm: { type: [Boolean, String, Number], default: void 0 },
    labelColsXl: { type: [Boolean, String, Number], default: void 0 },
    labelFor: { type: String, default: void 0 },
    labelSize: { type: String, default: void 0 },
    labelSrOnly: { type: [Boolean, String], default: false },
    state: { type: [Boolean, String], default: null },
    tooltip: { type: [Boolean, String], default: false },
    validFeedback: { type: String, default: void 0 },
    validated: { type: [Boolean, String], default: false },
    floating: { type: [Boolean, String], default: false }
  },
  setup(e, { attrs: t }) {
    const a = c(toRef(e, "disabled")), l = c(toRef(e, "labelSrOnly")), o = c(toRef(e, "state")), n = c(toRef(e, "tooltip")), r = c(toRef(e, "validated")), s = c(toRef(e, "floating")), f = null, m = ["xs", "sm", "md", "lg", "xl"], B = (S, O) => m.reduce((I, C) => {
      const F = ll(C === "xs" ? "" : C, `${O}Align`), P = S[F] || null;
      return P && (C === "xs" ? I.push(`text-${P}`) : I.push(`text-${C}-${P}`)), I;
    }, []), h2 = (S, O) => m.reduce((I, C) => {
      const F = ll(C === "xs" ? "" : C, `${O}Cols`);
      let P = S[F];
      return P = P === "" ? true : P || false, typeof P != "boolean" && P !== "auto" && (P = Ss(P, 0), P = P > 0 ? P : false), P && (C === "xs" ? I[typeof P == "boolean" ? "col" : "cols"] = P : I[C || (typeof P == "boolean" ? "col" : "cols")] = P), I;
    }, {}), v = ref(), w = (S, O = null) => {
      if (za && e.labelFor) {
        const I = go(`#${ss(e.labelFor)}`, v);
        if (I) {
          const C = "aria-describedby", F = (S || "").split(jt), P = (O || "").split(jt), W = (Ra(I, C) || "").split(jt).filter((j) => !P.includes(j)).concat(F).filter((j, te, X) => X.indexOf(j) === te).filter((j) => j).join(" ").trim();
          W ? $s(I, C, W) : ws(I, C);
        }
      }
    }, g = computed(() => h2(e, "content")), k = computed(() => B(e, "label")), y = computed(() => h2(e, "label")), $ = computed(
      () => (
        // Determine if the form group will be rendered horizontal
        // based on the existence of 'content-col' or 'label-col' props
        Object.keys(g.value).length > 0 || Object.keys(y.value).length > 0
      )
    ), b = computed(
      () => (
        // If not a boolean, ensure that value is null
        typeof o.value == "boolean" ? o.value : null
      )
    ), _ = computed(() => {
      const S = b.value;
      return S === true ? "is-valid" : S === false ? "is-invalid" : null;
    }), V = computed(
      () => ua(t.ariaInvalid, o.value)
    );
    return watch(
      () => f,
      (S, O) => {
        S !== O && w(S, O);
      }
    ), onMounted(() => {
      nextTick(() => {
        w(f);
      });
    }), {
      disabledBoolean: a,
      labelSrOnlyBoolean: l,
      stateBoolean: o,
      tooltipBoolean: n,
      validatedBoolean: r,
      floatingBoolean: s,
      ariaDescribedby: f,
      computedAriaInvalid: V,
      contentColProps: g,
      isHorizontal: $,
      labelAlignClasses: k,
      labelColProps: y,
      onLegendClick: (S) => {
        if (e.labelFor)
          return;
        const { target: O } = S, I = O ? O.tagName : "";
        if (qu.indexOf(I) !== -1)
          return;
        const C = ys(ju, v).filter(hs);
        C.length === 1 && gs(C[0]);
      },
      stateClass: _
    };
  },
  render() {
    const e = this.$props, t = this.$slots, a = Ce(), l = !e.labelFor;
    let o = null;
    const n = De(Gu, {}, t) || e.label, r = n ? at("_BV_label_") : null;
    if (n || this.isHorizontal) {
      const V = l ? "legend" : "label";
      if (this.labelSrOnlyBoolean)
        n && (o = h(
          V,
          {
            class: "visually-hidden",
            id: r,
            for: e.labelFor || null
          },
          n
        )), this.isHorizontal ? o = h(xt, this.labelColProps, { default: () => o }) : o = h("div", {}, [o]);
      else {
        const T = {
          onClick: l ? this.onLegendClick : null,
          ...this.isHorizontal ? this.labelColProps : {},
          tag: this.isHorizontal ? V : null,
          id: r,
          for: e.labelFor || null,
          tabIndex: l ? "-1" : null,
          class: [
            this.isHorizontal ? "col-form-label" : "form-label",
            {
              "bv-no-focus-ring": l,
              "col-form-label": this.isHorizontal || l,
              "pt-0": !this.isHorizontal && l,
              "d-block": !this.isHorizontal && !l,
              [`col-form-label-${e.labelSize}`]: !!e.labelSize
            },
            this.labelAlignClasses,
            e.labelClass
          ]
        };
        this.isHorizontal ? o = h(xt, T, { default: () => n }) : o = h(V, T, n);
      }
    }
    let s = null;
    const f = De(Wu, {}, t) || this.invalidFeedback, m = f ? at("_BV_feedback_invalid_") : void 0;
    f && (s = h(
      xa,
      {
        ariaLive: e.feedbackAriaLive,
        id: m,
        state: this.stateBoolean,
        tooltip: this.tooltipBoolean
      },
      { default: () => f }
    ));
    let B = null;
    const h2 = De(Uu, {}, t) || this.validFeedback, v = h2 ? at("_BV_feedback_valid_") : void 0;
    h2 && (B = h(
      Va,
      {
        ariaLive: e.feedbackAriaLive,
        id: v,
        state: this.stateBoolean,
        tooltip: this.tooltipBoolean
      },
      { default: () => h2 }
      // validFeedbackContent
    ));
    let w = null;
    const g = De(Ku, {}, t) || this.description, k = g ? at("_BV_description_") : void 0;
    g && (w = h(
      Aa,
      {
        id: k
      },
      { default: () => g }
    ));
    const y = this.ariaDescribedby = [
      k,
      this.stateBoolean === false ? m : null,
      this.stateBoolean === true ? v : null
    ].filter((V) => V).join(" ") || null, $ = [
      De(Xu, { ariaDescribedby: y, descriptionId: k, id: a, labelId: r }, t) || "",
      s,
      B,
      w
    ];
    !this.isHorizontal && this.floatingBoolean && $.push(o);
    let b = h(
      "div",
      {
        ref: "content",
        class: [
          {
            "form-floating": !this.isHorizontal && this.floatingBoolean
          }
        ]
      },
      $
    );
    this.isHorizontal && (b = h(xt, { ref: "content", ...this.contentColProps }, { default: () => $ }));
    const _ = {
      class: [
        this.stateClass,
        {
          "was-validated": this.validatedBoolean
        }
      ],
      id: Ce(toRef(e, "id")).value,
      disabled: l ? this.disabledBoolean : null,
      role: l ? null : "group",
      "aria-invalid": this.computedAriaInvalid,
      // Only apply `aria-labelledby` if we are a horizontal fieldset
      // as the legend is no longer a direct child of fieldset
      "aria-labelledby": l && this.isHorizontal ? r : null
    };
    return this.isHorizontal && !l ? h(qt, _, { default: () => [o, b] }) : h(
      l ? "fieldset" : "div",
      _,
      this.isHorizontal && l ? [h(qt, null, { default: () => [o, b] })] : this.isHorizontal || !this.floatingBoolean ? [o, b] : [b]
    );
  }
});
var Nl = [
  "text",
  "number",
  "email",
  "password",
  "search",
  "url",
  "tel",
  "date",
  "time",
  "range",
  "color",
  "datetime",
  "datetime-local",
  "month",
  "week"
];
var Yu = defineComponent({
  props: {
    ...nn,
    // debounce: {type: [String, Number], default: 0}, TODO: not implemented yet
    max: { type: [String, Number], default: void 0 },
    min: { type: [String, Number], default: void 0 },
    // noWheel: {type: [Boolean, String] as PropType<Booleanish>, default: false}, TODO: not implemented yet
    step: { type: [String, Number], default: void 0 },
    type: {
      type: String,
      default: "text",
      validator: (e) => Nl.includes(e)
    }
  },
  emits: ["update:modelValue", "change", "blur", "input"],
  setup(e, { emit: t }) {
    const { input: a, computedId: l, computedAriaInvalid: o, onInput: n, onChange: r, onBlur: s, focus: f, blur: m } = sn(e, t), B = ref(false), h2 = computed(() => {
      const g = e.type === "range", k = e.type === "color";
      return {
        "form-control-highlighted": B.value,
        "form-range": g,
        "form-control": k || !e.plaintext && !g,
        "form-control-color": k,
        "form-control-plaintext": e.plaintext && !g && !k,
        [`form-control-${e.size}`]: !!e.size,
        "is-valid": e.state === true,
        "is-invalid": e.state === false
      };
    }), v = computed(
      () => Nl.includes(e.type) ? e.type : "text"
    );
    return {
      computedClasses: h2,
      localType: v,
      input: a,
      computedId: l,
      computedAriaInvalid: o,
      onInput: n,
      onChange: r,
      onBlur: s,
      focus: f,
      blur: m,
      highlight: () => {
        B.value !== true && (B.value = true, setTimeout(() => {
          B.value = false;
        }, 2e3));
      }
    };
  }
});
var Zu = ["id", "name", "form", "type", "disabled", "placeholder", "required", "autocomplete", "readonly", "min", "max", "step", "list", "aria-required", "aria-invalid"];
function Qu(e, t, a, l, o, n) {
  return openBlock(), createElementBlock("input", {
    id: e.computedId,
    ref: "input",
    class: normalizeClass(e.computedClasses),
    name: e.name || void 0,
    form: e.form || void 0,
    type: e.localType,
    disabled: e.disabled,
    placeholder: e.placeholder,
    required: e.required,
    autocomplete: e.autocomplete || void 0,
    readonly: e.readonly || e.plaintext,
    min: e.min,
    max: e.max,
    step: e.step,
    list: e.type !== "password" ? e.list : void 0,
    "aria-required": e.required ? true : void 0,
    "aria-invalid": e.computedAriaInvalid,
    onInput: t[0] || (t[0] = (r) => e.onInput(r)),
    onChange: t[1] || (t[1] = (r) => e.onChange(r)),
    onBlur: t[2] || (t[2] = (r) => e.onBlur(r))
  }, null, 42, Zu);
}
var ed = ze(Yu, [["render", Qu]]);
var td = ["id", "checked", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "value", "aria-required"];
var ad = ["for"];
var ld = {
  inheritAttrs: false
};
var Tn = defineComponent({
  ...ld,
  __name: "BFormRadio",
  props: {
    ariaLabel: { default: void 0 },
    ariaLabelledby: { default: void 0 },
    form: { default: void 0 },
    id: { default: void 0 },
    name: { default: void 0 },
    size: { default: void 0 },
    autofocus: { default: false },
    modelValue: { type: [Boolean, String, Array, Object, Number, null], default: void 0 },
    plain: { default: false },
    button: { default: false },
    buttonGroup: { default: false },
    disabled: { default: false },
    buttonVariant: { default: void 0 },
    inline: { default: false },
    required: { default: false },
    state: { default: null },
    value: { type: [String, Boolean, Object, Number], default: true }
  },
  emits: ["input", "change", "update:modelValue"],
  setup(e, { emit: t }) {
    const a = e, l = useSlots(), o = Te(a, "modelValue", t, { passive: true }), n = Ce(toRef(a, "id"), "form-check"), r = c(toRef(a, "autofocus")), s = c(toRef(a, "plain")), f = c(toRef(a, "button")), m = c(toRef(a, "buttonGroup")), B = c(toRef(a, "disabled")), h2 = c(toRef(a, "inline")), v = c(toRef(a, "required")), w = c(toRef(a, "state")), g = inject(To, null), k = ref(null);
    qe(k, {
      initialValue: r.value
    });
    const y = computed(() => !Ve(l.default)), $ = computed({
      get: () => g !== null ? JSON.stringify(g.modelValue.value) === JSON.stringify(a.value) : JSON.stringify(o.value) === JSON.stringify(a.value),
      set: (I) => {
        const C = I || I === 0 ? a.value : false;
        t("input", C), o.value = C, nextTick(() => {
          t("change", C);
        });
      }
    });
    watch(
      () => g == null ? void 0 : g.modelValue.value,
      (I) => {
        JSON.stringify(I) === JSON.stringify(a.value) !== true && ($.value = false);
      }
    ), watch(o, (I) => {
      g === null || I === false || g.set(a.value);
    });
    const b = computed(
      () => !!(a.name ?? (g == null ? void 0 : g.name.value)) && (v.value || (g == null ? void 0 : g.required.value))
    ), _ = computed(
      () => m.value || ((g == null ? void 0 : g.buttons.value) ?? false)
    ), V = computed(() => ({
      plain: s.value || ((g == null ? void 0 : g.plain.value) ?? false),
      button: f.value || ((g == null ? void 0 : g.buttons.value) ?? false),
      inline: h2.value || ((g == null ? void 0 : g.inline.value) ?? false),
      state: w.value || (g == null ? void 0 : g.state.value),
      size: a.size !== void 0 ? a.size : (g == null ? void 0 : g.size.value) ?? "md",
      // This is where the true default is made
      buttonVariant: a.buttonVariant !== void 0 ? a.buttonVariant : (g == null ? void 0 : g.buttonVariant.value) ?? "secondary"
      // This is where the true default is made
    })), T = en(V), S = tn(V), O = an(V);
    return (I, C) => (openBlock(), createBlock(Cn, {
      skip: unref(_),
      class: normalizeClass(unref(T))
    }, {
      default: withCtx(() => {
        var F, P, W;
        return [
          withDirectives(createBaseVNode("input", mergeProps({ id: unref(n) }, I.$attrs, {
            ref_key: "input",
            ref: k,
            "onUpdate:modelValue": C[0] || (C[0] = (j) => isRef($) ? $.value = j : null),
            checked: unref($),
            class: unref(S),
            type: "radio",
            disabled: unref(B) || ((F = unref(g)) == null ? void 0 : F.disabled.value),
            required: unref(b) ? true : void 0,
            name: e.name || ((P = unref(g)) == null ? void 0 : P.name.value),
            form: e.form || ((W = unref(g)) == null ? void 0 : W.form.value),
            "aria-label": e.ariaLabel,
            "aria-labelledby": e.ariaLabelledby,
            value: e.value,
            "aria-required": unref(b) ? true : void 0
          }), null, 16, td), [
            [vModelRadio, unref($)]
          ]),
          unref(y) || unref(s) === false ? (openBlock(), createElementBlock("label", {
            key: 0,
            for: unref(n),
            class: normalizeClass(unref(O))
          }, [
            renderSlot(I.$slots, "default")
          ], 10, ad)) : createCommentVNode("", true)
        ];
      }),
      _: 3
    }, 8, ["skip", "class"]));
  }
});
var od = ["id"];
var nd = ["innerHTML"];
var sd = ["textContent"];
var id = defineComponent({
  __name: "BFormRadioGroup",
  props: {
    size: { default: void 0 },
    form: { default: void 0 },
    id: { default: void 0 },
    name: { default: void 0 },
    modelValue: { type: [String, Boolean, Array, Object, Number, null], default: null },
    ariaInvalid: { default: void 0 },
    autofocus: { default: false },
    buttonVariant: { default: "secondary" },
    buttons: { default: false },
    disabled: { default: false },
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    options: { default: () => [] },
    plain: { default: false },
    required: { default: false },
    stacked: { default: false },
    state: { default: null },
    textField: { default: "text" },
    validated: { default: false },
    valueField: { default: "value" }
  },
  emits: ["input", "update:modelValue", "change"],
  setup(e, { emit: t }) {
    const a = e, l = Te(a, "modelValue", t), o = Ce(toRef(a, "id"), "radio"), n = Ce(toRef(a, "name"), "checkbox"), r = c(toRef(a, "autofocus")), s = c(toRef(a, "buttons")), f = c(toRef(a, "disabled")), m = c(toRef(a, "plain")), B = c(toRef(a, "required")), h2 = c(toRef(a, "stacked")), v = c(toRef(a, "state")), w = c(toRef(a, "validated")), g = ref(null);
    qe(g, {
      initialValue: r.value
    }), provide(To, {
      set: (_) => {
        t("input", _), l.value = _, nextTick(() => {
          t("change", _);
        });
      },
      modelValue: computed(() => l.value),
      buttonVariant: readonly(toRef(a, "buttonVariant")),
      form: readonly(toRef(a, "form")),
      name: n,
      buttons: s,
      state: v,
      plain: m,
      size: readonly(toRef(a, "size")),
      inline: computed(() => !h2.value),
      required: B,
      disabled: f
    });
    const k = computed(
      () => a.options.map(
        (_, V) => typeof _ == "string" || typeof _ == "number" ? {
          props: {
            value: _,
            disabled: f.value
          },
          text: _.toString(),
          html: void 0,
          self: Symbol(`radioGroupOptionItem${V}`)
        } : {
          props: {
            value: _[a.valueField],
            disabled: _[a.disabledField],
            ..._.props ? _.props : {}
          },
          text: _[a.textField],
          html: _[a.htmlField],
          self: Symbol(`radioGroupOptionItem${V}`)
        }
      )
    ), y = computed(() => ({
      required: B.value,
      ariaInvalid: a.ariaInvalid,
      state: v.value,
      validated: w.value,
      buttons: s.value,
      stacked: h2.value,
      size: a.size
    })), $ = ln(y), b = on(y);
    return (_, V) => (openBlock(), createElementBlock("div", mergeProps(unref($), {
      id: unref(o),
      ref_key: "element",
      ref: g,
      role: "radiogroup",
      class: [unref(b), "bv-no-focus-ring"],
      tabindex: "-1"
    }), [
      renderSlot(_.$slots, "first"),
      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(k), (T) => (openBlock(), createBlock(Tn, mergeProps({
        key: T.self
      }, T.props), {
        default: withCtx(() => [
          T.html ? (openBlock(), createElementBlock("span", {
            key: 0,
            innerHTML: T.html
          }, null, 8, nd)) : (openBlock(), createElementBlock("span", {
            key: 1,
            textContent: toDisplayString(T.text)
          }, null, 8, sd))
        ]),
        _: 2
      }, 1040))), 128)),
      renderSlot(_.$slots, "default")
    ], 16, od));
  }
});
var rd = ["value", "disabled"];
var Xa = defineComponent({
  __name: "BFormSelectOption",
  props: {
    value: { default: void 0 },
    disabled: { default: false }
  },
  setup(e) {
    const a = c(toRef(e, "disabled"));
    return (l, o) => (openBlock(), createElementBlock("option", {
      value: e.value,
      disabled: unref(a)
    }, [
      renderSlot(l.$slots, "default")
    ], 8, rd));
  }
});
var ud = ["label"];
var xn = defineComponent({
  __name: "BFormSelectOptionGroup",
  props: {
    label: { default: void 0 },
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    options: { default: () => [] },
    textField: { default: "text" },
    valueField: { default: "value" }
  },
  setup(e) {
    const t = e, a = computed(
      () => Wa(t.options, "BFormSelectOptionGroup", t)
    );
    return (l, o) => (openBlock(), createElementBlock("optgroup", { label: e.label }, [
      renderSlot(l.$slots, "first"),
      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(a), (n, r) => (openBlock(), createBlock(Xa, mergeProps({
        key: r,
        value: n.value,
        disabled: n.disabled
      }, l.$attrs, {
        innerHTML: n.html || n.text
      }), null, 16, ["value", "disabled", "innerHTML"]))), 128)),
      renderSlot(l.$slots, "default")
    ], 8, ud));
  }
});
var dd = ["id", "name", "form", "multiple", "size", "disabled", "required", "aria-required", "aria-invalid"];
var cd = defineComponent({
  __name: "BFormSelect",
  props: {
    ariaInvalid: { default: void 0 },
    autofocus: { default: false },
    disabled: { default: false },
    disabledField: { default: "disabled" },
    form: { default: void 0 },
    htmlField: { default: "html" },
    id: { default: void 0 },
    labelField: { default: "label" },
    multiple: { default: false },
    name: { default: void 0 },
    options: { default: () => [] },
    optionsField: { default: "options" },
    plain: { default: false },
    required: { default: false },
    selectSize: { default: 0 },
    size: { default: void 0 },
    state: { default: null },
    textField: { default: "text" },
    valueField: { default: "value" },
    modelValue: { default: "" }
  },
  emits: ["input", "update:modelValue", "change"],
  setup(e, { emit: t }) {
    const a = e, l = Te(a, "modelValue", t), o = Ce(toRef(a, "id"), "input"), n = c(toRef(a, "autofocus")), r = c(toRef(a, "disabled")), s = c(toRef(a, "multiple")), f = c(toRef(a, "plain")), m = c(toRef(a, "required")), B = c(toRef(a, "state")), h2 = ref();
    qe(h2, {
      initialValue: n.value
    });
    const v = computed(() => ({
      "form-control": f.value,
      [`form-control-${a.size}`]: a.size && f.value,
      "form-select": !f.value,
      [`form-select-${a.size}`]: a.size && !f.value,
      "is-valid": B.value === true,
      "is-invalid": B.value === false
    })), w = computed(() => {
      if (a.selectSize || f.value)
        return a.selectSize;
    }), g = computed(
      () => ua(a.ariaInvalid, B.value)
    ), k = computed(() => Wa(a.options, "BFormSelect", a)), y = computed({
      get: () => l.value,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set: ($) => {
        t("change", $), l.value = $, t("input", $);
      }
    });
    return ($, b) => withDirectives((openBlock(), createElementBlock("select", mergeProps({
      id: unref(o),
      ref_key: "input",
      ref: h2
    }, $.$attrs, {
      "onUpdate:modelValue": b[0] || (b[0] = (_) => isRef(y) ? y.value = _ : null),
      class: unref(v),
      name: e.name,
      form: e.form || void 0,
      multiple: unref(s) || void 0,
      size: unref(w),
      disabled: unref(r),
      required: unref(m),
      "aria-required": unref(m) ? true : void 0,
      "aria-invalid": unref(g)
    }), [
      renderSlot($.$slots, "first"),
      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(k), (_, V) => (openBlock(), createElementBlock(Fragment, { key: V }, [
        Array.isArray(_.options) ? (openBlock(), createBlock(xn, {
          key: 0,
          label: _.label,
          options: _.options
        }, null, 8, ["label", "options"])) : (openBlock(), createBlock(Xa, {
          key: 1,
          value: _.value,
          disabled: _.disabled,
          innerHTML: _.html || _.text
        }, null, 8, ["value", "disabled", "innerHTML"]))
      ], 64))), 128)),
      renderSlot($.$slots, "default")
    ], 16, dd)), [
      [vModelSelect, unref(y)]
    ]);
  }
});
var fd = ["id"];
var An = defineComponent({
  __name: "BFormTag",
  props: {
    id: { default: void 0 },
    title: { default: void 0 },
    disabled: { default: false },
    noRemove: { default: false },
    pill: { default: false },
    removeLabel: { default: "Remove tag" },
    tag: { default: "span" },
    variant: { default: "secondary" }
  },
  emits: ["remove"],
  setup(e, { emit: t }) {
    const a = e, l = useSlots(), o = Ce(toRef(a, "id")), n = c(toRef(a, "disabled")), r = c(toRef(a, "noRemove")), s = c(toRef(a, "pill")), f = computed(
      () => {
        var h2;
        return ((((h2 = l.default) == null ? void 0 : h2.call(l)[0].children) ?? "").toString() || a.title) ?? "";
      }
    ), m = computed(() => `${o.value}taglabel__`), B = computed(() => [
      `bg-${a.variant}`,
      {
        "text-dark": ["warning", "info", "light"].includes(a.variant),
        "rounded-pill": s.value,
        disabled: n.value
      }
    ]);
    return (h2, v) => (openBlock(), createBlock(resolveDynamicComponent(e.tag), {
      id: unref(o),
      title: unref(f),
      class: normalizeClass(["badge b-form-tag d-inline-flex align-items-center mw-100", unref(B)]),
      "aria-labelledby": unref(m)
    }, {
      default: withCtx(() => [
        createBaseVNode("span", {
          id: unref(m),
          class: "b-form-tag-content flex-grow-1 text-truncate"
        }, [
          renderSlot(h2.$slots, "default", {}, () => [
            createTextVNode(toDisplayString(unref(f)), 1)
          ])
        ], 8, fd),
        !unref(n) && !unref(r) ? (openBlock(), createBlock(Tt, {
          key: 0,
          "aria-keyshortcuts": "Delete",
          "aria-label": e.removeLabel,
          class: "b-form-tag-remove",
          white: !["warning", "info", "light"].includes(e.variant),
          "aria-describedby": unref(m),
          "aria-controls": e.id,
          onClick: v[0] || (v[0] = (w) => t("remove", unref(f)))
        }, null, 8, ["aria-label", "white", "aria-describedby", "aria-controls"])) : createCommentVNode("", true)
      ]),
      _: 3
    }, 8, ["id", "title", "class", "aria-labelledby"]));
  }
});
var vd = ["id"];
var md = ["id", "for", "aria-live"];
var pd = ["id", "aria-live"];
var gd = ["id"];
var bd = ["aria-controls"];
var hd = {
  role: "group",
  class: "d-flex"
};
var yd = ["id", "disabled", "value", "type", "placeholder", "form", "required"];
var Bd = ["disabled"];
var $d = {
  "aria-live": "polite",
  "aria-atomic": "true"
};
var wd = {
  key: 0,
  class: "d-block invalid-feedback"
};
var kd = {
  key: 1,
  class: "form-text text-muted"
};
var Cd = {
  key: 2,
  class: "form-text text-muted"
};
var Sd = ["name", "value"];
var _d = defineComponent({
  __name: "BFormTags",
  props: {
    addButtonText: { default: "Add" },
    addButtonVariant: { default: "outline-secondary" },
    addOnChange: { default: false },
    autofocus: { default: false },
    disabled: { default: false },
    duplicateTagText: { default: "Duplicate tag(s)" },
    inputAttrs: { default: void 0 },
    inputClass: { default: void 0 },
    inputId: { default: void 0 },
    inputType: { default: "text" },
    invalidTagText: { default: "Invalid tag(s)" },
    form: { default: void 0 },
    limit: { default: void 0 },
    limitTagsText: { default: "Tag limit reached" },
    modelValue: { default: () => [] },
    name: { default: void 0 },
    noAddOnEnter: { default: false },
    noOuterFocus: { default: false },
    noTagRemove: { default: false },
    placeholder: { default: "Add tag..." },
    removeOnDelete: { default: false },
    required: { default: false },
    separator: { default: void 0 },
    state: { default: null },
    size: { default: void 0 },
    tagClass: { default: void 0 },
    tagPills: { default: false },
    tagRemoveLabel: { default: void 0 },
    tagRemovedLabel: { default: "Tag removed" },
    tagValidator: { type: Function, default: () => true },
    tagVariant: { default: "secondary" }
  },
  emits: ["update:modelValue", "input", "tag-state", "focus", "focusin", "focusout", "blur"],
  setup(e, { emit: t }) {
    const a = e, l = Te(a, "modelValue", t), o = Ce(), n = c(toRef(a, "addOnChange")), r = c(toRef(a, "autofocus")), s = c(toRef(a, "disabled")), f = c(toRef(a, "noAddOnEnter")), m = c(toRef(a, "noOuterFocus")), B = c(toRef(a, "noTagRemove")), h2 = c(toRef(a, "removeOnDelete")), v = c(toRef(a, "required")), w = c(toRef(a, "state")), g = c(toRef(a, "tagPills")), k = ref(null), { focused: y } = qe(k, {
      initialValue: r.value
    }), $ = computed(() => a.inputId || `${o.value}input__`), b = ref(l.value), _ = ref(""), V = ref(l.value.length > 0), T = ref(false), S = ref(""), O = ref([]), I = ref([]), C = ref([]), F = computed(() => ({
      [`form-control-${a.size}`]: a.size !== void 0,
      disabled: s.value,
      focus: T.value,
      "is-invalid": w.value === false,
      "is-valid": w.value === true
    })), P = computed(() => b.value.includes(_.value)), W = computed(
      () => _.value === "" ? false : !a.tagValidator(_.value)
    ), j = computed(() => b.value.length === a.limit), te = computed(() => !W.value && !P.value), X = computed(() => ({
      addButtonText: a.addButtonText,
      addButtonVariant: a.addButtonVariant,
      addTag: ve,
      disableAddButton: te.value,
      disabled: s.value,
      duplicateTagText: a.duplicateTagText,
      duplicateTags: C.value,
      form: a.form,
      inputAttrs: {
        ...a.inputAttrs,
        disabled: s.value,
        form: a.form,
        id: $,
        value: _
      },
      inputHandlers: {
        input: pe,
        keydown: ne,
        change: be
      },
      inputId: $,
      inputType: a.inputType,
      invalidTagText: a.invalidTagText,
      invalidTags: I.value,
      isDuplicate: P.value,
      isInvalid: W.value,
      isLimitReached: j.value,
      limitTagsText: a.limitTagsText,
      limit: a.limit,
      noTagRemove: B.value,
      placeholder: a.placeholder,
      removeTag: L,
      required: v.value,
      separator: a.separator,
      size: a.size,
      state: w.value,
      tagClass: a.tagClass,
      tagPills: g.value,
      tagRemoveLabel: a.tagRemoveLabel,
      tagVariant: a.tagVariant,
      tags: b.value
    }));
    watch(l, (z) => {
      b.value = z;
    });
    const q = (z) => {
      if (s.value) {
        z.target.blur();
        return;
      }
      t("focusin", z);
    }, ae = (z) => {
      s.value || m.value || (T.value = true, t("focus", z));
    }, me = (z) => {
      T.value = false, t("blur", z);
    }, pe = (z) => {
      var re, he;
      const ee = typeof z == "string" ? z : z.target.value;
      if (V.value = false, (re = a.separator) != null && re.includes(ee.charAt(0)) && ee.length > 0) {
        k.value && (k.value.value = "");
        return;
      }
      if (_.value = ee, (he = a.separator) != null && he.includes(ee.charAt(ee.length - 1))) {
        ve(ee.slice(0, ee.length - 1));
        return;
      }
      O.value = a.tagValidator(ee) && !P.value ? [ee] : [], I.value = a.tagValidator(ee) ? [] : [ee], C.value = P.value ? [ee] : [], t("tag-state", O.value, I.value, C.value);
    }, be = (z) => {
      n.value && (pe(z), P.value || ve(_.value));
    }, ne = (z) => {
      if (z.key === "Enter" && !f.value) {
        ve(_.value);
        return;
      }
      (z.key === "Backspace" || z.key === "Delete") && h2.value && _.value === "" && V.value && b.value.length > 0 ? L(b.value[b.value.length - 1]) : V.value = true;
    }, ve = (z) => {
      if (z = (z || _.value).trim(), z === "" || P.value || !a.tagValidator(z) || a.limit && j.value)
        return;
      const ee = [...l.value, z];
      _.value = "", V.value = true, l.value = ee, t("input", ee), y.value = true;
    }, L = (z) => {
      const ee = b.value.indexOf((z == null ? void 0 : z.toString()) ?? "");
      S.value = b.value.splice(ee, 1).toString(), l.value = b.value;
    };
    return (z, ee) => (openBlock(), createElementBlock("div", {
      id: unref(o),
      class: normalizeClass(["b-form-tags form-control h-auto", unref(F)]),
      role: "group",
      tabindex: "-1",
      onFocusin: q,
      onFocusout: ee[1] || (ee[1] = (re) => t("focusout", re))
    }, [
      createBaseVNode("output", {
        id: `${unref(o)}selected_tags__`,
        class: "visually-hidden",
        for: unref($),
        "aria-live": T.value ? "polite" : "off",
        "aria-atomic": "true",
        "aria-relevant": "additions text"
      }, toDisplayString(b.value.join(", ")), 9, md),
      createBaseVNode("div", {
        id: `${unref(o)}removed_tags__`,
        role: "status",
        "aria-live": T.value ? "assertive" : "off",
        "aria-atomic": "true",
        class: "visually-hidden"
      }, " (" + toDisplayString(e.tagRemovedLabel) + ") " + toDisplayString(S.value), 9, pd),
      renderSlot(z.$slots, "default", normalizeProps(guardReactiveProps(unref(X))), () => [
        createBaseVNode("ul", {
          id: `${unref(o)}tag_list__`,
          class: "b-form-tags-list list-unstyled mb-0 d-flex flex-wrap align-items-center"
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(b.value, (re, he) => renderSlot(z.$slots, "tag", normalizeProps(mergeProps({ key: he }, { tag: re, tagClass: e.tagClass, tagVariant: e.tagVariant, tagPills: unref(g), removeTag: L })), () => [
            (openBlock(), createBlock(An, {
              key: re,
              class: normalizeClass(e.tagClass),
              tag: "li",
              variant: e.tagVariant,
              pill: e.tagPills,
              onRemove: L
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(re), 1)
              ]),
              _: 2
            }, 1032, ["class", "variant", "pill"]))
          ])), 128)),
          createBaseVNode("li", {
            role: "none",
            "aria-live": "off",
            class: "b-from-tags-field flex-grow-1",
            "aria-controls": `${unref(o)}tag_list__`
          }, [
            createBaseVNode("div", hd, [
              createBaseVNode("input", mergeProps({
                id: unref($),
                ref_key: "input",
                ref: k,
                disabled: unref(s),
                value: _.value,
                type: e.inputType,
                placeholder: e.placeholder,
                class: "b-form-tags-input w-100 flex-grow-1 p-0 m-0 bg-transparent border-0",
                style: { outline: "currentcolor none 0px", "min-width": "5rem" }
              }, e.inputAttrs, {
                form: e.form,
                required: unref(v),
                onInput: pe,
                onChange: be,
                onKeydown: ne,
                onFocus: ae,
                onBlur: me
              }), null, 16, yd),
              unref(te) ? (openBlock(), createElementBlock("button", {
                key: 0,
                type: "button",
                class: normalizeClass(["btn b-form-tags-button py-0", [
                  `btn-${e.addButtonVariant}`,
                  {
                    "disabled invisible": _.value.length === 0
                  },
                  e.inputClass
                ]]),
                style: { "font-size": "90%" },
                disabled: unref(s) || _.value.length === 0 || unref(j),
                onClick: ee[0] || (ee[0] = (re) => ve(_.value))
              }, [
                renderSlot(z.$slots, "add-button-text", {}, () => [
                  createTextVNode(toDisplayString(e.addButtonText), 1)
                ])
              ], 10, Bd)) : createCommentVNode("", true)
            ])
          ], 8, bd)
        ], 8, gd),
        createBaseVNode("div", $d, [
          unref(W) ? (openBlock(), createElementBlock("div", wd, toDisplayString(e.invalidTagText) + ": " + toDisplayString(_.value), 1)) : createCommentVNode("", true),
          unref(P) ? (openBlock(), createElementBlock("small", kd, toDisplayString(e.duplicateTagText) + ": " + toDisplayString(_.value), 1)) : createCommentVNode("", true),
          b.value.length === e.limit ? (openBlock(), createElementBlock("small", Cd, "Tag limit reached")) : createCommentVNode("", true)
        ])
      ]),
      e.name ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(b.value, (re, he) => (openBlock(), createElementBlock("input", {
        key: he,
        type: "hidden",
        name: e.name,
        value: re
      }, null, 8, Sd))), 128)) : createCommentVNode("", true)
    ], 42, vd));
  }
});
var Td = defineComponent({
  props: {
    ...nn,
    noResize: { type: [Boolean, String], default: false },
    rows: { type: [String, Number], required: false, default: 2 },
    wrap: { type: String, default: "soft" }
  },
  emits: ["update:modelValue", "change", "blur", "input"],
  setup(e, { emit: t }) {
    const { input: a, computedId: l, computedAriaInvalid: o, onInput: n, onChange: r, onBlur: s, focus: f, blur: m } = sn(e, t), B = c(toRef(e, "noResize")), h2 = computed(() => ({
      "form-control": !e.plaintext,
      "form-control-plaintext": e.plaintext,
      [`form-control-${e.size}`]: !!e.size,
      "is-valid": e.state === true,
      "is-invalid": e.state === false
    })), v = computed(() => ({
      resize: B.value ? "none" : void 0
    }));
    return {
      input: a,
      computedId: l,
      computedAriaInvalid: o,
      onInput: n,
      onChange: r,
      onBlur: s,
      focus: f,
      blur: m,
      computedClasses: h2,
      computedStyles: v
    };
  }
});
var xd = ["id", "name", "form", "disabled", "placeholder", "required", "autocomplete", "readonly", "aria-required", "aria-invalid", "rows", "wrap"];
function Ad(e, t, a, l, o, n) {
  return openBlock(), createElementBlock("textarea", {
    id: e.computedId,
    ref: "input",
    class: normalizeClass(e.computedClasses),
    name: e.name || void 0,
    form: e.form || void 0,
    disabled: e.disabled,
    placeholder: e.placeholder,
    required: e.required,
    autocomplete: e.autocomplete || void 0,
    readonly: e.readonly || e.plaintext,
    "aria-required": e.required ? true : void 0,
    "aria-invalid": e.computedAriaInvalid,
    rows: e.rows,
    style: normalizeStyle(e.computedStyles),
    wrap: e.wrap || void 0,
    onInput: t[0] || (t[0] = (r) => e.onInput(r)),
    onChange: t[1] || (t[1] = (r) => e.onChange(r)),
    onBlur: t[2] || (t[2] = (r) => e.onBlur(r))
  }, null, 46, xd);
}
var Vd = ze(Td, [["render", Ad]]);
var Od = {
  key: 0,
  class: "input-group-text"
};
var Pd = ["innerHTML"];
var Ed = { key: 1 };
var Id = {
  key: 0,
  class: "input-group-text"
};
var Fd = ["innerHTML"];
var Ld = { key: 1 };
var Nd = defineComponent({
  __name: "BInputGroup",
  props: {
    append: { default: void 0 },
    appendHtml: { default: void 0 },
    id: { default: void 0 },
    prepend: { default: void 0 },
    prependHtml: { default: void 0 },
    size: { default: void 0 },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, a = computed(() => ({
      "input-group-sm": t.size === "sm",
      "input-group-lg": t.size === "lg"
    })), l = computed(() => !!t.append || !!t.appendHtml), o = computed(() => !!t.prepend || !!t.prependHtml);
    return (n, r) => (openBlock(), createBlock(resolveDynamicComponent(e.tag), {
      id: e.id,
      class: normalizeClass(["input-group", unref(a)]),
      role: "group"
    }, {
      default: withCtx(() => [
        renderSlot(n.$slots, "prepend", {}, () => [
          unref(o) ? (openBlock(), createElementBlock("span", Od, [
            e.prependHtml ? (openBlock(), createElementBlock("span", {
              key: 0,
              innerHTML: e.prependHtml
            }, null, 8, Pd)) : (openBlock(), createElementBlock("span", Ed, toDisplayString(e.prepend), 1))
          ])) : createCommentVNode("", true)
        ]),
        renderSlot(n.$slots, "default"),
        renderSlot(n.$slots, "append", {}, () => [
          unref(l) ? (openBlock(), createElementBlock("span", Id, [
            e.appendHtml ? (openBlock(), createElementBlock("span", {
              key: 0,
              innerHTML: e.appendHtml
            }, null, 8, Fd)) : (openBlock(), createElementBlock("span", Ld, toDisplayString(e.append), 1))
          ])) : createCommentVNode("", true)
        ])
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
});
var Vn = defineComponent({
  __name: "BInputGroupText",
  props: {
    tag: { default: "div" },
    text: { default: void 0 }
  },
  setup(e) {
    return (t, a) => (openBlock(), createBlock(resolveDynamicComponent(e.tag), { class: "input-group-text" }, {
      default: withCtx(() => [
        renderSlot(t.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(e.text), 1)
        ])
      ]),
      _: 3
    }));
  }
});
var Ja = defineComponent({
  __name: "BInputGroupAddon",
  props: {
    isText: { default: false }
  },
  setup(e) {
    const a = c(toRef(e, "isText"));
    return (l, o) => unref(a) ? (openBlock(), createBlock(Vn, { key: 0 }, {
      default: withCtx(() => [
        renderSlot(l.$slots, "default")
      ]),
      _: 3
    })) : renderSlot(l.$slots, "default", { key: 1 });
  }
});
var zd = defineComponent({
  __name: "BInputGroupAppend",
  props: {
    isText: { default: false }
  },
  setup(e) {
    return (t, a) => (openBlock(), createBlock(Ja, { "is-text": e.isText }, {
      default: withCtx(() => [
        renderSlot(t.$slots, "default")
      ]),
      _: 3
    }, 8, ["is-text"]));
  }
});
var Rd = defineComponent({
  __name: "BInputGroupPrepend",
  props: {
    isText: { default: false }
  },
  setup(e) {
    return (t, a) => (openBlock(), createBlock(Ja, { "is-text": e.isText }, {
      default: withCtx(() => [
        renderSlot(t.$slots, "default")
      ]),
      _: 3
    }, 8, ["is-text"]));
  }
});
var Hd = defineComponent({
  __name: "BListGroup",
  props: {
    flush: { default: false },
    horizontal: { type: [Boolean, String], default: false },
    numbered: { default: false },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, a = c(toRef(t, "flush")), l = c(toRef(t, "numbered")), o = computed(() => {
      const r = a.value ? false : t.horizontal;
      return {
        "list-group-flush": a.value,
        "list-group-horizontal": r === true,
        [`list-group-horizontal-${r}`]: typeof r == "string",
        "list-group-numbered": l.value
      };
    }), n = computed(() => l.value === true ? "ol" : t.tag);
    return provide(ko, {
      numbered: l
    }), (r, s) => (openBlock(), createBlock(resolveDynamicComponent(unref(n)), {
      class: normalizeClass(["list-group", unref(o)])
    }, {
      default: withCtx(() => [
        renderSlot(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
});
var Md = defineComponent({
  __name: "BListGroupItem",
  props: {
    action: { default: false },
    active: { default: false },
    button: { default: false },
    disabled: { default: false },
    href: { default: void 0 },
    tag: { default: "div" },
    target: { default: "_self" },
    to: { default: void 0 },
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = useAttrs(), l = inject(ko, null), o = c(toRef(t, "action")), n = c(toRef(t, "active")), r = c(toRef(t, "button")), s = c(toRef(t, "disabled")), f = computed(() => !r.value && (!!t.href || !!t.to)), m = computed(
      () => l != null && l.numbered.value ? "li" : r.value ? "button" : f.value ? Ne : t.tag
    ), B = computed(
      () => o.value || f.value || r.value || ["a", "router-link", "button", "b-link"].includes(t.tag)
    ), h2 = computed(() => ({
      [`list-group-item-${t.variant}`]: t.variant !== void 0,
      "list-group-item-action": B.value,
      active: n.value,
      disabled: s.value
    })), v = computed(() => {
      const w = {};
      return r.value && ((!a || !a.type) && (w.type = "button"), s.value && (w.disabled = true)), w;
    });
    return (w, g) => (openBlock(), createBlock(resolveDynamicComponent(unref(m)), mergeProps({
      class: ["list-group-item", unref(h2)],
      "aria-current": unref(n) ? true : void 0,
      "aria-disabled": unref(s) ? true : void 0,
      target: unref(f) ? e.target : void 0,
      href: unref(r) ? void 0 : e.href,
      to: unref(r) ? void 0 : e.to
    }, unref(v)), {
      default: withCtx(() => [
        renderSlot(w.$slots, "default")
      ]),
      _: 3
    }, 16, ["class", "aria-current", "aria-disabled", "target", "href", "to"]));
  }
});
var Dd = ["id", "aria-labelledby", "aria-describedby"];
var jd = ["id"];
var qd = {
  inheritAttrs: false
};
var Gd = defineComponent({
  ...qd,
  __name: "BModal",
  props: {
    bodyBgVariant: { default: void 0 },
    bodyClass: { default: void 0 },
    bodyTextVariant: { default: void 0 },
    busy: { default: false },
    lazy: { default: false },
    buttonSize: { default: "md" },
    cancelDisabled: { default: false },
    cancelTitle: { default: "Cancel" },
    cancelVariant: { default: "secondary" },
    centered: { default: false },
    contentClass: { default: void 0 },
    dialogClass: { default: void 0 },
    footerBgVariant: { default: void 0 },
    footerBorderVariant: { default: void 0 },
    footerClass: { default: void 0 },
    footerTextVariant: { default: void 0 },
    fullscreen: { type: [Boolean, String], default: false },
    headerBgVariant: { default: void 0 },
    headerBorderVariant: { default: void 0 },
    headerClass: { default: void 0 },
    headerCloseLabel: { default: "Close" },
    headerCloseWhite: { default: false },
    headerTextVariant: { default: void 0 },
    hideBackdrop: { default: false },
    hideFooter: { default: false },
    hideHeader: { default: false },
    hideHeaderClose: { default: false },
    id: { default: void 0 },
    modalClass: { default: void 0 },
    modelValue: { default: false },
    noCloseOnBackdrop: { default: false },
    noCloseOnEsc: { default: false },
    noFade: { default: false },
    autoFocus: { default: true },
    okDisabled: { default: false },
    okOnly: { default: false },
    okTitle: { default: "Ok" },
    okVariant: { default: "primary" },
    scrollable: { default: false },
    show: { default: false },
    size: { default: void 0 },
    title: { default: void 0 },
    titleClass: { default: void 0 },
    titleSrOnly: { default: false },
    titleTag: { default: "h5" },
    static: { default: false },
    autoFocusButton: { default: void 0 }
  },
  emits: ["update:modelValue", "show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "ok", "cancel", "close"],
  setup(e, { emit: t }) {
    const a = e, l = useSlots(), o = Ce(toRef(a, "id"), "modal"), n = Te(a, "modelValue", t), r = c(toRef(a, "busy")), s = c(toRef(a, "lazy")), f = c(toRef(a, "cancelDisabled")), m = c(toRef(a, "centered")), B = c(toRef(a, "hideBackdrop")), h2 = c(toRef(a, "hideFooter")), v = c(toRef(a, "hideHeader")), w = c(toRef(a, "hideHeaderClose")), g = c(n), k = c(toRef(a, "noCloseOnBackdrop")), y = c(toRef(a, "noCloseOnEsc")), $ = c(toRef(a, "noFade")), b = c(toRef(a, "autoFocus")), _ = c(toRef(a, "okDisabled")), V = c(toRef(a, "okOnly")), T = c(toRef(a, "scrollable")), S = c(toRef(a, "titleSrOnly")), O = c(toRef(a, "static")), I = Ni({
      attribute: "class",
      selector: "body",
      valueDark: "modal-open",
      valueLight: ""
    }), C = ref(null), F = ref(null), P = ref(null), W = ref(null), j = ref(g.value), te = ref(false), { focused: X } = qe(C, {
      initialValue: g.value && a.autoFocusButton === void 0
    }), { focused: q } = qe(F, {
      initialValue: g.value && a.autoFocusButton === "ok"
    }), { focused: ae } = qe(P, {
      initialValue: g.value && a.autoFocusButton === "cancel"
    }), { focused: me } = qe(W, {
      initialValue: g.value && a.autoFocusButton === "close"
    }), pe = computed(() => [
      a.modalClass,
      {
        fade: !$.value,
        show: j.value
      }
    ]), be = computed(
      () => s.value === false || s.value === true && te.value === true || s.value === true && g.value === true
    ), ne = computed(() => !Ve(l["header-close"])), ve = computed(() => [
      a.dialogClass,
      {
        "modal-fullscreen": a.fullscreen === true,
        [`modal-fullscreen-${a.fullscreen}-down`]: typeof a.fullscreen == "string",
        [`modal-${a.size}`]: a.size !== void 0,
        "modal-dialog-centered": m.value,
        "modal-dialog-scrollable": T.value
      }
    ]), L = computed(() => [
      a.bodyClass,
      {
        [`bg-${a.bodyBgVariant}`]: a.bodyBgVariant !== void 0,
        [`text-${a.bodyTextVariant}`]: a.bodyTextVariant !== void 0
      }
    ]), z = computed(() => [
      a.headerClass,
      {
        [`bg-${a.headerBgVariant}`]: a.headerBgVariant !== void 0,
        [`border-${a.headerBorderVariant}`]: a.headerBorderVariant !== void 0,
        [`text-${a.headerTextVariant}`]: a.headerTextVariant !== void 0
      }
    ]), ee = computed(() => [
      a.footerClass,
      {
        [`bg-${a.footerBgVariant}`]: a.footerBgVariant !== void 0,
        [`border-${a.footerBorderVariant}`]: a.footerBorderVariant !== void 0,
        [`text-${a.footerTextVariant}`]: a.footerTextVariant !== void 0
      }
    ]), re = computed(() => [
      a.titleClass,
      {
        ["visually-hidden"]: S.value
      }
    ]), he = computed(() => f.value || r.value), Oe = computed(() => _.value || r.value), U = (ue, oe = {}) => new Ft(ue, {
      cancelable: false,
      target: C.value || null,
      relatedTarget: null,
      trigger: null,
      ...oe,
      componentId: o.value
    }), ie = (ue = "") => {
      const oe = U("hide", { cancelable: ue !== "", trigger: ue });
      if (ue === "ok" && t(ue, oe), ue === "cancel" && t(ue, oe), ue === "close" && t(ue, oe), t("hide", oe), oe.defaultPrevented || ue === "backdrop" && k.value || ue === "esc" && y.value) {
        t("hide-prevented");
        return;
      }
      n.value = false;
    }, Re = () => {
      const ue = U("show", { cancelable: true });
      if (t("show", ue), ue.defaultPrevented) {
        n.value = false, t("show-prevented");
        return;
      }
      n.value = true;
    }, Ie = () => {
      b.value !== false && (a.autoFocusButton === "ok" ? q.value = true : a.autoFocusButton === "close" ? me.value = true : a.autoFocusButton === "cancel" ? ae.value = true : X.value = true);
    }, E = () => Re(), J = () => {
      j.value = true, Ie(), t("shown", U("shown")), s.value === true && (te.value = true);
    }, ge = () => j.value = false, G = () => {
      t("hidden", U("hidden")), s.value === true && (te.value = false);
    };
    return watch(
      j,
      (ue) => {
        I.value = ue;
      },
      { immediate: true }
    ), we(C, "bv-toggle", () => {
      g.value ? ie() : Re();
    }), (ue, oe) => (openBlock(), createBlock(Teleport, {
      to: "body",
      disabled: unref(O)
    }, [
      createVNode(_t, {
        "no-fade": true,
        "trans-props": { enterToClass: "show" },
        onBeforeEnter: E,
        onAfterEnter: J,
        onLeave: ge,
        onAfterLeave: G
      }, {
        default: withCtx(() => [
          withDirectives(createBaseVNode("div", mergeProps({
            id: unref(o),
            ref_key: "element",
            ref: C,
            class: ["modal", unref(pe)],
            role: "dialog",
            "aria-labelledby": `${unref(o)}-label`,
            "aria-describedby": `${unref(o)}-body`,
            tabindex: "-1"
          }, ue.$attrs, {
            onKeyup: oe[5] || (oe[5] = withKeys((et) => ie("esc"), ["esc"]))
          }), [
            createBaseVNode("div", {
              class: normalizeClass(["modal-dialog", unref(ve)])
            }, [
              unref(be) ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(["modal-content", e.contentClass])
              }, [
                unref(v) ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(["modal-header", unref(z)])
                }, [
                  renderSlot(ue.$slots, "header", {}, () => [
                    (openBlock(), createBlock(resolveDynamicComponent(e.titleTag), {
                      id: `${unref(o)}-label`,
                      class: normalizeClass(["modal-title", unref(re)])
                    }, {
                      default: withCtx(() => [
                        renderSlot(ue.$slots, "title", {}, () => [
                          createTextVNode(toDisplayString(e.title), 1)
                        ], true)
                      ]),
                      _: 3
                    }, 8, ["id", "class"])),
                    unref(w) ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                      unref(ne) ? (openBlock(), createElementBlock("button", {
                        key: 0,
                        type: "button",
                        onClick: oe[0] || (oe[0] = (et) => ie("close"))
                      }, [
                        renderSlot(ue.$slots, "header-close", {}, void 0, true)
                      ])) : (openBlock(), createBlock(Tt, {
                        key: 1,
                        ref_key: "closeButton",
                        ref: W,
                        "aria-label": e.headerCloseLabel,
                        white: e.headerCloseWhite,
                        onClick: oe[1] || (oe[1] = (et) => ie("close"))
                      }, null, 8, ["aria-label", "white"]))
                    ], 64))
                  ], true)
                ], 2)),
                createBaseVNode("div", {
                  id: `${unref(o)}-body`,
                  class: normalizeClass(["modal-body", unref(L)])
                }, [
                  renderSlot(ue.$slots, "default", {}, void 0, true)
                ], 10, jd),
                unref(h2) ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(["modal-footer", unref(ee)])
                }, [
                  renderSlot(ue.$slots, "footer", {}, () => [
                    renderSlot(ue.$slots, "cancel", {}, () => [
                      unref(V) ? createCommentVNode("", true) : (openBlock(), createBlock(kt, {
                        key: 0,
                        ref_key: "cancelButton",
                        ref: P,
                        type: "button",
                        class: "btn",
                        disabled: unref(he),
                        size: e.buttonSize,
                        variant: e.cancelVariant,
                        onClick: oe[2] || (oe[2] = (et) => ie("cancel"))
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(e.cancelTitle), 1)
                        ]),
                        _: 1
                      }, 8, ["disabled", "size", "variant"]))
                    ], true),
                    renderSlot(ue.$slots, "ok", {}, () => [
                      createVNode(kt, {
                        ref_key: "okButton",
                        ref: F,
                        type: "button",
                        class: "btn",
                        disabled: unref(Oe),
                        size: e.buttonSize,
                        variant: e.okVariant,
                        onClick: oe[3] || (oe[3] = (et) => ie("ok"))
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(e.okTitle), 1)
                        ]),
                        _: 1
                      }, 8, ["disabled", "size", "variant"])
                    ], true)
                  ], true)
                ], 2))
              ], 2)) : createCommentVNode("", true)
            ], 2),
            unref(B) ? createCommentVNode("", true) : renderSlot(ue.$slots, "backdrop", { key: 0 }, () => [
              createBaseVNode("div", {
                class: "modal-backdrop fade show",
                onClick: oe[4] || (oe[4] = (et) => ie("backdrop"))
              })
            ], true)
          ], 16, Dd), [
            [vShow, unref(g)]
          ])
        ]),
        _: 3
      })
    ], 8, ["disabled"]));
  }
});
var Wd = ze(Gd, [["__scopeId", "data-v-c766f542"]]);
var Ud = defineComponent({
  __name: "BNav",
  props: {
    align: { default: void 0 },
    cardHeader: { default: false },
    fill: { default: false },
    justified: { default: false },
    pills: { default: false },
    small: { default: false },
    tabs: { default: false },
    tag: { default: "ul" },
    vertical: { default: false }
  },
  setup(e) {
    const t = e, a = c(toRef(t, "cardHeader")), l = c(toRef(t, "fill")), o = c(toRef(t, "justified")), n = c(toRef(t, "pills")), r = c(toRef(t, "small")), s = c(toRef(t, "tabs")), f = c(toRef(t, "vertical")), m = zt(toRef(t, "align")), B = computed(() => ({
      "nav-tabs": s.value,
      "nav-pills": n.value && !s.value,
      "card-header-tabs": !f.value && a.value && s.value,
      "card-header-pills": !f.value && a.value && n.value && !s.value,
      "flex-column": f.value,
      "nav-fill": !f.value && l.value,
      "nav-justified": !f.value && o.value,
      [m.value]: !f.value && t.align !== void 0,
      small: r.value
    }));
    return (h2, v) => (openBlock(), createBlock(resolveDynamicComponent(e.tag), {
      class: normalizeClass(["nav", unref(B)])
    }, {
      default: withCtx(() => [
        renderSlot(h2.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
});
var Kd = defineComponent({
  __name: "BNavForm",
  props: {
    role: { default: void 0 },
    id: { default: void 0 },
    floating: { default: false },
    novalidate: { default: false },
    validated: { default: false }
  },
  emits: ["submit"],
  setup(e, { emit: t }) {
    const a = e, l = computed(() => ({
      floating: a.floating,
      role: a.role,
      id: a.id,
      novalidate: a.novalidate,
      validated: a.validated
    })), o = (n) => t("submit", n);
    return (n, r) => (openBlock(), createBlock(kn, mergeProps(unref(l), {
      class: "d-flex",
      onSubmit: withModifiers(o, ["prevent"])
    }), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["onSubmit"]));
  }
});
var Xd = defineComponent({
  components: { BLink: Ne },
  props: {
    ...Lt(mt, ["event", "routerTag"])
  },
  setup(e) {
    return { disabledBoolean: c(toRef(e, "disabled")) };
  }
});
var Jd = { class: "nav-item" };
function Yd(e, t, a, l, o, n) {
  const r = resolveComponent("b-link");
  return openBlock(), createElementBlock("li", Jd, [
    createVNode(r, mergeProps({ class: "nav-link" }, e.$props, {
      "active-class": "active",
      tabindex: e.disabledBoolean ? -1 : void 0,
      "aria-disabled": e.disabledBoolean ? true : void 0
    }), {
      default: withCtx(() => [
        renderSlot(e.$slots, "default")
      ]),
      _: 3
    }, 16, ["tabindex", "aria-disabled"])
  ]);
}
var Zd = ze(Xd, [["render", Yd]]);
var Qd = { class: "nav-item dropdown" };
var ec = defineComponent({
  __name: "BNavItemDropdown",
  props: {
    id: { default: void 0 },
    text: { default: void 0 },
    toggleClass: { default: void 0 },
    size: { default: void 0 },
    offset: { default: void 0 },
    autoClose: { type: [Boolean, String], default: void 0 },
    dark: { default: void 0 },
    splitVariant: { default: void 0 },
    noCaret: { default: void 0 },
    variant: { default: "link" },
    modelValue: { default: false },
    lazy: { default: void 0 },
    strategy: { default: void 0 },
    floatingMiddleware: { default: void 0 },
    noFlip: { default: void 0 },
    noShift: { default: void 0 },
    dropup: { default: void 0 },
    dropend: { default: void 0 },
    dropstart: { default: void 0 },
    center: null,
    end: null,
    menuClass: { default: void 0 }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const a = e, l = Te(a, "modelValue", t), o = c(l), n = computed({
      get: () => o.value,
      set: (s) => l.value = s
    }), r = computed(() => Lt(a, ["modelValue"]));
    return (s, f) => (openBlock(), createElementBlock("li", Qd, [
      createVNode(wn, mergeProps({
        modelValue: unref(n),
        "onUpdate:modelValue": f[0] || (f[0] = (m) => isRef(n) ? n.value = m : null)
      }, unref(r), { "is-nav": "" }), {
        "button-content": withCtx(() => [
          renderSlot(s.$slots, "button-content")
        ]),
        "toggle-text": withCtx(() => [
          renderSlot(s.$slots, "toggle-text")
        ]),
        default: withCtx(() => [
          renderSlot(s.$slots, "default")
        ]),
        _: 3
      }, 16, ["modelValue"])
    ]));
  }
});
var tc = { class: "navbar-text" };
var ac = defineComponent({
  __name: "BNavText",
  props: {
    text: { default: void 0 }
  },
  setup(e) {
    return (t, a) => (openBlock(), createElementBlock("li", tc, [
      renderSlot(t.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(e.text), 1)
      ])
    ]));
  }
});
var lc = defineComponent({
  __name: "BNavbar",
  props: {
    fixed: { default: void 0 },
    print: { default: false },
    sticky: { default: void 0 },
    tag: { default: "nav" },
    toggleable: { type: [Boolean, String], default: false },
    dark: { default: false },
    variant: { default: void 0 },
    container: { type: [String, Boolean], default: "fluid" }
  },
  setup(e) {
    const t = e, a = c(toRef(t, "print")), l = c(toRef(t, "dark")), o = computed(
      () => t.tag === "nav" ? void 0 : "navigation"
    ), n = computed(
      () => typeof t.toggleable == "string" ? `navbar-expand-${t.toggleable}` : t.toggleable === false ? "navbar-expand" : void 0
    ), r = computed(
      () => t.container === true ? "container" : "container-fluid"
    ), s = computed(() => ({
      "d-print": a.value,
      [`sticky-${t.sticky}`]: t.sticky !== void 0,
      "navbar-dark": l.value,
      [`bg-${t.variant}`]: t.variant !== void 0,
      [`fixed-${t.fixed}`]: t.fixed !== void 0,
      [`${n.value}`]: n.value !== void 0
    }));
    return (f, m) => (openBlock(), createBlock(resolveDynamicComponent(e.tag), {
      class: normalizeClass(["navbar", unref(s)]),
      role: unref(o)
    }, {
      default: withCtx(() => [
        e.container !== false ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(unref(r))
        }, [
          renderSlot(f.$slots, "default")
        ], 2)) : renderSlot(f.$slots, "default", { key: 1 })
      ]),
      _: 3
    }, 8, ["class", "role"]));
  }
});
var zl = Lt(mt, ["event", "routerTag"]);
var oc = defineComponent({
  components: {
    BLink: Ne
  },
  props: {
    tag: { type: String, default: "div" },
    ...zl
  },
  setup(e) {
    const t = computed(() => Et(e)), a = computed(
      () => t.value ? Ne : e.tag
    );
    return {
      computedLinkProps: computed(
        () => t.value ? Ha(e, zl) : {}
      ),
      computedTag: a
    };
  }
});
function nc(e, t, a, l, o, n) {
  return openBlock(), createBlock(resolveDynamicComponent(e.computedTag), mergeProps({ class: "navbar-brand" }, e.computedLinkProps), {
    default: withCtx(() => [
      renderSlot(e.$slots, "default")
    ]),
    _: 3
  }, 16);
}
var sc = ze(oc, [["render", nc]]);
var ic = defineComponent({
  __name: "BNavbarNav",
  props: {
    align: { default: void 0 },
    fill: { default: false },
    justified: { default: false },
    small: { default: false },
    tag: { default: "ul" }
  },
  setup(e) {
    const t = e, a = c(toRef(t, "fill")), l = c(toRef(t, "justified")), o = c(toRef(t, "small")), n = zt(toRef(t, "align")), r = computed(() => ({
      "nav-fill": a.value,
      "nav-justified": l.value,
      [n.value]: t.align !== void 0,
      small: o.value
    }));
    return (s, f) => (openBlock(), createElementBlock("ul", {
      class: normalizeClass(["navbar-nav", unref(r)])
    }, [
      renderSlot(s.$slots, "default")
    ], 2));
  }
});
var Rl = (e, t) => e.setAttribute("data-bs-theme", t);
var rc = {
  mounted(e, t) {
    Rl(e, t.value);
  },
  updated(e, t) {
    Rl(e, t.value);
  }
};
var Ya = (e, t) => {
  const { modifiers: a, arg: l, value: o } = e, n = Object.keys(a || {}), r = typeof o == "string" ? o.split(jt) : o;
  if (ks(t.tagName, "a")) {
    const s = Ra(t, "href") || "";
    ls.test(s) && n.push(s.replace(as, ""));
  }
  return Array.prototype.concat.apply([], [l, r]).forEach((s) => typeof s == "string" && n.push(s)), n.filter((s, f, m) => s && m.indexOf(s) === f);
};
var uc = (e, t) => {
  Ya(e, t).forEach((l) => {
    const o = document.getElementById(l);
    o !== null && o.dispatchEvent(new Event("bv-toggle"));
  }), setTimeout(() => On(e, t), 50);
};
var On = (e, t) => {
  const a = Ya(e, t);
  let l = false;
  a.forEach((o) => {
    const n = document.getElementById(o);
    n != null && n.classList.contains("show") && (l = true), n != null && n.classList.contains("closing") && (l = false);
  }), t.setAttribute("aria-expanded", l ? "true" : "false");
};
var Oa = {
  mounted(e, t) {
    e.__toggle = () => uc(t, e), e.addEventListener("click", e.__toggle), On(t, e), e.setAttribute("aria-controls", Ya(t, e).join(" "));
  },
  unmounted(e) {
    e.removeEventListener("click", e.__toggle), e.removeAttribute("aria-controls"), e.removeAttribute("aria-expanded");
  }
};
var dc = {
  mounted(e, t) {
    const a = aa(t.value, e);
    e.$__state = ref({
      ...la(t, e),
      ...a
    }), rn(e, t);
  },
  updated(e, t) {
    const a = aa(t.value, e);
    e.$__state && (e.$__state.value = {
      ...la(t, e),
      ...a
    });
  },
  beforeUnmount(e) {
    un(e);
  }
};
var cc = {
  mounted(e, t) {
    const a = aa(t.value, e);
    e.$__state = ref({
      ...la(t, e),
      title: a.title ?? a.content ?? "",
      tooltip: true
    }), rn(e, t);
  },
  updated(e, t) {
    const a = aa(t.value, e);
    e.$__state && (e.$__state.value = {
      ...la(t, e),
      title: a.title ?? a.content ?? "",
      tooltip: true
    });
  },
  beforeUnmount(e) {
    un(e);
  }
};
var fc = createBaseVNode("span", { class: "navbar-toggler-icon" }, null, -1);
var vc = defineComponent({
  __name: "BNavbarToggle",
  props: {
    disabled: { default: false },
    label: { default: "Toggle navigation" },
    target: { default: void 0 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = e, l = c(toRef(a, "disabled")), o = computed(() => ({
      disabled: l.value,
      "aria-label": a.label
    })), n = computed(() => ({
      disabled: l.value
    })), r = (s) => {
      l.value || t("click", s);
    };
    return (s, f) => withDirectives((openBlock(), createElementBlock("button", mergeProps({
      class: ["navbar-toggler", unref(n)],
      type: "button"
    }, unref(o), { onClick: r }), [
      renderSlot(s.$slots, "default", {}, () => [
        fc
      ])
    ], 16)), [
      [unref(Oa), unref(l) ? void 0 : e.target]
    ]);
  }
});
var Pn = defineComponent({
  __name: "BOverlay",
  props: {
    bgColor: { default: void 0 },
    blur: { default: "2px" },
    fixed: { default: false },
    noCenter: { default: false },
    noFade: { default: false },
    noWrap: { default: false },
    opacity: { default: 0.85 },
    overlayTag: { default: "div" },
    rounded: { type: [Boolean, String], default: false },
    show: { default: false },
    spinnerSmall: { default: false },
    spinnerType: { default: "border" },
    spinnerVariant: { default: void 0 },
    noSpinner: { default: false },
    variant: { default: "light" },
    wrapTag: { default: "div" },
    zIndex: { default: 10 }
  },
  emits: ["click", "hidden", "shown"],
  setup(e, { emit: t }) {
    const a = e, l = { top: 0, left: 0, bottom: 0, right: 0 }, o = c(toRef(a, "fixed")), n = c(toRef(a, "noSpinner")), r = c(toRef(a, "noCenter")), s = c(toRef(a, "noWrap")), f = c(toRef(a, "show")), m = c(toRef(a, "spinnerSmall")), B = computed(
      () => a.rounded === true || a.rounded === "" ? "rounded" : a.rounded === false ? "" : `rounded-${a.rounded}`
    ), h2 = computed(
      () => a.variant && !a.bgColor ? `bg-${a.variant}` : ""
    ), v = computed(() => f.value ? true : null), w = computed(() => ({
      type: a.spinnerType || void 0,
      variant: a.spinnerVariant || void 0,
      small: m.value
    })), g = computed(() => ({
      ...l,
      zIndex: a.zIndex || 10
    })), k = computed(() => [
      "b-overlay",
      {
        "position-absolute": !s.value || !o.value,
        "position-fixed": s.value && o.value
      }
    ]), y = computed(() => [h2.value, B.value]), $ = computed(() => ({
      ...l,
      opacity: a.opacity,
      backgroundColor: a.bgColor || void 0,
      backdropFilter: blur ? `blur(${blur})` : void 0
    })), b = computed(
      () => r.value ? l : {
        top: "50%",
        left: "50%",
        transform: "translateX(-50%) translateY(-50%)"
      }
    );
    return (_, V) => (openBlock(), createBlock(resolveDynamicComponent(e.wrapTag), {
      class: "b-overlay-wrap position-relative",
      "aria-busy": unref(v)
    }, {
      default: withCtx(() => [
        renderSlot(_.$slots, "default"),
        createVNode(_t, {
          "no-fade": e.noFade,
          "trans-props": { enterToClass: "show" },
          name: "fade",
          onOnAfterEnter: V[1] || (V[1] = (T) => t("shown")),
          onOnAfterLeave: V[2] || (V[2] = (T) => t("hidden"))
        }, {
          default: withCtx(() => [
            unref(f) ? (openBlock(), createBlock(resolveDynamicComponent(e.overlayTag), {
              key: 0,
              class: normalizeClass(unref(k)),
              style: normalizeStyle(unref(g)),
              onClick: V[0] || (V[0] = (T) => t("click", T))
            }, {
              default: withCtx(() => [
                createBaseVNode("div", {
                  class: normalizeClass(["position-absolute", unref(y)]),
                  style: normalizeStyle(unref($))
                }, null, 6),
                createBaseVNode("div", {
                  class: "position-absolute",
                  style: normalizeStyle(unref(b))
                }, [
                  renderSlot(_.$slots, "overlay", normalizeProps(guardReactiveProps(unref(w))), () => [
                    unref(n) ? createCommentVNode("", true) : (openBlock(), createBlock(fa, normalizeProps(mergeProps({ key: 0 }, unref(w))), null, 16))
                  ])
                ], 4)
              ]),
              _: 3
            }, 8, ["class", "style"])) : createCommentVNode("", true)
          ]),
          _: 3
        }, 8, ["no-fade"])
      ]),
      _: 3
    }, 8, ["aria-busy"]));
  }
});
var mc = {
  key: 0,
  class: "offcanvas-header"
};
var pc = {
  id: "offcanvasLabel",
  class: "offcanvas-title"
};
var gc = { class: "offcanvas-body" };
var bc = { key: 1 };
var hc = {
  inheritAttrs: false
};
var yc = defineComponent({
  ...hc,
  __name: "BOffcanvas",
  props: {
    dismissLabel: { default: "Close" },
    modelValue: { default: false },
    bodyScrolling: { default: false },
    backdrop: { default: true },
    noCloseOnBackdrop: { default: false },
    noCloseOnEsc: { default: false },
    placement: { default: "start" },
    title: { default: void 0 },
    noHeaderClose: { default: false },
    noHeader: { default: false },
    lazy: { default: false },
    id: { default: void 0 },
    noFocus: { default: false },
    static: { default: false },
    backdropVariant: { default: "dark" }
  },
  emits: ["update:modelValue", "show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "esc", "close"],
  setup(e, { emit: t }) {
    const a = e, l = useSlots(), o = Te(a, "modelValue", t), n = c(o);
    c(toRef(a, "bodyScrolling"));
    const r = c(toRef(a, "backdrop")), s = c(toRef(a, "noHeaderClose")), f = c(toRef(a, "noHeader")), m = c(toRef(a, "noFocus")), B = c(toRef(a, "noCloseOnBackdrop")), h2 = c(toRef(a, "noCloseOnEsc")), v = c(toRef(a, "lazy")), w = c(toRef(a, "static")), g = Ce(toRef(a, "id"), "offcanvas"), k = ref(null), { focused: y } = qe(k, {
      initialValue: n.value && m.value === false
    }), $ = ref(n.value), b = ref(false), _ = computed(
      () => r.value === true && n.value === true
    ), V = computed(
      () => v.value === false || v.value === true && b.value === true || v.value === true && n.value === true
    ), T = computed(() => !Ve(l.footer)), S = computed(() => [
      // props.responsive === undefined ? 'offcanvas' : `offcanvas-${props.responsive}`,
      "offcanvas",
      // Remove when above check is fixed
      `offcanvas-${a.placement}`,
      {
        show: n.value && $.value === true
      }
    ]), O = (X, q = {}) => new Ft(X, {
      cancelable: false,
      target: k.value || null,
      relatedTarget: null,
      trigger: null,
      ...q,
      componentId: g.value
    }), I = (X = "") => {
      const q = O("hide", { cancelable: X !== "", trigger: X });
      if (X === "close" && t(X, q), X === "esc" && t(X, q), t("hide", q), q.defaultPrevented || X === "backdrop" && B.value || X === "esc" && h2.value) {
        t("hide-prevented");
        return;
      }
      o.value = false;
    }, C = () => {
      const X = O("show", { cancelable: true });
      if (t("show", X), X.defaultPrevented) {
        o.value = false, t("show-prevented");
        return;
      }
      o.value = true;
    }, F = () => {
      nextTick(() => {
        m.value === false && (y.value = true);
      });
    }, P = () => C(), W = () => {
      $.value = true, F(), t("shown", O("shown")), v.value === true && (b.value = true);
    }, j = () => $.value = false, te = () => {
      t("hidden", O("hidden")), v.value === true && (b.value = false);
    };
    return we(k, "bv-toggle", () => {
      n.value ? I() : C();
    }), (X, q) => (openBlock(), createBlock(Teleport, {
      to: "body",
      disabled: unref(w)
    }, [
      createVNode(_t, {
        "no-fade": true,
        "trans-props": {
          enterToClass: "showing",
          enterFromClass: "",
          leaveToClass: "hiding show",
          leaveFromClass: "show"
        },
        onBeforeEnter: P,
        onAfterEnter: W,
        onLeave: j,
        onAfterLeave: te
      }, {
        default: withCtx(() => [
          withDirectives(createBaseVNode("div", mergeProps({
            ref_key: "element",
            ref: k,
            "aria-modal": "true",
            role: "dialog",
            class: unref(S),
            tabindex: "-1",
            "aria-labelledby": "offcanvasLabel",
            "data-bs-backdrop": "false"
          }, X.$attrs, {
            onKeyup: q[1] || (q[1] = withKeys((ae) => I("esc"), ["esc"]))
          }), [
            unref(V) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              unref(f) ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", mc, [
                renderSlot(X.$slots, "header", normalizeProps(guardReactiveProps({ visible: unref(n), placement: e.placement, hide: I })), () => [
                  createBaseVNode("h5", pc, [
                    renderSlot(X.$slots, "title", {}, () => [
                      createTextVNode(toDisplayString(e.title), 1)
                    ])
                  ]),
                  unref(s) ? createCommentVNode("", true) : (openBlock(), createBlock(Tt, {
                    key: 0,
                    class: "text-reset",
                    "aria-label": e.dismissLabel,
                    onClick: q[0] || (q[0] = (ae) => I("close"))
                  }, null, 8, ["aria-label"]))
                ])
              ])),
              createBaseVNode("div", gc, [
                renderSlot(X.$slots, "default")
              ]),
              unref(T) ? (openBlock(), createElementBlock("div", bc, [
                renderSlot(X.$slots, "footer", normalizeProps(guardReactiveProps({ visible: unref(n), placement: e.placement, hide: I })))
              ])) : createCommentVNode("", true)
            ], 64)) : createCommentVNode("", true)
          ], 16), [
            [vShow, unref(o)]
          ])
        ]),
        _: 3
      }),
      createVNode(Pn, {
        variant: e.backdropVariant,
        show: unref(_),
        fixed: true,
        "no-wrap": "",
        "no-spinner": true,
        onClick: q[2] || (q[2] = (ae) => I("backdrop"))
      }, null, 8, ["variant", "show"])
    ], 8, ["disabled"]));
  }
});
var Bc = 5;
var En = 20;
var In = 0;
var Ue = 3;
var $c = "ellipsis-text";
var wc = "first-text";
var kc = "last-text";
var Cc = "next-text";
var Sc = "page";
var _c = "prev-text";
var Hl = (e) => Math.max(lt(e) || En, 1);
var Ml = (e) => Math.max(lt(e) || In, 0);
var Tc = (e, t) => {
  const a = lt(e) || 1;
  return a > t ? t : a < 1 ? 1 : a;
};
var xc = defineComponent({
  name: "BPagination",
  props: {
    align: { type: String, default: "start" },
    ariaControls: { type: String, default: void 0 },
    ariaLabel: { type: String, default: "Pagination" },
    disabled: { type: [Boolean, String], default: false },
    ellipsisClass: { type: [Array, String], default: () => [] },
    ellipsisText: { type: String, default: "â¦" },
    firstClass: { type: [Array, String], default: () => [] },
    firstNumber: { type: [Boolean, String], default: false },
    firstText: { type: String, default: "Â«" },
    hideEllipsis: { type: [Boolean, String], default: false },
    hideGotoEndButtons: { type: [Boolean, String], default: false },
    labelFirstPage: { type: String, default: "Go to first page" },
    labelLastPage: { type: String, default: "Go to last page" },
    labelNextPage: { type: String, default: "Go to next page" },
    labelPage: { type: String, default: "Go to page" },
    labelPrevPage: { type: String, default: "Go to previous page" },
    lastClass: { type: [Array, String], default: () => [] },
    lastNumber: { type: [Boolean, String], default: false },
    lastText: { type: String, default: "Â»" },
    limit: { type: Number, default: Bc },
    modelValue: { type: Number, default: 1 },
    // V-model prop
    nextClass: { type: [Array, String], default: () => [] },
    nextText: { type: String, default: "âº" },
    pageClass: { type: [Array, String], default: () => [] },
    perPage: { type: Number, default: En },
    pills: { type: [Boolean, String], default: false },
    prevClass: { type: [Array, String], default: () => [] },
    prevText: { type: String, default: "â¹" },
    size: { type: String, default: void 0 },
    totalRows: { type: Number, default: In }
  },
  emits: ["update:modelValue", "page-click"],
  setup(e, { emit: t, slots: a }) {
    const l = Te(e, "modelValue", t), o = c(toRef(e, "disabled")), n = c(toRef(e, "firstNumber")), r = c(toRef(e, "hideEllipsis")), s = c(toRef(e, "hideGotoEndButtons")), f = c(toRef(e, "lastNumber")), m = c(toRef(e, "pills")), B = computed(
      () => e.align === "fill" ? "start" : e.align
    ), h2 = zt(toRef(B, "value")), v = computed(
      () => Math.ceil(Ml(e.totalRows) / Hl(e.perPage))
    ), w = computed(() => {
      let S;
      return v.value - l.value + 2 < e.limit && e.limit > Ue ? S = v.value - k.value + 1 : S = l.value - Math.floor(k.value / 2), S < 1 ? S = 1 : S > v.value - k.value && (S = v.value - k.value + 1), e.limit <= Ue && f.value && v.value === S + k.value - 1 && (S = Math.max(S - 1, 1)), S;
    }), g = computed(() => {
      const S = v.value - l.value;
      let O = false;
      return S + 2 < e.limit && e.limit > Ue ? e.limit > Ue && (O = true) : e.limit > Ue && (O = !!(!r.value || n.value)), w.value <= 1 && (O = false), O && n.value && w.value < 4 && (O = false), O;
    }), k = computed(() => {
      let S = e.limit;
      return v.value <= e.limit ? S = v.value : l.value < e.limit - 1 && e.limit > Ue ? ((!r.value || f.value) && (S = e.limit - (n.value ? 0 : 1)), S = Math.min(S, e.limit)) : v.value - l.value + 2 < e.limit && e.limit > Ue ? (!r.value || n.value) && (S = e.limit - (f.value ? 0 : 1)) : e.limit > Ue && (S = e.limit - (r.value ? 0 : 2)), S;
    }), y = computed(() => {
      const S = v.value - k.value;
      let O = false;
      l.value < e.limit - 1 && e.limit > Ue ? (!r.value || f.value) && (O = true) : e.limit > Ue && (O = !!(!r.value || f.value)), w.value > S && (O = false);
      const I = w.value + k.value - 1;
      return O && f.value && I > v.value - 3 && (O = false), O;
    }), $ = reactive({
      pageSize: Hl(e.perPage),
      totalRows: Ml(e.totalRows),
      numberOfPages: v.value
    }), b = (S, O) => {
      if (O === l.value)
        return;
      const { target: I } = S, C = new Xe("page-click", {
        cancelable: true,
        target: I
      });
      t("page-click", C, O), !C.defaultPrevented && (l.value = O);
    }, _ = computed(() => e.size ? `pagination-${e.size}` : ""), V = computed(() => m.value ? "b-pagination-pills" : "");
    watch(l, (S) => {
      const O = Tc(S, v.value);
      O !== l.value && (l.value = O);
    }), watch($, (S, O) => {
      S != null && (O.pageSize !== S.pageSize && O.totalRows === S.totalRows || O.numberOfPages !== S.numberOfPages && l.value > O.numberOfPages) && (l.value = 1);
    });
    const T = computed(() => {
      const S = [];
      for (let O = 0; O < k.value; O++)
        S.push({ number: w.value + O, classes: null });
      return S;
    });
    return () => {
      const S = [], O = T.value.map((q) => q.number), I = (q) => q === l.value, C = l.value < 1, F = e.align === "fill", P = (q, ae, me, pe, be, ne) => {
        const ve = o.value || I(ne) || C || q < 1 || q > v.value, L = q < 1 ? 1 : q > v.value ? v.value : q, z = { disabled: ve, page: L, index: L - 1 }, ee = De(me, z, a) || pe || "";
        return h(
          "li",
          {
            class: [
              "page-item",
              {
                disabled: ve,
                "flex-fill": F,
                "d-flex": F && !ve
              },
              be
            ]
          },
          // render inner content
          h(
            ve ? "span" : "button",
            {
              class: ["page-link", { "flex-grow-1": !ve && F }],
              "aria-label": ae,
              "aria-controls": e.ariaControls || null,
              "aria-disabled": ve ? true : null,
              role: "menuitem",
              type: ve ? null : "button",
              tabindex: ve ? null : "-1",
              onClick: (re) => {
                ve || b(re, L);
              }
            },
            ee
          )
        );
      }, W = (q) => h(
        "li",
        {
          class: [
            "page-item",
            "disabled",
            "bv-d-xs-down-none",
            F ? "flex-fill" : "",
            e.ellipsisClass
          ],
          role: "separator",
          key: `ellipsis-${q ? "last" : "first"}`
        },
        [
          h(
            "span",
            { class: ["page-link"] },
            De($c, {}, a) || e.ellipsisText || "..."
          )
        ]
      ), j = (q, ae) => {
        const me = I(q.number) && !C, pe = o.value ? null : me || C && ae === 0 ? "0" : "-1", be = {
          active: me,
          disabled: o.value,
          page: q.number,
          index: q.number - 1,
          content: q.number
        }, ne = De(Sc, be, a) || q.number, ve = h(
          o.value ? "span" : "button",
          {
            class: ["page-link", { "flex-grow-1": !o.value && F }],
            "aria-controls": e.ariaControls || null,
            "aria-disabled": o.value ? true : null,
            "aria-label": e.labelPage ? `${e.labelPage} ${q.number}` : null,
            role: "menuitemradio",
            type: o.value ? null : "button",
            tabindex: pe,
            onClick: (L) => {
              o.value || b(L, q.number);
            }
          },
          ne
        );
        return h(
          "li",
          {
            class: [
              "page-item",
              {
                disabled: o.value,
                active: me,
                "flex-fill": F,
                "d-flex": F && !o.value
              },
              e.pageClass
            ],
            role: "presentation",
            key: `page-${q.number}`
          },
          ve
        );
      };
      if (!s.value && !n.value) {
        const q = P(
          1,
          e.labelFirstPage,
          wc,
          e.firstText,
          e.firstClass,
          1
        );
        S.push(q);
      }
      const te = P(
        l.value - 1,
        e.labelFirstPage,
        _c,
        e.prevText,
        e.prevClass,
        1
      );
      S.push(te), n.value && O[0] !== 1 && S.push(j({ number: 1 }, 0)), g.value && S.push(W(false)), T.value.forEach((q, ae) => {
        const me = g.value && n.value && O[0] !== 1 ? 1 : 0;
        S.push(j(q, ae + me));
      }), y.value && S.push(W(true)), f.value && O[O.length - 1] !== v.value && S.push(j({ number: v.value }, -1));
      const X = P(
        l.value + 1,
        e.labelNextPage,
        Cc,
        e.nextText,
        e.nextClass,
        v.value
      );
      if (S.push(X), !f.value && !s.value) {
        const q = P(
          v.value,
          e.labelLastPage,
          kc,
          e.lastText,
          e.lastClass,
          v.value
        );
        S.push(q);
      }
      return h(
        "ul",
        {
          class: ["pagination", _.value, h2.value, V.value],
          role: "menubar",
          "aria-disabled": o.value,
          "aria-label": e.ariaLabel || null
        },
        S
      );
    };
  }
});
var Ac = {
  inheritAttrs: false
};
var Me = defineComponent({
  ...Ac,
  __name: "BPlaceholder",
  props: {
    tag: { default: "span" },
    wrapperTag: { default: "span" },
    width: { default: void 0 },
    cols: { default: 12 },
    variant: { default: void 0 },
    size: { default: void 0 },
    animation: { default: void 0 }
  },
  setup(e) {
    const t = e, a = computed(
      () => t.width === void 0 ? void 0 : typeof t.width == "number" ? t.width.toString() : t.width.replace("%", "")
    ), l = computed(
      () => t.cols === void 0 ? void 0 : typeof t.cols == "number" ? t.cols.toString() : t.cols
    ), o = computed(() => ({
      [`col-${l.value}`]: l.value !== void 0 && a.value === void 0,
      [`bg-${t.variant}`]: t.variant !== void 0,
      [`placeholder-${t.size}`]: t.size !== void 0
    })), n = computed(() => ({
      [`placeholder-${t.animation}`]: t.animation !== void 0
    })), r = computed(() => ({
      width: a.value === void 0 ? void 0 : `${a.value}%`
    }));
    return (s, f) => (openBlock(), createBlock(resolveDynamicComponent(e.wrapperTag), {
      class: normalizeClass(unref(n))
    }, {
      default: withCtx(() => [
        (openBlock(), createBlock(resolveDynamicComponent(e.tag), mergeProps(s.$attrs, {
          class: ["placeholder", unref(o)],
          style: unref(r)
        }), null, 16, ["class", "style"]))
      ]),
      _: 1
    }, 8, ["class"]));
  }
});
var Fn = defineComponent({
  __name: "BPlaceholderButton",
  props: {
    tag: { default: "div" },
    width: { default: void 0 },
    cols: { default: void 0 },
    variant: { default: "primary" },
    animation: { default: void 0 }
  },
  setup(e) {
    const t = e, a = computed(() => ["btn", `btn-${t.variant}`, "disabled"]), l = computed(() => ({
      animation: t.animation,
      width: t.width,
      cols: t.cols,
      tag: t.tag
    }));
    return (o, n) => (openBlock(), createBlock(Me, mergeProps({ class: unref(a) }, unref(l)), null, 16, ["class"]));
  }
});
var Vc = defineComponent({
  __name: "BPlaceholderCard",
  props: {
    noHeader: { default: false },
    headerWidth: { default: 100 },
    headerVariant: { default: void 0 },
    headerAnimation: { default: void 0 },
    headerSize: { default: void 0 },
    noFooter: { default: false },
    footerWidth: { default: 100 },
    footerVariant: { default: void 0 },
    footerAnimation: { default: void 0 },
    footerSize: { default: void 0 },
    animation: { default: void 0 },
    size: { default: void 0 },
    variant: { default: void 0 },
    noButton: { default: false },
    imgBottom: { default: false },
    imgSrc: { default: void 0 },
    imgBlankColor: { default: "#868e96" },
    imgHeight: { default: 100 },
    noImg: { default: false }
  },
  setup(e) {
    const t = e, a = c(toRef(t, "noButton")), l = c(toRef(t, "noHeader")), o = c(toRef(t, "noFooter")), n = c(toRef(t, "noImg")), r = computed(() => ({
      width: t.headerWidth,
      variant: t.headerVariant,
      animation: t.headerAnimation,
      size: t.headerSize
    })), s = computed(() => ({
      width: t.footerWidth,
      animation: t.footerAnimation,
      size: a.value ? t.footerSize : void 0,
      variant: t.footerVariant
    })), f = computed(() => ({
      animation: t.animation,
      size: t.size,
      variant: t.variant
    })), m = computed(() => ({
      blank: !t.imgSrc,
      blankColor: t.imgBlankColor,
      height: t.imgSrc ? void 0 : t.imgHeight,
      src: t.imgSrc,
      top: !t.imgBottom,
      bottom: t.imgBottom
    }));
    return (B, h2) => (openBlock(), createBlock(hn, { "img-bottom": e.imgBottom }, createSlots({
      default: withCtx(() => [
        renderSlot(B.$slots, "default", {}, () => [
          createVNode(Me, mergeProps({ cols: "7" }, unref(f)), null, 16),
          createVNode(Me, mergeProps({ cols: "4" }, unref(f)), null, 16),
          createVNode(Me, mergeProps({ cols: "4" }, unref(f)), null, 16),
          createVNode(Me, mergeProps({ cols: "6" }, unref(f)), null, 16),
          createVNode(Me, mergeProps({ cols: "8" }, unref(f)), null, 16)
        ])
      ]),
      _: 2
    }, [
      unref(n) ? void 0 : {
        name: "img",
        fn: withCtx(() => [
          renderSlot(B.$slots, "img", {}, () => [
            createVNode(oa, normalizeProps(guardReactiveProps(unref(m))), null, 16)
          ])
        ]),
        key: "0"
      },
      unref(l) ? void 0 : {
        name: "header",
        fn: withCtx(() => [
          renderSlot(B.$slots, "header", {}, () => [
            createVNode(Me, normalizeProps(guardReactiveProps(unref(r))), null, 16)
          ])
        ]),
        key: "1"
      },
      unref(o) ? void 0 : {
        name: "footer",
        fn: withCtx(() => [
          renderSlot(B.$slots, "footer", {}, () => [
            unref(a) ? (openBlock(), createBlock(Me, normalizeProps(mergeProps({ key: 1 }, unref(s))), null, 16)) : (openBlock(), createBlock(Fn, normalizeProps(mergeProps({ key: 0 }, unref(s))), null, 16))
          ])
        ]),
        key: "2"
      }
    ]), 1032, ["img-bottom"]));
  }
});
var Za = defineComponent({
  __name: "BTableSimple",
  props: {
    bordered: { default: false },
    borderless: { default: false },
    borderVariant: { default: void 0 },
    captionTop: { default: false },
    dark: { default: false },
    hover: { default: false },
    responsive: { type: [Boolean, String], default: false },
    stacked: { type: [Boolean, String], default: false },
    striped: { default: false },
    small: { default: false },
    tableClass: { default: void 0 },
    tableVariant: { default: void 0 },
    stickyHeader: { default: false }
  },
  setup(e) {
    const t = e, a = c(toRef(t, "captionTop")), l = c(toRef(t, "borderless")), o = c(toRef(t, "bordered")), n = c(toRef(t, "dark")), r = c(toRef(t, "hover")), s = c(toRef(t, "small")), f = c(toRef(t, "striped")), m = c(toRef(t, "stickyHeader")), B = computed(() => [
      "table",
      "b-table",
      {
        "table-bordered": o.value,
        "table-borderless": l.value,
        [`border-${t.borderVariant}`]: t.borderVariant !== void 0,
        "caption-top": a.value,
        "table-dark": n.value,
        "table-hover": r.value,
        "b-table-stacked": typeof t.stacked == "boolean" && t.stacked,
        [`b-table-stacked-${t.stacked}`]: typeof t.stacked == "string",
        "table-striped": f.value,
        "table-sm": s.value,
        [`table-${t.tableVariant}`]: t.tableVariant !== void 0
      },
      t.tableClass
    ]), h2 = computed(() => [
      {
        "table-responsive": t.responsive === true,
        [`table-responsive-${t.responsive}`]: typeof t.responsive == "string",
        "b-table-sticky-header": m.value
      }
    ]);
    return (v, w) => e.responsive ? (openBlock(), createElementBlock("div", {
      key: 1,
      class: normalizeClass(unref(h2))
    }, [
      createBaseVNode("table", {
        class: normalizeClass(unref(B))
      }, [
        renderSlot(v.$slots, "default")
      ], 2)
    ], 2)) : (openBlock(), createElementBlock("table", {
      key: 0,
      class: normalizeClass(unref(B))
    }, [
      renderSlot(v.$slots, "default")
    ], 2));
  }
});
var Oc = defineComponent({
  __name: "BPlaceholderTable",
  props: {
    rows: { default: 3 },
    columns: { default: 5 },
    cellWidth: { default: 100 },
    size: { default: void 0 },
    animation: { default: void 0 },
    variant: { default: void 0 },
    headerColumns: { default: void 0 },
    hideHeader: { default: false },
    headerCellWidth: { default: 100 },
    headerSize: { default: void 0 },
    headerAnimation: { default: void 0 },
    headerVariant: { default: void 0 },
    footerColumns: { default: void 0 },
    showFooter: { default: false },
    footerCellWidth: { default: 100 },
    footerSize: { default: void 0 },
    footerAnimation: { default: void 0 },
    footerVariant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = Bt(toRef(t, "columns"), { nanToZero: true, method: "parseInt" }), l = Bt(toRef(t, "rows"), { nanToZero: true, method: "parseInt" }), o = computed(() => t.headerColumns ?? NaN), n = computed(() => t.footerColumns ?? NaN), r = Bt(o, {
      nanToZero: true,
      method: "parseInt"
    }), s = Bt(n, {
      nanToZero: true,
      method: "parseInt"
    }), f = computed(() => a.value || 5), m = computed(() => l.value || 3), B = computed(
      () => t.headerColumns === void 0 ? f.value : r.value
    ), h2 = computed(
      () => t.footerColumns === void 0 ? f.value : s.value
    ), v = computed(() => ({
      size: t.size,
      variant: t.variant,
      animation: t.animation,
      width: t.cellWidth
    })), w = computed(() => ({
      size: t.headerSize,
      variant: t.headerVariant,
      animation: t.headerAnimation,
      width: t.headerCellWidth
    })), g = computed(() => ({
      size: t.footerSize,
      variant: t.footerVariant,
      animation: t.footerAnimation,
      width: t.footerCellWidth
    })), k = c(toRef(t, "hideHeader")), y = c(toRef(t, "showFooter"));
    return ($, b) => (openBlock(), createBlock(Za, null, {
      default: withCtx(() => [
        unref(k) ? createCommentVNode("", true) : renderSlot($.$slots, "thead", { key: 0 }, () => [
          createBaseVNode("thead", null, [
            createBaseVNode("tr", null, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(B), (_, V) => (openBlock(), createElementBlock("th", { key: V }, [
                createVNode(Me, normalizeProps(guardReactiveProps(unref(w))), null, 16)
              ]))), 128))
            ])
          ])
        ]),
        renderSlot($.$slots, "default", {}, () => [
          createBaseVNode("tbody", null, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(m), (_, V) => (openBlock(), createElementBlock("tr", { key: V }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(f), (T, S) => (openBlock(), createElementBlock("td", { key: S }, [
                createVNode(Me, normalizeProps(guardReactiveProps(unref(v))), null, 16)
              ]))), 128))
            ]))), 128))
          ])
        ]),
        unref(y) ? renderSlot($.$slots, "tfoot", { key: 1 }, () => [
          createBaseVNode("tfoot", null, [
            createBaseVNode("tr", null, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(h2), (_, V) => (openBlock(), createElementBlock("th", { key: V }, [
                createVNode(Me, normalizeProps(guardReactiveProps(unref(g))), null, 16)
              ]))), 128))
            ])
          ])
        ]) : createCommentVNode("", true)
      ]),
      _: 3
    }));
  }
});
var Pc = defineComponent({
  __name: "BPlaceholderWrapper",
  props: {
    loading: { default: false }
  },
  setup(e) {
    const a = c(toRef(e, "loading"));
    return (l, o) => unref(a) ? renderSlot(l.$slots, "loading", { key: 0 }) : renderSlot(l.$slots, "default", { key: 1 });
  }
});
var Ec = ["aria-valuenow", "aria-valuemax"];
var Ln = defineComponent({
  __name: "BProgressBar",
  props: {
    animated: { default: false },
    label: { default: void 0 },
    labelHtml: { default: void 0 },
    max: { default: void 0 },
    precision: { default: 0 },
    showProgress: { default: false },
    showValue: { default: false },
    striped: { default: false },
    value: { default: 0 },
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = inject(wo, null), l = c(toRef(t, "animated")), o = c(toRef(t, "showProgress")), n = c(toRef(t, "showValue")), r = c(toRef(t, "striped")), s = computed(() => ({
      "progress-bar-animated": l.value || (a == null ? void 0 : a.animated.value),
      "progress-bar-striped": r.value || (a == null ? void 0 : a.striped.value) || l.value || (a == null ? void 0 : a.animated.value),
      [`bg-${t.variant}`]: t.variant !== void 0
    })), f = computed(
      () => typeof t.precision == "number" ? t.precision : Number.parseFloat(t.precision)
    ), m = computed(
      () => typeof t.value == "number" ? t.value : Number.parseFloat(t.value)
    ), B = computed(
      () => typeof t.max == "number" ? t.max : t.max === void 0 ? void 0 : Number.parseFloat(t.max)
    ), h2 = computed(
      () => t.labelHtml !== void 0 ? t.labelHtml : n.value || a != null && a.showValue.value ? m.value.toFixed(f.value) : o.value || a != null && a.showProgress.value ? (m.value * 100 / (B.value || 100)).toFixed(f.value) : t.label !== void 0 ? t.label : ""
    ), v = computed(
      () => a != null && a.max.value ? `${m.value * 100 / (typeof a.max.value == "number" ? a.max.value : Number.parseInt(a.max.value))}%` : t.max ? `${m.value * 100 / (typeof t.max == "number" ? t.max : Number.parseInt(t.max))}%` : typeof t.value == "string" ? t.value : `${t.value}%`
    );
    return (w, g) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(["progress-bar", unref(s)]),
      role: "progressbar",
      "aria-valuenow": e.value,
      "aria-valuemin": "0",
      "aria-valuemax": e.max,
      style: normalizeStyle({ width: unref(v) })
    }, [
      renderSlot(w.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(unref(h2)), 1)
      ])
    ], 14, Ec));
  }
});
var Ic = defineComponent({
  __name: "BProgress",
  props: {
    variant: { default: void 0 },
    max: { default: void 0 },
    height: { default: void 0 },
    animated: { default: false },
    precision: { default: 0 },
    showProgress: { default: false },
    showValue: { default: false },
    striped: { default: false },
    value: { default: 0 }
  },
  setup(e) {
    const t = e, a = c(toRef(t, "animated")), l = c(toRef(t, "showProgress")), o = c(toRef(t, "showValue")), n = c(toRef(t, "striped")), r = computed(() => ({
      animated: t.animated,
      max: t.max,
      precision: t.precision,
      showProgress: t.showProgress,
      showValue: t.showValue,
      striped: t.striped,
      value: t.value,
      variant: t.variant
    }));
    return provide(wo, {
      animated: a,
      max: readonly(toRef(t, "max")),
      showProgress: l,
      showValue: o,
      striped: n
    }), (s, f) => (openBlock(), createElementBlock("div", {
      class: "progress",
      style: normalizeStyle({ height: e.height })
    }, [
      renderSlot(s.$slots, "default", {}, () => [
        createVNode(Ln, normalizeProps(guardReactiveProps(unref(r))), null, 16)
      ])
    ], 4));
  }
});
var Dl = ra("cols", [""], { type: [String, Number], default: null });
var Fc = defineComponent({
  name: "BRow",
  props: {
    tag: { type: String, default: "div" },
    gutterX: { type: String, default: null },
    gutterY: { type: String, default: null },
    noGutters: { type: [Boolean, String], default: false },
    alignV: { type: String, default: null },
    alignH: { type: String, default: null },
    alignContent: { type: String, default: null },
    ...Dl
  },
  setup(e) {
    const t = c(toRef(e, "noGutters")), a = zt(toRef(e, "alignH")), l = computed(() => ho(e, Dl, "cols", "row-cols"));
    return {
      computedClasses: computed(() => [
        l.value,
        {
          [`gx-${e.gutterX}`]: e.gutterX !== null,
          [`gy-${e.gutterY}`]: e.gutterY !== null,
          "g-0": t.value,
          [`align-items-${e.alignV}`]: e.alignV !== null,
          [a.value]: e.alignH !== null,
          [`align-content-${e.alignContent}`]: e.alignContent !== null
        }
      ])
    };
  }
});
function Lc(e, t, a, l, o, n) {
  return openBlock(), createBlock(resolveDynamicComponent(e.tag), {
    class: normalizeClass(["row", e.computedClasses])
  }, {
    default: withCtx(() => [
      renderSlot(e.$slots, "default")
    ]),
    _: 3
  }, 8, ["class"]);
}
var Nc = ze(Fc, [["render", Lc]]);
var jl = [
  "ar",
  "az",
  "ckb",
  "fa",
  "he",
  "ks",
  "lrc",
  "mzn",
  "ps",
  "sd",
  "te",
  "ug",
  "ur",
  "yi"
].map((e) => e.toLowerCase());
var zc = (e) => {
  const t = Gt(e).toLowerCase().replace(os, "").split("-"), a = t.slice(0, 2).join("-"), [l] = t;
  return jl.includes(a) || jl.includes(l);
};
var Rc = (e) => cs ? ga(e) ? e : { capture: !!e || false } : !!(ga(e) ? e.capture : e);
var Hc = (e, t, a, l) => {
  e && e.addEventListener && e.addEventListener(t, a, Rc(l));
};
var Mc = (e, t, a, l) => {
  e && e.removeEventListener && e.removeEventListener(t, a, l);
};
var ql = (e, t) => {
  (e ? Hc : Mc)(...t);
};
var Mt = (e, { preventDefault: t = true, propagation: a = true, immediatePropagation: l = false } = {}) => {
  t && e.preventDefault(), a && e.stopPropagation(), l && e.stopImmediatePropagation();
};
var Pa = "ArrowDown";
var Nn = "End";
var zn = "Home";
var Rn = "PageDown";
var Hn = "PageUp";
var Ea = "ArrowUp";
var Gl = 1;
var Wl = 100;
var Ul = 1;
var Kl = 500;
var Xl = 100;
var Jl = 10;
var Yl = 4;
var Zl = [Ea, Pa, zn, Nn, Hn, Rn];
var Dc = defineComponent({
  props: {
    ariaControls: { type: String, default: void 0 },
    ariaLabel: { type: String, default: void 0 },
    labelIncrement: { type: String, default: "Increment" },
    labelDecrement: { type: String, default: "Decrement" },
    modelValue: { type: Number, default: null },
    // V-model prop
    name: { type: String, default: "BFormSpinbutton" },
    disabled: { type: [Boolean, String], default: false },
    placeholder: { type: String, default: void 0 },
    locale: { type: String, default: "locale" },
    form: { type: String, default: void 0 },
    inline: { type: Boolean, default: false },
    size: { type: String, default: void 0 },
    formatterFn: {
      type: Function,
      default: void 0
    },
    readonly: { type: Boolean, default: false },
    vertical: { type: Boolean, default: false },
    repeatDelay: {
      type: [String, Number],
      default: Kl
    },
    repeatInterval: {
      type: [String, Number],
      default: Xl
    },
    repeatStepMultiplier: {
      type: [String, Number],
      default: Yl
    },
    repeatThreshold: {
      type: [String, Number],
      default: Jl
    },
    required: { type: [Boolean, String], default: false },
    step: { type: [String, Number], default: Ul },
    min: { type: [String, Number], default: Gl },
    max: { type: [String, Number], default: Wl },
    wrap: { type: Boolean, default: false },
    state: { type: [Boolean, String], default: null }
  },
  emits: ["update:modelValue", "change"],
  setup(e, { emit: t }) {
    const a = Te(e, "modelValue", t), l = ref(false), o = computed(() => 1), n = () => {
      t("change", s.value);
    }, r = ref(null), s = computed({
      get: () => a.value === null ? r.value : a.value,
      set: (L) => {
        a.value === null ? r.value = L : a.value = L;
      }
    });
    let f, m, B = false;
    const h2 = computed(() => At(e.step, Ul)), v = computed(() => At(e.min, Gl)), w = computed(() => {
      const L = At(e.max, Wl), z = h2.value, ee = v.value;
      return Math.floor((L - ee) / z) * z + ee;
    }), g = computed(() => {
      const L = lt(e.repeatDelay, 0);
      return L > 0 ? L : Kl;
    }), k = computed(() => {
      const L = lt(e.repeatInterval, 0);
      return L > 0 ? L : Xl;
    }), y = computed(
      () => Math.max(lt(e.repeatThreshold, Jl), 1)
    ), $ = computed(
      () => Math.max(lt(e.repeatStepMultiplier, Yl), 1)
    ), b = computed(() => {
      const L = h2.value;
      return Math.floor(L) === L ? 0 : (L.toString().split(".")[1] || "").length;
    }), _ = computed(() => Math.pow(10, b.value || 0)), V = computed(() => {
      const { value: L } = s;
      return L === null ? "" : L.toFixed(b.value);
    }), T = computed(() => {
      const L = [e.locale];
      return new Intl.NumberFormat(L).resolvedOptions().locale;
    }), S = computed(
      () => (
        //todo
        zc(T.value)
      )
    ), O = () => {
      const L = b.value;
      return new Intl.NumberFormat(T.value, {
        style: "decimal",
        useGrouping: false,
        minimumIntegerDigits: 1,
        minimumFractionDigits: L,
        maximumFractionDigits: L,
        notation: "standard"
      }).format;
    }, I = computed(() => e.formatterFn ?? O()), C = computed(() => ({
      role: "group",
      lang: T.value,
      tabindex: e.disabled ? null : "-1",
      title: e.ariaLabel
    })), F = computed(() => a.value !== null || r.value !== null), P = computed(() => ({
      dir: S.value,
      spinId: o.value,
      tabindex: e.disabled ? null : "0",
      role: "spinbutton",
      "aria-live": "off",
      "aria-label": e.ariaLabel || null,
      "aria-controls": e.ariaControls || null,
      "aria-invalid": e.state === false || !F.value && e.required ? true : null,
      "aria-required": e.required ? true : null,
      "aria-valuemin": v.value,
      "aria-valuemax": w.value,
      "aria-valuenow": s.value !== null ? s.value : null,
      "aria-valuetext": s.value !== null ? I.value(s.value) : null
    })), W = (L) => {
      let { value: z } = s;
      if (!e.disabled && z !== null) {
        const ee = h2.value * L, re = v.value, he = w.value, Oe = _.value, { wrap: U } = e;
        z = Math.round((z - re) / ee) * ee + re + ee, z = Math.round(z * Oe) / Oe, s.value = z > he ? U ? re : he : z < re ? U ? he : re : z;
      }
    }, j = (L = 1) => {
      s.value === null ? s.value = v.value : W(1 * L);
    }, te = (L = 1) => {
      s.value === null ? s.value = e.wrap ? w.value : v.value : W(-1 * L);
    }, X = (L) => {
      const { code: z, altKey: ee, ctrlKey: re, metaKey: he } = L;
      if (!(e.disabled || e.readonly || ee || re || he) && Zl.includes(z)) {
        if (Mt(L, { propagation: false }), B)
          return;
        ne(), [Ea, Pa].includes(z) ? (B = true, z === Ea ? ae(L, j) : z === Pa && ae(L, te)) : z === Hn ? j($.value) : z === Rn ? te($.value) : z === zn ? s.value = v.value : z === Nn && (s.value = w.value);
      }
    }, q = (L) => {
      const { code: z, altKey: ee, ctrlKey: re, metaKey: he } = L;
      e.disabled || e.readonly || ee || re || he || Zl.includes(z) && (Mt(L, { propagation: false }), ne(), B = false, n());
    }, ae = (L, z) => {
      const { type: ee } = L || {};
      if (!e.disabled && !e.readonly) {
        if (me(L) && ee === "mousedown" && L.button)
          return;
        ne(), z(1);
        const re = y.value, he = $.value, Oe = g.value, U = k.value;
        f = setTimeout(() => {
          let ie = 0;
          m = setInterval(() => {
            z(ie < re ? 1 : he), ie++;
          }, U);
        }, Oe);
      }
    };
    function me(L) {
      return L.type === "mouseup" || L.type === "mousedown";
    }
    const pe = (L) => {
      me(L) && L.type === "mouseup" && L.button || (Mt(L, { propagation: false }), ne(), be(false), n());
    }, be = (L) => {
      try {
        ql(L, [document.body, "mouseup", pe, false]), ql(L, [document.body, "touchend", pe, false]);
      } catch {
        return 0;
      }
    }, ne = () => {
      clearTimeout(f), clearInterval(m), f = void 0, m = void 0;
    }, ve = (L, z, ee, re, he, Oe, U) => {
      const ie = h(ee, {
        props: { scale: l.value ? 1.5 : 1.25 },
        attrs: { "aria-hidden": true }
      }), Re = { hasFocus: l.value }, Ie = (E) => {
        !e.disabled && !e.readonly && (Mt(E, { propagation: false }), be(true), ae(E, L));
      };
      return h(
        "button",
        {
          class: [{ "py-0": !e.vertical }, "btn", "btn-sm", "border-0", "rounded-0"],
          tabindex: "-1",
          type: "button",
          disabled: e.disabled || e.readonly || Oe,
          "aria-disabled": e.disabled || e.readonly || Oe ? true : null,
          "aria-controls": o.value,
          "aria-label": z || null,
          "aria-keyshortcuts": he || null,
          onmousedown: Ie,
          ontouchstart: Ie
          // 'ref': keyRef,
        },
        [De(U, Re) || ie]
      );
    };
    return () => {
      const L = ve(
        j,
        e.labelIncrement,
        h(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            width: "16",
            height: "16",
            fill: "currentColor",
            class: "bi bi-plus",
            viewBox: "0 0 16 16"
          },
          h("path", {
            d: "M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"
          })
        ),
        "inc",
        "ArrowUp",
        false,
        "increment"
      ), z = ve(
        te,
        e.labelDecrement,
        h(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            width: "16",
            height: "16",
            fill: "currentColor",
            class: "bi bi-dash",
            viewBox: "0 0 16 16"
          },
          h("path", { d: "M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z" })
        ),
        "dec",
        "ArrowDown",
        false,
        "decrement"
      ), ee = [];
      e.name && !e.disabled && ee.push(
        h("input", {
          type: "hidden",
          name: e.name,
          form: e.form || null,
          // TODO: Should this be set to '' if value is out of range?
          value: V.value,
          key: "hidden"
        })
      );
      const re = h(
        // We use 'output' element to make this accept a `<label for="id">` (Except IE)
        "output",
        {
          class: [
            { "d-flex": e.vertical },
            { "align-self-center": !e.vertical },
            { "align-items-center": e.vertical },
            { "border-top": e.vertical },
            { "border-bottom": e.vertical },
            { "border-start": !e.vertical },
            { "border-end": !e.vertical },
            "flex-grow-1"
          ],
          ...P.value,
          key: "output"
          // ref: 'spinner',
        },
        [
          h(
            "bdi",
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            //@ts-ignore How can we narrow this type down
            F.value ? I.value(s.value) : e.placeholder || ""
          )
        ]
      );
      return h(
        "div",
        {
          class: [
            "b-form-spinbutton form-control",
            { disabled: e.disabled },
            { readonly: e.readonly },
            { focus: l },
            { "d-inline-flex": e.inline || e.vertical },
            { "d-flex": !e.inline && !e.vertical },
            { "align-items-stretch": !e.vertical },
            { "flex-column": e.vertical },
            e.size ? `form-control-${e.size}` : null
            // this.stateClass //TODO
          ],
          ...C.value,
          onkeydown: X,
          onkeyup: q
          // We use capture phase (`!` prefix) since focus and blur do not bubble
          // 'focus': onFocusBlur, //TODO
          // 'blur': onFocusBlur, //TODO
        },
        e.vertical ? [L, ee, re, z] : [z, ee, re, L]
      );
    };
  }
});
var jc = ["TD", "TH", "TR"];
var qc = [
  "a",
  "a *",
  // Include content inside links
  "button",
  "button *",
  // Include content inside buttons
  "input:not(.disabled):not([disabled])",
  "select:not(.disabled):not([disabled])",
  "textarea:not(.disabled):not([disabled])",
  '[role="link"]',
  '[role="link"] *',
  '[role="button"]',
  '[role="button"] *',
  "[tabindex]:not(.disabled):not([disabled])"
].join(",");
var Dt = (e) => {
  if (!e || !e.target)
    return false;
  const t = e.target;
  if ("disabled" in t && t.disabled || jc.indexOf(t.tagName) !== -1)
    return false;
  if (al(".dropdown-menu", t))
    return true;
  const a = t.tagName === "LABEL" ? t : al("label", t);
  if (a) {
    const l = Ra(a, "for"), o = l ? Bs(l) : go("input, select, textarea", a);
    if (o && !o.disabled)
      return true;
  }
  return bo(t, qc);
};
var Gc = () => {
  const e = (m, B) => {
    const h2 = [];
    return !(m != null && m.length) && (B != null && B.length) ? (Object.keys(B[0]).forEach((v) => h2.push({ key: v, label: Qa(v) })), h2) : (Array.isArray(m) && m.forEach((v) => {
      typeof v == "string" ? h2.push({ key: v, label: Qa(v) }) : ga(v) && v.key && typeof v.key == "string" && h2.push({ ...v });
    }), h2);
  }, t = ref([]), a = (m, B, h2, v) => (t.value = Wt(B), "isFilterableTable" in v && v.isFilterableTable.value === true && h2.filter && (t.value = n(t.value, h2.filter, h2.filterable)), "isSortable" in v && v.isSortable.value === true && (t.value = o(
    m,
    t.value,
    {
      key: h2.sortBy,
      desc: v.sortDescBoolean.value
    },
    h2.sortCompare
  )), t.value), l = ref(void 0), o = (m, B, h2, v) => {
    if (!h2 || !h2.key)
      return B;
    const w = h2.key;
    return B.sort((g, k) => {
      if (v !== void 0)
        return v(g, k, h2.key, h2.desc);
      const y = (_) => typeof _ == "object" ? JSON.stringify(_) : _;
      return y(g[w]) > y(k[w]) ? h2.desc ? -1 : 1 : y(k[w]) > y(g[w]) ? h2.desc ? 1 : -1 : 0;
    });
  }, n = (m, B, h2) => m.filter(
    (v) => Object.entries(v).filter((w) => {
      const [g, k] = w;
      return !k || g[0] === "_" || h2.length > 0 && !h2.includes(g) ? false : (typeof k == "object" ? JSON.stringify(Object.values(k)) : typeof k == "string" ? k : k.toString()).toLowerCase().includes(B.toLowerCase());
    }).length > 0
  );
  return {
    normaliseFields: e,
    mapItems: a,
    internalItems: t,
    updateInternalItems: async (m) => {
      try {
        return t.value = await ba(m), t.value;
      } catch {
        return;
      }
    },
    filterEvent: l,
    notifyFilteredItems: () => {
      l.value && l.value(t.value);
    },
    formatItem: (m, B) => {
      const h2 = m[B.key];
      return B.formatter && typeof B.formatter == "function" ? B.formatter(h2, B.key, m) : m[B.key];
    }
  };
};
var Wc = ["title", "abbr", "onClick"];
var Uc = { class: "d-inline-flex flex-nowrap align-items-center gap-1" };
var Kc = { key: 1 };
var Xc = ["onClick", "onDblclick", "onMouseenter", "onMouseleave"];
var Jc = {
  key: 0,
  class: "b-table-stacked-label"
};
var Yc = ["colspan"];
var Zc = ["colspan"];
var Qc = { class: "d-flex align-items-center justify-content-center gap-2" };
var ef = createBaseVNode("strong", null, "Loading...", -1);
var tf = {
  key: 1,
  class: "b-table-empty-slot"
};
var af = ["colspan"];
var lf = { key: 0 };
var of = ["title", "abbr", "onClick"];
var nf = { key: 1 };
var sf = { key: 2 };
var rf = { key: 3 };
var uf = defineComponent({
  __name: "BTable",
  props: {
    align: { default: void 0 },
    caption: { default: void 0 },
    captionTop: { default: false },
    borderless: { default: false },
    bordered: { default: false },
    borderVariant: { default: void 0 },
    dark: { default: false },
    fields: { default: () => [] },
    footClone: { default: false },
    hover: { default: false },
    items: { default: () => [] },
    provider: { default: void 0 },
    sortCompare: { default: void 0 },
    noProvider: { default: void 0 },
    noProviderPaging: { default: void 0 },
    noProviderSorting: { default: void 0 },
    noProviderFiltering: { default: void 0 },
    responsive: { type: [Boolean, String], default: false },
    small: { default: false },
    striped: { default: false },
    stacked: { type: [Boolean, String], default: false },
    labelStacked: { type: Boolean, default: false },
    variant: { default: void 0 },
    sortBy: { default: void 0 },
    sortDesc: { default: false },
    sortInternal: { default: true },
    selectable: { default: false },
    stickySelect: { default: false },
    selectHead: { type: [Boolean, String], default: true },
    selectMode: { default: "single" },
    selectionVariant: { default: "primary" },
    stickyHeader: { default: false },
    busy: { default: false },
    showEmpty: { default: false },
    perPage: { default: void 0 },
    currentPage: { default: 1 },
    filter: { default: void 0 },
    filterable: { default: void 0 },
    emptyText: { default: "There are no records to show" },
    emptyFilteredText: { default: "There are no records matching your request" }
  },
  emits: ["headClicked", "rowClicked", "rowDblClicked", "rowHovered", "rowUnhovered", "rowSelected", "rowUnselected", "selection", "update:busy", "update:sortBy", "update:sortDesc", "sorted", "filtered"],
  setup(e, { expose: t, emit: a }) {
    const l = e, o = useSlots(), n = Gc(), r = c(toRef(l, "footClone")), s = c(toRef(l, "sortDesc")), f = c(toRef(l, "sortInternal")), m = c(toRef(l, "selectable")), B = c(toRef(l, "stickySelect")), h2 = c(toRef(l, "labelStacked")), v = c(toRef(l, "busy")), w = c(toRef(l, "showEmpty")), g = c(toRef(l, "noProviderPaging")), k = c(toRef(l, "noProviderSorting")), y = c(toRef(l, "noProviderFiltering")), $ = ref(v.value);
    n.filterEvent.value = async (E) => {
      if (C.value) {
        await L();
        return;
      }
      const J = await ba(E);
      a("filtered", J);
    };
    const b = ref(/* @__PURE__ */ new Set([])), _ = computed(() => b.value.size > 0), V = computed(() => ({
      [`align-${l.align}`]: l.align !== void 0,
      "b-table-selectable": m.value,
      [`b-table-select-${l.selectMode}`]: m.value,
      "b-table-selecting user-select-none": m.value && _.value,
      "b-table-busy": $.value,
      "b-table-sortable": P.value,
      "b-table-sort-desc": P.value && s.value === true,
      "b-table-sort-asc": P.value && s.value === false
    })), T = computed(() => ({
      bordered: l.bordered,
      borderless: l.borderless,
      borderVariant: l.borderVariant,
      captionTop: l.captionTop,
      dark: l.dark,
      hover: l.hover,
      responsive: l.responsive,
      striped: l.striped,
      stacked: l.stacked,
      small: l.small,
      tableClass: V.value,
      tableVariant: l.variant,
      stickyHeader: l.stickyHeader
    })), S = computed(() => n.normaliseFields(l.fields, l.items)), O = computed(
      () => S.value.length + (m.value ? 1 : 0)
    ), I = computed(() => l.filter !== void 0 && l.filter !== ""), C = computed(() => l.provider !== void 0), F = computed(
      () => m.value && (!!l.selectHead || o.selectHead !== void 0)
    ), P = computed(
      () => l.fields.filter((E) => typeof E == "string" ? false : E.sortable).length > 0
    ), W = computed(() => P.value && f.value === true), j = computed(() => {
      const E = C.value ? n.internalItems.value : W.value ? n.mapItems(l.fields, l.items, l, {
        isSortable: P,
        isFilterableTable: I,
        sortDescBoolean: s
      }) : l.items;
      if (l.perPage !== void 0) {
        const J = (l.currentPage - 1) * l.perPage;
        return E.splice(J, l.perPage);
      }
      return E;
    }), te = (E) => typeof E == "string" ? el(E) : E.label !== void 0 ? E.label : typeof E.key == "string" ? el(E.key) : E.key, X = (E, J, ge = false) => {
      const G = typeof E == "string" ? E : E.key;
      a("headClicked", G, E, J, ge), be(E);
    }, q = (E, J, ge) => {
      a("rowClicked", E, J, ge), ve(E, J, ge.shiftKey);
    }, ae = (E, J, ge) => a("rowDblClicked", E, J, ge), me = (E, J, ge) => a("rowHovered", E, J, ge), pe = (E, J, ge) => a("rowUnhovered", E, J, ge), be = (E) => {
      if (!P.value)
        return;
      const J = typeof E == "string" ? E : E.key, ge = typeof E == "string" ? false : E.sortable;
      if (P.value === true && ge === true) {
        const G = !s.value;
        J !== l.sortBy && a("update:sortBy", J), a("update:sortDesc", G), a("sorted", J, G);
      }
    }, ne = () => {
      m.value && a("selection", Array.from(b.value));
    }, ve = (E, J, ge = false) => {
      if (m.value) {
        if (b.value.has(E))
          b.value.delete(E), a("rowUnselected", E);
        else if (l.selectMode === "single" && b.value.size > 0 && (b.value.forEach((G) => a("rowUnselected", G)), b.value.clear()), l.selectMode === "range" && b.value.size > 0 && ge) {
          const G = Array.from(b.value).pop(), ue = j.value.findIndex((it) => it === G), oe = Math.min(ue, J), et = Math.max(ue, J);
          j.value.slice(oe, et + 1).forEach((it) => {
            b.value.has(it) || (b.value.add(it), a("rowSelected", it));
          });
        } else
          b.value.add(E), a("rowSelected", E);
        ne();
      }
    }, L = async () => {
      if (!C.value || !l.provider || $.value)
        return;
      $.value = true;
      const E = new Proxy(
        {
          currentPage: l.currentPage,
          filter: l.filter,
          sortBy: l.sortBy,
          sortDesc: l.sortDesc,
          perPage: l.perPage
        },
        {
          get: (ge, G) => G in ge ? ge[G] : void 0,
          set: () => (console.error("BTable provider context is a read-only object."), true)
        }
      ), J = l.provider(E, n.updateInternalItems);
      if (J !== void 0) {
        if (J instanceof Promise)
          try {
            const ge = await J;
            return Array.isArray(ge) ? await n.updateInternalItems(ge) : void 0;
          } finally {
            $.value && ($.value = false);
          }
        try {
          return await n.updateInternalItems(J);
        } finally {
          $.value && ($.value = false);
        }
      }
    }, z = (E) => {
      E._showDetails = !E._showDetails;
    }, ee = (E) => [
      E.class,
      E.thClass,
      E.variant ? `table-${E.variant}` : void 0,
      {
        "b-table-sortable-column": P.value && E.sortable,
        "b-table-sticky-column": E.stickyColumn
      }
    ], re = (E, J) => [
      E.class,
      E.tdClass,
      E.variant ? `table-${E.variant}` : void 0,
      J != null && J._cellVariants && (J != null && J._cellVariants[E.key]) ? `table-${J == null ? void 0 : J._cellVariants[E.key]}` : void 0,
      {
        "b-table-sticky-column": E.stickyColumn
      }
    ], he = (E) => [
      E._rowVariant ? `table-${E._rowVariant}` : null,
      E._rowVariant ? `table-${E._rowVariant}` : null,
      m.value && b.value.has(E) ? `selected table-${l.selectionVariant}` : null
    ], Oe = () => {
      if (!m.value)
        return;
      const E = b.value.size > 0 ? Array.from(b.value) : [];
      b.value = /* @__PURE__ */ new Set([...j.value]), b.value.forEach((J) => {
        E.includes(J) || a("rowSelected", J);
      }), ne();
    }, U = () => {
      m.value && (b.value.forEach((E) => {
        a("rowUnselected", E);
      }), b.value = /* @__PURE__ */ new Set([]), ne());
    }, ie = (E) => {
      if (!m.value)
        return;
      const J = j.value[E];
      !J || b.value.has(J) || (b.value.add(J), a("rowSelected", J), ne());
    }, Re = (E) => {
      if (!m.value)
        return;
      const J = j.value[E];
      !J || !b.value.has(J) || (b.value.delete(J), a("rowUnselected", J), ne());
    }, Ie = async (E, J, ge) => {
      if (J === ge)
        return;
      const G = (Mn) => l.noProvider && l.noProvider.includes(Mn), ue = !["currentPage", "perPage"].includes(E), oe = ["currentPage", "perPage"].includes(E) && (G("paging") || g.value === true), et = ["filter"].includes(E) && (G("filtering") || y.value === true), it = ["sortBy", "sortDesc"].includes(E) && (G("sorting") || k.value === true);
      oe || et || it || (await L(), ue && n.notifyFilteredItems());
    };
    return watch(
      () => l.filter,
      (E, J) => {
        E === J || C.value || E || ba(l.items).then((ge) => a("filtered", ge));
      }
    ), watch(
      $,
      () => $.value !== v.value && a("update:busy", $.value)
    ), watch(
      v,
      () => $.value !== v.value && ($.value = v.value)
    ), watch(
      () => l.filter,
      (E, J) => Ie("filter", E, J)
    ), watch(
      () => l.currentPage,
      (E, J) => Ie("currentPage", E, J)
    ), watch(
      () => l.perPage,
      (E, J) => Ie("perPage", E, J)
    ), watch(
      () => l.sortBy,
      (E, J) => Ie("sortBy", E, J)
    ), watch(
      () => l.sortDesc,
      (E, J) => Ie("sortDesc", E, J)
    ), onMounted(() => {
      C.value && L();
    }), t({
      selectAllRows: Oe,
      clearSelected: U,
      selectRow: ie,
      unselectRow: Re,
      refresh: L
    }), (E, J) => (openBlock(), createBlock(Za, normalizeProps(guardReactiveProps(unref(T))), {
      default: withCtx(() => {
        var ge;
        return [
          createBaseVNode("thead", null, [
            E.$slots["thead-top"] ? renderSlot(E.$slots, "thead-top", { key: 0 }) : createCommentVNode("", true),
            createBaseVNode("tr", null, [
              unref(F) ? (openBlock(), createElementBlock("th", {
                key: 0,
                class: normalizeClass(["b-table-selection-column", {
                  "b-table-sticky-column": unref(B)
                }])
              }, [
                renderSlot(E.$slots, "select-head", {}, () => [
                  createTextVNode(toDisplayString(typeof e.selectHead == "boolean" ? "Selected" : e.selectHead), 1)
                ])
              ], 2)) : createCommentVNode("", true),
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(S), (G) => (openBlock(), createElementBlock("th", mergeProps({
                key: G.key,
                scope: "col",
                class: ee(G),
                title: G.headerTitle,
                abbr: G.headerAbbr,
                style: G.thStyle
              }, G.thAttr, {
                onClick: (ue) => X(G, ue)
              }), [
                createBaseVNode("div", Uc, [
                  renderSlot(E.$slots, "sort-icon", {
                    field: G,
                    sortBy: e.sortBy,
                    selected: G.key === e.sortBy,
                    isDesc: unref(s),
                    direction: unref(s) ? "desc" : "asc"
                  }, () => [
                    unref(P) && G.sortable ? (openBlock(), createElementBlock("span", {
                      key: 0,
                      class: normalizeClass(["b-table-sort-icon", {
                        sorted: G.key === e.sortBy,
                        [`sorted-${unref(s) ? "desc" : "asc"}`]: G.key === e.sortBy
                      }])
                    }, null, 2)) : createCommentVNode("", true)
                  ]),
                  createBaseVNode("div", null, [
                    E.$slots["head(" + G.key + ")"] || E.$slots["head()"] ? renderSlot(E.$slots, E.$slots["head(" + G.key + ")"] ? "head(" + G.key + ")" : "head()", {
                      key: 0,
                      label: G.label
                    }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                      createTextVNode(toDisplayString(te(G)), 1)
                    ], 64))
                  ])
                ])
              ], 16, Wc))), 128))
            ]),
            E.$slots["thead-sub"] ? (openBlock(), createElementBlock("tr", Kc, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(S), (G) => (openBlock(), createElementBlock("td", {
                key: G.key,
                scope: "col",
                class: normalizeClass([G.class, G.thClass, G.variant ? `table-${G.variant}` : ""])
              }, [
                E.$slots["thead-sub"] ? renderSlot(E.$slots, "thead-sub", mergeProps({
                  key: 0,
                  items: unref(S)
                }, G)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createTextVNode(toDisplayString(G.label), 1)
                ], 64))
              ], 2))), 128))
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("tbody", null, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(j), (G, ue) => (openBlock(), createElementBlock(Fragment, { key: ue }, [
              createBaseVNode("tr", {
                class: normalizeClass(he(G)),
                onClick: (oe) => !unref(Dt)(oe) && q(G, ue, oe),
                onDblclick: (oe) => !unref(Dt)(oe) && ae(G, ue, oe),
                onMouseenter: (oe) => !unref(Dt)(oe) && me(G, ue, oe),
                onMouseleave: (oe) => !unref(Dt)(oe) && pe(G, ue, oe)
              }, [
                unref(F) ? (openBlock(), createElementBlock("td", {
                  key: 0,
                  class: normalizeClass(["b-table-selection-column", {
                    "b-table-sticky-column": unref(B)
                  }])
                }, [
                  renderSlot(E.$slots, "select-cell", {}, () => [
                    createBaseVNode("span", {
                      class: normalizeClass(b.value.has(G) ? "text-primary" : "")
                    }, "ð¹", 2)
                  ])
                ], 2)) : createCommentVNode("", true),
                (openBlock(true), createElementBlock(Fragment, null, renderList(unref(S), (oe) => (openBlock(), createElementBlock("td", mergeProps({
                  key: oe.key
                }, oe.tdAttr, {
                  class: re(oe, G)
                }), [
                  e.stacked && unref(h2) ? (openBlock(), createElementBlock("label", Jc, toDisplayString(te(oe)), 1)) : createCommentVNode("", true),
                  E.$slots["cell(" + oe.key + ")"] || E.$slots["cell()"] ? renderSlot(E.$slots, E.$slots["cell(" + oe.key + ")"] ? "cell(" + oe.key + ")" : "cell()", {
                    key: 1,
                    value: G[oe.key],
                    index: ue,
                    item: G,
                    field: oe,
                    items: e.items,
                    toggleDetails: () => z(G),
                    detailsShowing: G._showDetails
                  }) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                    createTextVNode(toDisplayString(unref(n).formatItem(G, oe)), 1)
                  ], 64))
                ], 16))), 128))
              ], 42, Xc),
              G._showDetails === true && E.$slots["row-details"] ? (openBlock(), createElementBlock("tr", {
                key: 0,
                class: normalizeClass(he(G))
              }, [
                createBaseVNode("td", { colspan: unref(O) }, [
                  renderSlot(E.$slots, "row-details", {
                    item: G,
                    toggleDetails: () => z(G)
                  })
                ], 8, Yc)
              ], 2)) : createCommentVNode("", true)
            ], 64))), 128)),
            $.value ? (openBlock(), createElementBlock("tr", {
              key: 0,
              class: normalizeClass(["b-table-busy-slot", { "b-table-static-busy": unref(j).length === 0 }])
            }, [
              createBaseVNode("td", { colspan: unref(O) }, [
                renderSlot(E.$slots, "table-busy", {}, () => [
                  createBaseVNode("div", Qc, [
                    createVNode(fa, { class: "align-middle" }),
                    ef
                  ])
                ])
              ], 8, Zc)
            ], 2)) : createCommentVNode("", true),
            unref(w) && unref(j).length === 0 ? (openBlock(), createElementBlock("tr", tf, [
              createBaseVNode("td", { colspan: unref(O) }, [
                renderSlot(E.$slots, "empty", {
                  items: unref(j),
                  filtered: unref(I)
                }, () => [
                  createTextVNode(toDisplayString(unref(I) ? e.emptyFilteredText : e.emptyText), 1)
                ])
              ], 8, af)
            ])) : createCommentVNode("", true)
          ]),
          unref(r) ? (openBlock(), createElementBlock("tfoot", lf, [
            createBaseVNode("tr", null, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(S), (G) => (openBlock(), createElementBlock("th", mergeProps({
                key: G.key
              }, G.thAttr, {
                scope: "col",
                class: [G.class, G.thClass, G.variant ? `table-${G.variant}` : ""],
                title: G.headerTitle,
                abbr: G.headerAbbr,
                style: G.thStyle,
                onClick: (ue) => X(G, ue, true)
              }), toDisplayString(G.label), 17, of))), 128))
            ])
          ])) : E.$slots["custom-foot"] ? (openBlock(), createElementBlock("tfoot", nf, [
            renderSlot(E.$slots, "custom-foot", {
              fields: unref(S),
              items: e.items,
              columns: (ge = unref(S)) == null ? void 0 : ge.length
            })
          ])) : createCommentVNode("", true),
          E.$slots["table-caption"] ? (openBlock(), createElementBlock("caption", sf, [
            renderSlot(E.$slots, "table-caption")
          ])) : e.caption ? (openBlock(), createElementBlock("caption", rf, toDisplayString(e.caption), 1)) : createCommentVNode("", true)
        ];
      }),
      _: 3
    }, 16));
  }
});
var df = defineComponent({
  __name: "BTbody",
  props: {
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = computed(() => ({
      [`thead-${t.variant}`]: t.variant !== void 0
    }));
    return (l, o) => (openBlock(), createElementBlock("tbody", {
      class: normalizeClass(unref(a))
    }, [
      renderSlot(l.$slots, "default")
    ], 2));
  }
});
var cf = ["scope", "colspan", "rowspan", "data-label"];
var ff = { key: 0 };
var vf = defineComponent({
  __name: "BTd",
  props: {
    colspan: { default: void 0 },
    rowspan: { default: void 0 },
    stackedHeading: { default: void 0 },
    stickyColumn: { default: false },
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = c(toRef(t, "stickyColumn")), l = computed(() => ({
      [`table-${t.variant}`]: t.variant !== void 0,
      "b-table-sticky-column": a.value,
      "table-b-table-default": a.value && t.variant === void 0
    })), o = computed(() => t.colspan ? "colspan" : t.rowspan ? "rowspan" : "col");
    return (n, r) => (openBlock(), createElementBlock("td", {
      scope: unref(o),
      class: normalizeClass(unref(l)),
      colspan: e.colspan,
      rowspan: e.rowspan,
      "data-label": e.stackedHeading
    }, [
      e.stackedHeading ? (openBlock(), createElementBlock("div", ff, [
        renderSlot(n.$slots, "default")
      ])) : renderSlot(n.$slots, "default", { key: 1 })
    ], 10, cf));
  }
});
var mf = defineComponent({
  __name: "BTfoot",
  props: {
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = computed(() => ({
      [`table-${t.variant}`]: t.variant !== void 0
    }));
    return (l, o) => (openBlock(), createElementBlock("tfoot", {
      class: normalizeClass(unref(a))
    }, [
      renderSlot(l.$slots, "default")
    ], 2));
  }
});
var pf = ["scope", "colspan", "rowspan", "data-label"];
var gf = { key: 0 };
var bf = defineComponent({
  __name: "BTh",
  props: {
    colspan: { default: void 0 },
    rowspan: { default: void 0 },
    stackedHeading: { default: void 0 },
    stickyColumn: { default: false },
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = c(toRef(t, "stickyColumn")), l = computed(() => ({
      [`table-${t.variant}`]: t.variant !== void 0,
      "b-table-sticky-column": a.value,
      "table-b-table-default": a.value && t.variant === void 0
    })), o = computed(() => t.colspan ? "colspan" : t.rowspan ? "rowspan" : "col");
    return (n, r) => (openBlock(), createElementBlock("th", {
      scope: unref(o),
      class: normalizeClass(unref(l)),
      colspan: e.colspan,
      rowspan: e.rowspan,
      "data-label": e.stackedHeading
    }, [
      e.stackedHeading !== void 0 ? (openBlock(), createElementBlock("div", gf, [
        renderSlot(n.$slots, "default")
      ])) : renderSlot(n.$slots, "default", { key: 1 })
    ], 10, pf));
  }
});
var hf = defineComponent({
  __name: "BThead",
  props: {
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = computed(() => ({
      [`table-${t.variant}`]: t.variant !== void 0
    }));
    return (l, o) => (openBlock(), createElementBlock("thead", {
      class: normalizeClass(unref(a))
    }, [
      renderSlot(l.$slots, "default")
    ], 2));
  }
});
var yf = defineComponent({
  __name: "BTr",
  props: {
    variant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = computed(() => ({
      [`table-${t.variant}`]: t.variant !== void 0
    }));
    return (l, o) => (openBlock(), createElementBlock("tr", {
      class: normalizeClass(unref(a))
    }, [
      renderSlot(l.$slots, "default")
    ], 2));
  }
});
var Bf = defineComponent({
  __name: "BTab",
  props: {
    id: { default: void 0 },
    title: { default: void 0 },
    active: { default: false },
    buttonId: { default: void 0 },
    disabled: { default: false },
    lazy: { default: void 0 },
    lazyOnce: { default: void 0 },
    noBody: { type: [Boolean, String], default: false },
    tag: { default: "div" },
    titleItemClass: { default: void 0 },
    titleLinkAttributes: { default: void 0 },
    titleLinkClass: { default: void 0 }
  },
  setup(e) {
    const t = e, a = inject(Bo, null), l = c(toRef(t, "active")), o = c(toRef(t, "disabled")), n = c(toRef(t, t.lazyOnce !== void 0 ? "lazyOnce" : "lazy")), r = ref(false), s = computed(() => !!(a != null && a.lazy.value || n.value)), f = computed(() => t.lazyOnce !== void 0), m = computed(() => l.value && !o.value), B = computed(() => {
      const v = s.value && f.value && r.value;
      return m.value || !s.value || v;
    }), h2 = computed(() => ({
      active: l.value,
      show: l.value,
      "card-body": (a == null ? void 0 : a.card.value) && t.noBody === false
    }));
    return watch(B, (v) => {
      v && !r.value && (r.value = true);
    }), (v, w) => (openBlock(), createBlock(resolveDynamicComponent(e.tag), {
      id: e.id,
      class: normalizeClass(["tab-pane", unref(h2)]),
      role: "tabpanel",
      "aria-labelledby": "profile-tab"
    }, {
      default: withCtx(() => [
        unref(B) ? renderSlot(v.$slots, "default", { key: 0 }) : createCommentVNode("", true)
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
});
var $f = ["id", "data-bs-target", "aria-controls", "aria-selected", "onClick"];
var wf = defineComponent({
  __name: "BTabs",
  props: {
    activeNavItemClass: { default: void 0 },
    activeTabClass: { default: void 0 },
    align: { default: void 0 },
    contentClass: { default: void 0 },
    card: { default: false },
    end: { default: false },
    fill: { default: false },
    id: { default: void 0 },
    justified: { default: false },
    lazy: { default: false },
    navClass: { default: void 0 },
    navWrapperClass: { default: void 0 },
    noFade: { default: false },
    noNavStyle: { default: false },
    pills: { default: false },
    small: { default: false },
    tag: { default: "div" },
    vertical: { default: false },
    modelValue: { default: -1 }
  },
  emits: ["update:modelValue", "activate-tab", "click"],
  setup(e, { emit: t }) {
    const a = e, l = Te(a, "modelValue", t), o = useSlots(), n = c(toRef(a, "card")), r = c(toRef(a, "end")), s = c(toRef(a, "fill")), f = c(toRef(a, "justified")), m = c(toRef(a, "lazy")), B = c(toRef(a, "noFade")), h2 = c(toRef(a, "noNavStyle")), v = c(toRef(a, "pills")), w = c(toRef(a, "small")), g = c(toRef(a, "vertical")), k = ref(l.value), y = ref(""), $ = computed({
      get: () => k.value,
      set: (C) => {
        k.value = C, b.value.length > 0 && C >= 0 && C < b.value.length ? y.value = b.value[C].buttonId : y.value = "", l.value = C;
      }
    }), b = computed(
      () => o.default === void 0 ? [] : ha(o.default, "BTab").map((C, F) => {
        C.props || (C.props = {});
        const P = C.props["button-id"] || at("tab"), W = C.props.id || at(), j = $.value > -1 ? F === $.value : C.props.active === "", te = C.props["title-item-class"], X = C.props["title-link-attributes"];
        return {
          buttonId: P,
          contentId: W,
          active: j,
          disabled: C.props.disabled === "" || C.props.disabled === true,
          navItemClasses: [
            {
              active: j,
              disabled: C.props.disabled === "" || C.props.disabled === true
            },
            j && a.activeNavItemClass ? a.activeNavItemClass : null,
            C.props["title-link-class"]
          ],
          tabClasses: [
            {
              fade: !B.value
            },
            j && a.activeTabClass ? a.activeTabClass : null
          ],
          target: `#${W}`,
          title: C.props.title,
          titleItemClass: te,
          titleLinkAttributes: X,
          onClick: C.props.onClick,
          tab: C,
          //TODO remove this in future since the mapped value does not provide a direct reference to the actual slot component.
          tabComponent: () => ha(o.default, "BTab")[F]
        };
      })
    ), _ = computed(() => !(b != null && b.value && b.value.length > 0)), V = computed(() => ({
      "d-flex": g.value,
      "align-items-start": g.value
    })), T = zt(toRef(a, "align")), S = computed(() => ({
      "nav-pills": v.value,
      "flex-column me-3": g.value,
      [T.value]: a.align !== void 0,
      "nav-fill": s.value,
      "card-header-tabs": n.value,
      "nav-justified": f.value,
      "nav-tabs": !h2.value && !v.value,
      small: w.value
    })), O = (C) => {
      let F = false;
      if (C !== void 0 && C > -1 && C < b.value.length && !b.value[C].disabled && ($.value < 0 || b.value[C].buttonId !== y.value)) {
        const P = new Xe("activate-tab", { cancelable: true });
        t("activate-tab", C, $.value, P), P.defaultPrevented || ($.value = C, F = true);
      }
      return !F && l.value !== $.value && (l.value = $.value), F;
    }, I = (C, F) => {
      var P;
      O(F), F >= 0 && !b.value[F].disabled && ((P = b.value[F]) != null && P.onClick) && typeof b.value[F].onClick == "function" && b.value[F].onClick(C);
    };
    return O(k.value), watch(l, (C, F) => {
      if (C === F)
        return;
      if (C = Math.max(C, -1), F = Math.max(F, -1), b.value.length <= 0) {
        $.value = -1;
        return;
      }
      const P = C > F;
      let W = C;
      const j = b.value.length - 1;
      for (; W >= 0 && W <= j && b.value[W].disabled; )
        W += P ? 1 : -1;
      if (W < 0) {
        O(0);
        return;
      }
      if (W >= b.value.length) {
        O(b.value.length - 1);
        return;
      }
      O(W);
    }), watch(b, () => {
      let C = b.value.map((F) => F.active && !F.disabled).lastIndexOf(true);
      C < 0 && ($.value >= b.value.length ? C = b.value.map((F) => !F.disabled).lastIndexOf(true) : b.value[$.value] && !b.value[$.value].disabled && (C = $.value)), C < 0 && (C = b.value.map((F) => !F.disabled).indexOf(true)), b.value.forEach((F, P) => F.active = P === C), O(C);
    }), onMounted(() => {
      if ($.value < 0 && b.value.length > 0 && !b.value.some((C) => C.active)) {
        const C = b.value.map((F) => !F.disabled).indexOf(true);
        O(C >= 0 ? C : -1);
      }
    }), provide(Bo, {
      lazy: m,
      card: n
    }), (C, F) => (openBlock(), createBlock(resolveDynamicComponent(e.tag), {
      id: e.id,
      class: normalizeClass(["tabs", unref(V)])
    }, {
      default: withCtx(() => [
        unref(r) ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(["tab-content", e.contentClass])
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(b), ({ tabComponent: P, contentId: W, tabClasses: j, active: te }, X) => (openBlock(), createBlock(resolveDynamicComponent(P()), {
            id: W,
            key: X,
            class: normalizeClass(j),
            active: te
          }, null, 8, ["id", "class", "active"]))), 128)),
          unref(_) ? (openBlock(), createElementBlock("div", {
            key: "bv-empty-tab",
            class: normalizeClass(["tab-pane active", { "card-body": unref(n) }])
          }, [
            renderSlot(C.$slots, "empty")
          ], 2)) : createCommentVNode("", true)
        ], 2)) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: normalizeClass([e.navWrapperClass, { "card-header": unref(n), "ms-auto": e.vertical && unref(r) }])
        }, [
          createBaseVNode("ul", {
            class: normalizeClass(["nav", [unref(S), e.navClass]]),
            role: "tablist"
          }, [
            renderSlot(C.$slots, "tabs-start"),
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(b), ({ tab: P, buttonId: W, contentId: j, navItemClasses: te, active: X, target: q }, ae) => {
              var me, pe, be;
              return openBlock(), createElementBlock("li", {
                key: ae,
                class: normalizeClass(["nav-item", (me = P == null ? void 0 : P.props) == null ? void 0 : me["title-item-class"]]),
                role: "presentation"
              }, [
                createBaseVNode("button", mergeProps({
                  id: W,
                  class: ["nav-link", te],
                  "data-bs-toggle": "tab",
                  "data-bs-target": q,
                  role: "tab",
                  "aria-controls": j,
                  "aria-selected": X
                }, (pe = P == null ? void 0 : P.props) == null ? void 0 : pe["title-link-attributes"], {
                  onClick: withModifiers((ne) => I(ne, ae), ["stop", "prevent"])
                }), [
                  P.children && P.children.title ? (openBlock(), createBlock(resolveDynamicComponent(P.children.title), { key: 0 })) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    createTextVNode(toDisplayString((be = P == null ? void 0 : P.props) == null ? void 0 : be.title), 1)
                  ], 64))
                ], 16, $f)
              ], 2);
            }), 128)),
            renderSlot(C.$slots, "tabs-end")
          ], 2)
        ], 2),
        unref(r) ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(["tab-content", e.contentClass])
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(b), ({ tabComponent: P, contentId: W, tabClasses: j, active: te }, X) => (openBlock(), createBlock(resolveDynamicComponent(P()), {
            id: W,
            key: X,
            class: normalizeClass(j),
            active: te
          }, null, 8, ["id", "class", "active"]))), 128)),
          unref(_) ? (openBlock(), createElementBlock("div", {
            key: "bv-empty-tab",
            class: normalizeClass(["tab-pane active", { "card-body": unref(n) }])
          }, [
            renderSlot(C.$slots, "empty")
          ], 2)) : createCommentVNode("", true)
        ], 2))
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
});
var kf = defineComponent({
  __name: "BTooltip",
  setup(e) {
    return (t, a) => (openBlock(), createBlock(Ua, { tooltip: "" }, createSlots({ _: 2 }, [
      renderList(t.$slots, (l, o) => ({
        name: o,
        fn: withCtx((n) => [
          renderSlot(t.$slots, o, normalizeProps(guardReactiveProps(n)))
        ])
      }))
    ]), 1024));
  }
});
var Cf = Object.freeze(Object.defineProperty({
  __proto__: null,
  BAccordion: or,
  BAccordionItem: dr,
  BAlert: hr,
  BAvatar: wr,
  BAvatarGroup: kr,
  BBadge: _r,
  BBreadcrumb: Or,
  BBreadcrumbItem: cn,
  BButton: kt,
  BButtonGroup: Pr,
  BButtonToolbar: Ir,
  BCard: hn,
  BCardBody: gn,
  BCardFooter: bn,
  BCardGroup: Lr,
  BCardHeader: vn,
  BCardImg: oa,
  BCardSubtitle: pn,
  BCardText: Nr,
  BCardTitle: mn,
  BCarousel: Wr,
  BCarouselSlide: Yr,
  BCloseButton: Tt,
  BCol: xt,
  BCollapse: dn,
  BContainer: nu,
  BDropdown: wn,
  BDropdownDivider: du,
  BDropdownForm: pu,
  BDropdownGroup: yu,
  BDropdownHeader: ku,
  BDropdownItem: Su,
  BDropdownItemButton: xu,
  BDropdownText: Ou,
  BForm: kn,
  BFormCheckbox: Sn,
  BFormCheckboxGroup: Du,
  BFormFloatingLabel: Fu,
  BFormGroup: Ju,
  BFormInput: ed,
  BFormInvalidFeedback: xa,
  BFormRadio: Tn,
  BFormRadioGroup: id,
  BFormRow: qt,
  BFormSelect: cd,
  BFormSelectOption: Xa,
  BFormSelectOptionGroup: xn,
  BFormSpinButton: Dc,
  BFormTag: An,
  BFormTags: _d,
  BFormText: Aa,
  BFormTextarea: Vd,
  BFormValidFeedback: Va,
  BImg: Ka,
  BInputGroup: Nd,
  BInputGroupAddon: Ja,
  BInputGroupAppend: zd,
  BInputGroupPrepend: Rd,
  BInputGroupText: Vn,
  BLink: Ne,
  BListGroup: Hd,
  BListGroupItem: Md,
  BModal: Wd,
  BNav: Ud,
  BNavForm: Kd,
  BNavItem: Zd,
  BNavItemDropdown: ec,
  BNavText: ac,
  BNavbar: lc,
  BNavbarBrand: sc,
  BNavbarNav: ic,
  BNavbarToggle: vc,
  BOffcanvas: yc,
  BOverlay: Pn,
  BPagination: xc,
  BPlaceholder: Me,
  BPlaceholderButton: Fn,
  BPlaceholderCard: Vc,
  BPlaceholderTable: Oc,
  BPlaceholderWrapper: Pc,
  BPopover: Ua,
  BProgress: Ic,
  BProgressBar: Ln,
  BRow: Nc,
  BSpinner: fa,
  BTab: Bf,
  BTable: uf,
  BTableSimple: Za,
  BTabs: wf,
  BTbody: df,
  BTd: vf,
  BTfoot: mf,
  BTh: bf,
  BThead: hf,
  BToast: $n,
  BToastContainer: Ta,
  BToastPlugin: lu,
  BToaster: Ta,
  BTooltip: kf,
  BTr: yf,
  BTransition: _t
}, Symbol.toStringTag, { value: "Module" }));
var Sf = Object.freeze(Object.defineProperty({
  __proto__: null,
  vBColorMode: rc,
  vBModal: Oa,
  vBPopover: dc,
  vBToggle: Oa,
  vBTooltip: cc
}, Symbol.toStringTag, { value: "Module" }));
var xf = Object.freeze(Object.defineProperty({
  __proto__: null,
  createBreadcrumb: Zo,
  useBreadcrumb: Qo,
  useColorMode: Wi
}, Symbol.toStringTag, { value: "Module" }));
var Af = Object.freeze(Object.defineProperty({
  __proto__: null,
  BvCarouselEvent: io,
  BvEvent: Xe,
  BvTriggerableEvent: Ft
}, Symbol.toStringTag, { value: "Module" }));
var Vf = Object.freeze(Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var Of = {
  // TODO: use options in the future
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  install(e, t = {}) {
    Object.entries(Cf).forEach(([a, l]) => {
      e.component(a, l);
    }), Object.entries(Sf).forEach(([a, l]) => {
      a.toLowerCase().startsWith("v") ? e.directive(a.slice(1), l) : e.directive(a, l);
    }), Zo(e);
  }
};
export {
  or as BAccordion,
  dr as BAccordionItem,
  hr as BAlert,
  wr as BAvatar,
  kr as BAvatarGroup,
  _r as BBadge,
  Or as BBreadcrumb,
  cn as BBreadcrumbItem,
  kt as BButton,
  Pr as BButtonGroup,
  Ir as BButtonToolbar,
  hn as BCard,
  gn as BCardBody,
  bn as BCardFooter,
  Lr as BCardGroup,
  vn as BCardHeader,
  oa as BCardImg,
  pn as BCardSubtitle,
  Nr as BCardText,
  mn as BCardTitle,
  Wr as BCarousel,
  Yr as BCarouselSlide,
  Tt as BCloseButton,
  xt as BCol,
  dn as BCollapse,
  nu as BContainer,
  wn as BDropdown,
  du as BDropdownDivider,
  pu as BDropdownForm,
  yu as BDropdownGroup,
  ku as BDropdownHeader,
  Su as BDropdownItem,
  xu as BDropdownItemButton,
  Ou as BDropdownText,
  kn as BForm,
  Sn as BFormCheckbox,
  Du as BFormCheckboxGroup,
  Fu as BFormFloatingLabel,
  Ju as BFormGroup,
  ed as BFormInput,
  xa as BFormInvalidFeedback,
  Tn as BFormRadio,
  id as BFormRadioGroup,
  qt as BFormRow,
  cd as BFormSelect,
  Xa as BFormSelectOption,
  xn as BFormSelectOptionGroup,
  Dc as BFormSpinButton,
  An as BFormTag,
  _d as BFormTags,
  Aa as BFormText,
  Vd as BFormTextarea,
  Va as BFormValidFeedback,
  Ka as BImg,
  Nd as BInputGroup,
  Ja as BInputGroupAddon,
  zd as BInputGroupAppend,
  Rd as BInputGroupPrepend,
  Vn as BInputGroupText,
  Ne as BLink,
  Hd as BListGroup,
  Md as BListGroupItem,
  Wd as BModal,
  Ud as BNav,
  Kd as BNavForm,
  Zd as BNavItem,
  ec as BNavItemDropdown,
  ac as BNavText,
  lc as BNavbar,
  sc as BNavbarBrand,
  ic as BNavbarNav,
  vc as BNavbarToggle,
  yc as BOffcanvas,
  Pn as BOverlay,
  xc as BPagination,
  Me as BPlaceholder,
  Fn as BPlaceholderButton,
  Vc as BPlaceholderCard,
  Oc as BPlaceholderTable,
  Pc as BPlaceholderWrapper,
  Ua as BPopover,
  Ic as BProgress,
  Ln as BProgressBar,
  Nc as BRow,
  fa as BSpinner,
  Bf as BTab,
  uf as BTable,
  Za as BTableSimple,
  wf as BTabs,
  df as BTbody,
  vf as BTd,
  mf as BTfoot,
  bf as BTh,
  hf as BThead,
  $n as BToast,
  Ta as BToastContainer,
  lu as BToastPlugin,
  Ta as BToaster,
  kf as BTooltip,
  yf as BTr,
  _t as BTransition,
  Of as BootstrapVueNext,
  io as BvCarouselEvent,
  Xe as BvEvent,
  Ft as BvTriggerableEvent,
  Cf as Components,
  xf as Composables,
  Sf as Directives,
  Vf as Types,
  Af as Utils,
  Zo as createBreadcrumb,
  Of as default,
  Qo as useBreadcrumb,
  Wi as useColorMode,
  Bn as useToast,
  rc as vBColorMode,
  Oa as vBModal,
  dc as vBPopover,
  Oa as vBToggle,
  cc as vBTooltip
};
//# sourceMappingURL=bootstrap-vue-next.js.map
