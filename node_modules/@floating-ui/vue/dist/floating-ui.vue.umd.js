(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@floating-ui/dom'), require('vue-demi')) :
  typeof define === 'function' && define.amd ? define(['exports', '@floating-ui/dom', 'vue-demi'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.FloatingUIVue = {}, global.FloatingUIDOM, global.VueDemi));
})(this, (function (exports, dom, vueDemi) { 'use strict';

  function unwrapElement(element) {
    var _$el;
    return (_$el = element == null ? void 0 : element.$el) != null ? _$el : element;
  }

  /**
   * Positions an inner element of the floating element such that it is centered to the reference element.
   * @param options The arrow options.
   * @see https://floating-ui.com/docs/arrow
   */
  function arrow(options) {
    return {
      name: 'arrow',
      options,
      fn(args) {
        const element = unwrapElement(vueDemi.unref(options.element));
        if (element == null) {
          return {};
        }
        return dom.arrow({
          element,
          padding: options.padding
        }).fn(args);
      }
    };
  }

  /**
   * Computes the `x` and `y` coordinates that will place the floating element next to a reference element when it is given a certain CSS positioning strategy.
   * @param reference The reference template ref.
   * @param floating The floating template ref.
   * @param options The floating options.
   * @see https://floating-ui.com/docs/vue
   */
  function useFloating(reference, floating, options) {
    if (options === void 0) {
      options = {};
    }
    const whileElementsMountedOption = options.whileElementsMounted;
    const openOption = vueDemi.computed(() => {
      var _unref;
      return (_unref = vueDemi.unref(options.open)) != null ? _unref : true;
    });
    const middlewareOption = vueDemi.computed(() => vueDemi.unref(options.middleware));
    const placementOption = vueDemi.computed(() => {
      var _unref2;
      return (_unref2 = vueDemi.unref(options.placement)) != null ? _unref2 : 'bottom';
    });
    const strategyOption = vueDemi.computed(() => {
      var _unref3;
      return (_unref3 = vueDemi.unref(options.strategy)) != null ? _unref3 : 'absolute';
    });
    const referenceElement = vueDemi.computed(() => unwrapElement(reference.value));
    const floatingElement = vueDemi.computed(() => unwrapElement(floating.value));
    const x = vueDemi.ref(null);
    const y = vueDemi.ref(null);
    const strategy = vueDemi.ref(strategyOption.value);
    const placement = vueDemi.ref(placementOption.value);
    const middlewareData = vueDemi.shallowRef({});
    const isPositioned = vueDemi.ref(false);
    let whileElementsMountedCleanup;
    function update() {
      if (referenceElement.value == null || floatingElement.value == null) {
        return;
      }
      dom.computePosition(referenceElement.value, floatingElement.value, {
        middleware: middlewareOption.value,
        placement: placementOption.value,
        strategy: strategyOption.value
      }).then(position => {
        x.value = position.x;
        y.value = position.y;
        strategy.value = position.strategy;
        placement.value = position.placement;
        middlewareData.value = position.middlewareData;
        isPositioned.value = true;
      });
    }
    function cleanup() {
      if (typeof whileElementsMountedCleanup === 'function') {
        whileElementsMountedCleanup();
        whileElementsMountedCleanup = undefined;
      }
    }
    function attach() {
      cleanup();
      if (whileElementsMountedOption === undefined) {
        update();
        return;
      }
      if (referenceElement.value != null && floatingElement.value != null) {
        whileElementsMountedCleanup = whileElementsMountedOption(referenceElement.value, floatingElement.value, update);
        return;
      }
    }
    function reset() {
      if (!openOption.value) {
        isPositioned.value = false;
      }
    }
    vueDemi.watch([middlewareOption, placementOption, strategyOption], update, {
      flush: 'sync'
    });
    vueDemi.watch([referenceElement, floatingElement], attach, {
      flush: 'sync'
    });
    vueDemi.watch(openOption, reset, {
      flush: 'sync'
    });
    if (vueDemi.getCurrentScope()) {
      vueDemi.onScopeDispose(cleanup);
    }
    return {
      x: vueDemi.shallowReadonly(x),
      y: vueDemi.shallowReadonly(y),
      strategy: vueDemi.shallowReadonly(strategy),
      placement: vueDemi.shallowReadonly(placement),
      middlewareData: vueDemi.shallowReadonly(middlewareData),
      isPositioned: vueDemi.shallowReadonly(isPositioned),
      update
    };
  }

  exports.arrow = arrow;
  exports.useFloating = useFloating;
  Object.keys(dom).forEach(function (k) {
    if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
      enumerable: true,
      get: function () { return dom[k]; }
    });
  });

  Object.defineProperty(exports, '__esModule', { value: true });

}));
